,"Copy and Paste","The Clipboard Framework","<h2 id="Clipboard">The Clipboard Framework</h2> 
 <p> When you use the clipboard framework, you put data into a clip object, and then put the clip object on the system-wide clipboard. The clip object can take one of three forms: </p> 
 <dl> 
  <dt>
   Text
  </dt> 
  <dd>
    A text string. You put the string directly into the clip object, which you then put onto the clipboard. To paste the string, you get the clip object from the clipboard and copy the string to into your application's storage. 
  </dd> 
  <dt>
   URI
  </dt> 
  <dd>
    A 
   <code><a href="../../../reference/android/net/Uri.html">Uri</a></code> object representing any form of URI. This is primarily for copying complex data from a content provider. To copy data, you put a 
   <code><a href="../../../reference/android/net/Uri.html">Uri</a></code> object into a clip object and put the clip object onto the clipboard. To paste the data, you get the clip object, get the 
   <code><a href="../../../reference/android/net/Uri.html">Uri</a></code> object, resolve it to a data source such as a content provider, and copy the data from the source into your application's storage. 
  </dd> 
  <dt>
   Intent
  </dt> 
  <dd>
    An 
   <code><a href="../../../reference/android/content/Intent.html">Intent</a></code>. This supports copying application shortcuts. To copy data, you create an Intent, put it into a clip object, and put the clip object onto the clipboard. To paste the data, you get the clip object and then copy the Intent object into your application's memory area. 
  </dd> 
 </dl> 
 <p> The clipboard holds only one clip object at a time. When an application puts a clip object on the clipboard, the previous clip object disappears. </p> 
 <p> If you want to allow users to paste data into your application, you don't have to handle all types of data. You can examine the data on the clipboard before you give users the option to paste it. Besides having a certain data form, the clip object also contains metadata that tells you what MIME type or types are available. This metadata helps you decide if your application can do something useful with the clipboard data. For example, if you have an application that primarily handles text you may want to ignore clip objects that contain a URI or Intent. </p> 
 <p> You may also want to allow users to paste text regardless of the form of data on the clipboard. To do this, you can force the clipboard data into a text representation, and then paste this text. This is described in the section <a href="#CoerceToText">Coercing the clipboard to text</a>. </p> 
 ","Uri","android.net.Uri","class",1
,"Clipboard Classes","ClipData, ClipData.Item, and ClipDescription","<h3 id="ClipClasses">ClipData, ClipData.Item, and ClipDescription</h3> 
 <p> To add data to the clipboard, you create a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object that contains both a description of the data and the data itself. The clipboard holds only one <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> at a time. A <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> contains a <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object and one or more <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects. </p> 
 <p> A <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object contains metadata about the clip. In particular, it contains an array of available MIME types for the clip's data. When you put a clip on the clipboard, this array is available to pasting applications, which can examine it to see if they can handle any of available the MIME types. </p> 
 <p> A <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains the text, URI, or Intent data: </p> 
 <dl> 
  <dt>
   Text
  </dt> 
  <dd>
    A 
   <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code>. 
  </dd> 
  <dt>
   URI
  </dt> 
  <dd>
    A 
   <code><a href="../../../reference/android/net/Uri.html">Uri</a></code>. This usually contains a content provider URI, although any URI is allowed. The application that provides the data puts the URI on the clipboard. Applications that want to paste the data get the URI from the clipboard and use it to access the content provider (or other data source) and retrieve the data. 
  </dd> 
  <dt>
   Intent
  </dt> 
  <dd>
    An 
   <code><a href="../../../reference/android/content/Intent.html">Intent</a></code>. This data type allows you to copy an application shortcut to the clipboard. Users can then paste the shortcut into their applications for later use. 
  </dd> 
 </dl> 
 <p> You can add more than one <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object to a clip. This allows users to copy and paste multiple selections as a single clip. For example, if you have a list widget that allows the user to select more than one item at a time, you can copy all the items to the clipboard at once. To do this, you create a separate <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> for each list item, and then you add the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects to the <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object. </p> 
 ","Uri","android.net.Uri","class",1
,"Clipboard Classes","ClipData convenience methods","<h3 id="ClipDataMethods">ClipData convenience methods</h3> 
 <p> The <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> class provides static convenience methods for creating a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object with a single <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object and a simple <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object: </p> 
 <dl> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newPlainText(java.lang.CharSequence, java.lang.CharSequence)">newPlainText(label, text)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains a text string. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. The single MIME type in 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> is 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_PLAIN">MIMETYPE_TEXT_PLAIN</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newPlainText(java.lang.CharSequence, java.lang.CharSequence)">newPlainText()</a></code> to create a clip from a text string. </p>
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newUri(android.content.ContentResolver, java.lang.CharSequence, android.net.Uri)">newUri(resolver, label, URI)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains a URI. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. If the URI is a content URI (
   <code><a href="../../../reference/android/net/Uri.html#getScheme()">Uri.getScheme()</a></code> returns 
   <code>content:</code>), the method uses the 
   <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> object provided in 
   <code>resolver</code> to retrieve the available MIME types from the content provider and store them in 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code>. For a URI that is not a 
   <code>content:</code> URI, the method sets the MIME type to 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_URILIST">MIMETYPE_TEXT_URILIST</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newUri(android.content.ContentResolver, java.lang.CharSequence, android.net.Uri)">newUri()</a></code> to create a clip from a URI, particularly a <code>content:</code> URI. </p> 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newIntent(java.lang.CharSequence, android.content.Intent)">newIntent(label, intent)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains an 
   <code><a href="../../../reference/android/content/Intent.html">Intent</a></code>. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. The MIME type is set to 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_INTENT">MIMETYPE_TEXT_INTENT</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newIntent(java.lang.CharSequence, android.content.Intent)">newIntent()</a></code> to create a clip from an Intent object. </p>
  </dd> 
 </dl> 
 ","Uri","android.net.Uri","class",0
,"Clipboard Classes","Coercing the clipboard data to text","<h3 id="CoerceToText">Coercing the clipboard data to text</h3> 
 <p> Even if your application only handles text, you can copy non-text data from the clipboard by converting it with the method <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">ClipData.Item.coerceToText()</a></code>. </p> 
 <p> This method converts the data in <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> to text and returns a <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code>. The value that <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">ClipData.Item.coerceToText()</a></code> returns is based on the form of data in <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code>: </p> 
 <dl> 
  <dt>
   <em>Text</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is text (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getText()">getText()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns the text. 
  </dd> 
  <dt>
   <em>URI</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is a URI (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getUri()">getUri()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> tries to use it as a content URI: 
   <ul> 
    <li> If the URI is a content URI and the provider can return a text stream, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a text stream. </li> 
    <li> If the URI is a content URI but the provider does not offer a text stream, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a representation of the URI. The representation is the same as that returned by <code><a href="../../../reference/android/net/Uri.html#toString()">Uri.toString()</a></code>. </li> 
    <li> If the URI is not a content URI, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a representation of the URI. The representation is the same as that returned by <code><a href="../../../reference/android/net/Uri.html#toString()">Uri.toString()</a></code>. </li> 
   </ul> 
  </dd> 
  <dt>
   <em>Intent</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is an Intent (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getIntent()">getIntent()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> converts it to an Intent URI and returns it. The representation is the same as that returned by 
   <code><a href="../../../reference/android/content/Intent.html#toUri(int)">Intent.toUri(URI_INTENT_SCHEME)</a></code>. 
  </dd> 
 </dl> 
 <p> The clipboard framework is summarized in Figure 1. To copy data, an application puts a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object on the <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> global clipboard. The <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> contains one or more <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects and one <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object. To paste data, an application gets the <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code>, gets its MIME type from the <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code>, and gets the data either from the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> or from the content provider referred to by <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code>. </p> 
 <a name="framework"></a> 
 <img src="../../../images/ui/clipboard/copy_paste_framework.png" alt="A block diagram of the copy and paste framework" height="400px" id="figure1" /> 
 <p class="img-caption"> <strong>Figure 1.</strong> The Android clipboard framework </p> 
 ","Uri","android.net.Uri","class",0
,"Copy and Paste","The Clipboard Framework","<h2 id="Clipboard">The Clipboard Framework</h2> 
 <p> When you use the clipboard framework, you put data into a clip object, and then put the clip object on the system-wide clipboard. The clip object can take one of three forms: </p> 
 <dl> 
  <dt>
   Text
  </dt> 
  <dd>
    A text string. You put the string directly into the clip object, which you then put onto the clipboard. To paste the string, you get the clip object from the clipboard and copy the string to into your application's storage. 
  </dd> 
  <dt>
   URI
  </dt> 
  <dd>
    A 
   <code><a href="../../../reference/android/net/Uri.html">Uri</a></code> object representing any form of URI. This is primarily for copying complex data from a content provider. To copy data, you put a 
   <code><a href="../../../reference/android/net/Uri.html">Uri</a></code> object into a clip object and put the clip object onto the clipboard. To paste the data, you get the clip object, get the 
   <code><a href="../../../reference/android/net/Uri.html">Uri</a></code> object, resolve it to a data source such as a content provider, and copy the data from the source into your application's storage. 
  </dd> 
  <dt>
   Intent
  </dt> 
  <dd>
    An 
   <code><a href="../../../reference/android/content/Intent.html">Intent</a></code>. This supports copying application shortcuts. To copy data, you create an Intent, put it into a clip object, and put the clip object onto the clipboard. To paste the data, you get the clip object and then copy the Intent object into your application's memory area. 
  </dd> 
 </dl> 
 <p> The clipboard holds only one clip object at a time. When an application puts a clip object on the clipboard, the previous clip object disappears. </p> 
 <p> If you want to allow users to paste data into your application, you don't have to handle all types of data. You can examine the data on the clipboard before you give users the option to paste it. Besides having a certain data form, the clip object also contains metadata that tells you what MIME type or types are available. This metadata helps you decide if your application can do something useful with the clipboard data. For example, if you have an application that primarily handles text you may want to ignore clip objects that contain a URI or Intent. </p> 
 <p> You may also want to allow users to paste text regardless of the form of data on the clipboard. To do this, you can force the clipboard data into a text representation, and then paste this text. This is described in the section <a href="#CoerceToText">Coercing the clipboard to text</a>. </p> 
 ","Intent","android.content.Intent","class",1
,"Clipboard Classes","ClipData, ClipData.Item, and ClipDescription","<h3 id="ClipClasses">ClipData, ClipData.Item, and ClipDescription</h3> 
 <p> To add data to the clipboard, you create a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object that contains both a description of the data and the data itself. The clipboard holds only one <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> at a time. A <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> contains a <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object and one or more <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects. </p> 
 <p> A <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object contains metadata about the clip. In particular, it contains an array of available MIME types for the clip's data. When you put a clip on the clipboard, this array is available to pasting applications, which can examine it to see if they can handle any of available the MIME types. </p> 
 <p> A <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains the text, URI, or Intent data: </p> 
 <dl> 
  <dt>
   Text
  </dt> 
  <dd>
    A 
   <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code>. 
  </dd> 
  <dt>
   URI
  </dt> 
  <dd>
    A 
   <code><a href="../../../reference/android/net/Uri.html">Uri</a></code>. This usually contains a content provider URI, although any URI is allowed. The application that provides the data puts the URI on the clipboard. Applications that want to paste the data get the URI from the clipboard and use it to access the content provider (or other data source) and retrieve the data. 
  </dd> 
  <dt>
   Intent
  </dt> 
  <dd>
    An 
   <code><a href="../../../reference/android/content/Intent.html">Intent</a></code>. This data type allows you to copy an application shortcut to the clipboard. Users can then paste the shortcut into their applications for later use. 
  </dd> 
 </dl> 
 <p> You can add more than one <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object to a clip. This allows users to copy and paste multiple selections as a single clip. For example, if you have a list widget that allows the user to select more than one item at a time, you can copy all the items to the clipboard at once. To do this, you create a separate <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> for each list item, and then you add the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects to the <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object. </p> 
 ","Intent","android.content.Intent","class",1
,"Clipboard Classes","ClipData convenience methods","<h3 id="ClipDataMethods">ClipData convenience methods</h3> 
 <p> The <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> class provides static convenience methods for creating a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object with a single <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object and a simple <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object: </p> 
 <dl> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newPlainText(java.lang.CharSequence, java.lang.CharSequence)">newPlainText(label, text)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains a text string. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. The single MIME type in 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> is 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_PLAIN">MIMETYPE_TEXT_PLAIN</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newPlainText(java.lang.CharSequence, java.lang.CharSequence)">newPlainText()</a></code> to create a clip from a text string. </p>
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newUri(android.content.ContentResolver, java.lang.CharSequence, android.net.Uri)">newUri(resolver, label, URI)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains a URI. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. If the URI is a content URI (
   <code><a href="../../../reference/android/net/Uri.html#getScheme()">Uri.getScheme()</a></code> returns 
   <code>content:</code>), the method uses the 
   <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> object provided in 
   <code>resolver</code> to retrieve the available MIME types from the content provider and store them in 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code>. For a URI that is not a 
   <code>content:</code> URI, the method sets the MIME type to 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_URILIST">MIMETYPE_TEXT_URILIST</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newUri(android.content.ContentResolver, java.lang.CharSequence, android.net.Uri)">newUri()</a></code> to create a clip from a URI, particularly a <code>content:</code> URI. </p> 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newIntent(java.lang.CharSequence, android.content.Intent)">newIntent(label, intent)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains an 
   <code><a href="../../../reference/android/content/Intent.html">Intent</a></code>. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. The MIME type is set to 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_INTENT">MIMETYPE_TEXT_INTENT</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newIntent(java.lang.CharSequence, android.content.Intent)">newIntent()</a></code> to create a clip from an Intent object. </p>
  </dd> 
 </dl> 
 ","Intent","android.content.Intent","class",0
,"Clipboard Classes","Coercing the clipboard data to text","<h3 id="CoerceToText">Coercing the clipboard data to text</h3> 
 <p> Even if your application only handles text, you can copy non-text data from the clipboard by converting it with the method <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">ClipData.Item.coerceToText()</a></code>. </p> 
 <p> This method converts the data in <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> to text and returns a <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code>. The value that <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">ClipData.Item.coerceToText()</a></code> returns is based on the form of data in <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code>: </p> 
 <dl> 
  <dt>
   <em>Text</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is text (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getText()">getText()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns the text. 
  </dd> 
  <dt>
   <em>URI</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is a URI (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getUri()">getUri()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> tries to use it as a content URI: 
   <ul> 
    <li> If the URI is a content URI and the provider can return a text stream, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a text stream. </li> 
    <li> If the URI is a content URI but the provider does not offer a text stream, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a representation of the URI. The representation is the same as that returned by <code><a href="../../../reference/android/net/Uri.html#toString()">Uri.toString()</a></code>. </li> 
    <li> If the URI is not a content URI, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a representation of the URI. The representation is the same as that returned by <code><a href="../../../reference/android/net/Uri.html#toString()">Uri.toString()</a></code>. </li> 
   </ul> 
  </dd> 
  <dt>
   <em>Intent</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is an Intent (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getIntent()">getIntent()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> converts it to an Intent URI and returns it. The representation is the same as that returned by 
   <code><a href="../../../reference/android/content/Intent.html#toUri(int)">Intent.toUri(URI_INTENT_SCHEME)</a></code>. 
  </dd> 
 </dl> 
 <p> The clipboard framework is summarized in Figure 1. To copy data, an application puts a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object on the <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> global clipboard. The <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> contains one or more <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects and one <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object. To paste data, an application gets the <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code>, gets its MIME type from the <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code>, and gets the data either from the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> or from the content provider referred to by <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code>. </p> 
 <a name="framework"></a> 
 <img src="../../../images/ui/clipboard/copy_paste_framework.png" alt="A block diagram of the copy and paste framework" height="400px" id="figure1" /> 
 <p class="img-caption"> <strong>Figure 1.</strong> The Android clipboard framework </p> 
 ","Intent","android.content.Intent","class",1
,"Copy and Paste","Designing Effective Copy/Paste Functionality","<h2 id="DataDesign">Designing Effective Copy/Paste Functionality</h2> 
 <p> To design effective copy and paste functionality for your application, remember these points: </p> 
 <ul> 
  <li> At any time, there is only one clip on the clipboard. A new copy operation by any application in the system overwrites the previous clip. Since the user may navigate away from your application and do a copy before returning, you can't assume that the clipboard contains the clip that the user previously copied in <em>your</em> application. </li> 
  <li> The intended purpose of multiple <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects per clip is to support copying and pasting of multiple selections rather than different forms of reference to a single selection. You usually want all of the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects in a clip to have the same form, that is, they should all be simple text, content URI, or <code><a href="../../../reference/android/content/Intent.html">Intent</a></code>, but not a mixture. </li> 
  <li> When you provide data, you can offer different MIME representations. Add the MIME types you support to the <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code>, and then implement the MIME types in your content provider. </li> 
  <li> When you get data from the clipboard, your application is responsible for checking the available MIME types and then deciding which one, if any, to use. Even if there is a clip on the clipboard and the user requests a paste, your application is not required to do the paste. You <em>should</em> do the paste if the MIME type is compatible. You may choose to coerce the data on the clipboard to text using <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> if you choose. If your application supports more than one of the available MIME types, you can allow the user to choose which one to use. </li> 
 </ul> 
</div> 
","Intent","android.content.Intent","class",0
,"Creating an Input Method","Declaring IME Components in the Manifest","<h2 id="DefiningIME">Declaring IME Components in the Manifest</h2> 
 <p> In the Android system, an IME is an Android application that contains a special IME service. The application's manifest file must declare the service, request the necessary permissions, provide an intent filter that matches the action <code>action.view.InputMethod</code>, and provide metadata that defines characteristics of the IME. In addition, to provide a settings interface that allows the user to modify the behavior of the IME, you can define a &quot;settings&quot; activity that can be launched from System Settings. </p> 
 <p> The following snippet declares IME service. It requests the permission <code><a href="../../../reference/android/Manifest.permission.html#BIND_INPUT_METHOD">BIND_INPUT_METHOD</a></code> to allow the service to connect the IME to the system, sets up an intent filter that matches the action <code>android.view.InputMethod</code>, and defines metadata for the IME: </p> 
 <pre>
&lt;!-- Declares the input method service --&gt;
    &lt;service android:name=&quot;FastInputIME&quot;
        android:label=&quot;@string/fast_input_label&quot;
        android:permission=&quot;android.permission.BIND_INPUT_METHOD&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.view.InputMethod&quot; /&gt;
        &lt;/intent-filter&gt;
        &lt;meta-data android:name=&quot;android.view.im&quot; android:resource=&quot;@xml/method&quot; /&gt;
    &lt;/service&gt;
</pre> 
 <p> This next snippet declares the settings activity for the IME. It has an intent filter for <code><a href="../../../reference/android/content/Intent.html#ACTION_MAIN">ACTION_MAIN</a></code> that indicates this activity is the main entry point for the IME application:</p> 
 <pre>
    &lt;!-- Optional: an activity for controlling the IME settings --&gt;
    &lt;activity android:name=&quot;FastInputIMESettings&quot; 
        android:label=&quot;@string/fast_input_settings&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
</pre> 
 <p> You can also provide access to the IME's settings directly from its UI. </p> 
 ","Intent","android.content.Intent","class",1
,"Clipboard Classes","ClipboardManager","<h3 id="ClipboardManager">ClipboardManager</h3> 
 <p> In the Android system, the system clipboard is represented by the global <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> class. You do not instantiate this class directly; instead, you get a reference to it by invoking <code><a href="../../../reference/android/content/Context.html#getSystemService(java.lang.String)">getSystemService(CLIPBOARD_SERVICE)</a></code>. </p> 
 ","Context","android.content.Context","class",0
,"Pasting from the Clipboard","Pasting plain text","<h3 id="PastePlainText">Pasting plain text</h3> 
 <p> To paste plain text, first get the global clipboard and verify that it can return plain text. Then get the clip object and copy its text to your own storage using <code><a href="../../../reference/android/content/ClipData.Item.html#getText()">getText()</a></code>, as described in the following procedure: </p> 
 <ol> 
  <li> Get the global <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> object using <code><a href="../../../reference/android/content/Context.html#getSystemService(java.lang.String)">getSystemService(CLIPBOARD_SERVICE)</a></code>. Also declare a global variable to contain the pasted text: <pre>
ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);

String pasteData = &quot;&quot;;

</pre> </li> 
  <li> Next, determine if you should enable or disable the &quot;paste&quot; option in the current Activity. You should verify that the clipboard contains a clip and that you can handle the type of data represented by the clip: <pre>
// Gets the ID of the &quot;paste&quot; menu item
MenuItem mPasteItem = menu.findItem(R.id.menu_paste);

// If the clipboard doesn't contain data, disable the paste menu item.
// If it does contain data, decide if you can handle the data.
if (!(clipboard.hasPrimaryClip())) {

    mPasteItem.setEnabled(false);

    } else if (!(clipboard.getPrimaryClipDescription().hasMimeType(MIMETYPE_TEXT_PLAIN))) {

        // This disables the paste menu item, since the clipboard has data but it is not plain text
        mPasteItem.setEnabled(false);
    } else {

        // This enables the paste menu item, since the clipboard contains plain text.
        mPasteItem.setEnabled(true);
    }
}
</pre> </li> 
  <li> Copy the data from the clipboard. This point in the program is only reachable if the &quot;paste&quot; menu item is enabled, so you can assume that the clipboard contains plain text. You do not yet know if it contains a text string or a URI that points to plain text. The following snippet tests this, but it only shows the code for handling plain text: <pre>
// Responds to the user selecting &quot;paste&quot;
case R.id.menu_paste:

// Examines the item on the clipboard. If getText() does not return null, the clip item contains the
// text. Assumes that this application can only handle one item at a time.
 ClipData.Item item = clipboard.getPrimaryClip().getItemAt(0);

// Gets the clipboard as text.
pasteData = item.getText();

// If the string contains data, then the paste operation is done
if (pasteData != null) {
    return;

// The clipboard does not contain text. If it contains a URI, attempts to get data from it
} else {
    Uri pasteUri = item.getUri();

    // If the URI contains something, try to get text from it
    if (pasteUri != null) {

        // calls a routine to resolve the URI and get data from it. This routine is not
        // presented here.
        pasteData = resolveUri(Uri);
        return;
    } else {

    // Something is wrong. The MIME type was plain text, but the clipboard does not contain either
    // text or a Uri. Report an error.
    Log.e(&quot;Clipboard contains an invalid data type&quot;);
    return;
    }
}
</pre> </li> 
 </ol> 
 ","Context","android.content.Context","class",0
,"Clipboard Classes","ClipboardManager","<h3 id="ClipboardManager">ClipboardManager</h3> 
 <p> In the Android system, the system clipboard is represented by the global <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> class. You do not instantiate this class directly; instead, you get a reference to it by invoking <code><a href="../../../reference/android/content/Context.html#getSystemService(java.lang.String)">getSystemService(CLIPBOARD_SERVICE)</a></code>. </p> 
 ","ClipboardManager","android.content.ClipboardManager","class",1
,"Clipboard Classes","Coercing the clipboard data to text","<h3 id="CoerceToText">Coercing the clipboard data to text</h3> 
 <p> Even if your application only handles text, you can copy non-text data from the clipboard by converting it with the method <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">ClipData.Item.coerceToText()</a></code>. </p> 
 <p> This method converts the data in <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> to text and returns a <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code>. The value that <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">ClipData.Item.coerceToText()</a></code> returns is based on the form of data in <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code>: </p> 
 <dl> 
  <dt>
   <em>Text</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is text (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getText()">getText()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns the text. 
  </dd> 
  <dt>
   <em>URI</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is a URI (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getUri()">getUri()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> tries to use it as a content URI: 
   <ul> 
    <li> If the URI is a content URI and the provider can return a text stream, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a text stream. </li> 
    <li> If the URI is a content URI but the provider does not offer a text stream, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a representation of the URI. The representation is the same as that returned by <code><a href="../../../reference/android/net/Uri.html#toString()">Uri.toString()</a></code>. </li> 
    <li> If the URI is not a content URI, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a representation of the URI. The representation is the same as that returned by <code><a href="../../../reference/android/net/Uri.html#toString()">Uri.toString()</a></code>. </li> 
   </ul> 
  </dd> 
  <dt>
   <em>Intent</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is an Intent (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getIntent()">getIntent()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> converts it to an Intent URI and returns it. The representation is the same as that returned by 
   <code><a href="../../../reference/android/content/Intent.html#toUri(int)">Intent.toUri(URI_INTENT_SCHEME)</a></code>. 
  </dd> 
 </dl> 
 <p> The clipboard framework is summarized in Figure 1. To copy data, an application puts a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object on the <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> global clipboard. The <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> contains one or more <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects and one <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object. To paste data, an application gets the <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code>, gets its MIME type from the <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code>, and gets the data either from the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> or from the content provider referred to by <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code>. </p> 
 <a name="framework"></a> 
 <img src="../../../images/ui/clipboard/copy_paste_framework.png" alt="A block diagram of the copy and paste framework" height="400px" id="figure1" /> 
 <p class="img-caption"> <strong>Figure 1.</strong> The Android clipboard framework </p> 
 ","ClipboardManager","android.content.ClipboardManager","class",0
,"Copy and Paste","Copying to the Clipboard","<h2 id="Copying">Copying to the Clipboard</h2> 
 <p> As described previously, to copy data to the clipboard you get a handle to the global <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> object, create a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object, add a <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> and one or more <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects to it, and add the finished <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object to the <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> object. This is described in detail in the following procedure: </p> 
 <ol> 
  <li> If you are copying data using a content URI, set up a content provider. <p> The <a href="../../../resources/samples/NotePad/index.html"> Note Pad</a> sample application is an example of using a content provider for copying and pasting. The <a href="../../../resources/samples/NotePad/src/com/example/android/notepad/NotePadProvider.html"> NotePadProvider</a> class implements the content provider. The <a href="../../../resources/samples/NotePad/src/com/example/android/notepad/NotePad.html"> NotePad</a> class defines a contract between the provider and other applications, including the supported MIME types. </p> </li> 
  <li> Get the system clipboard: <pre>

...

// if the user selects copy
case R.id.menu_copy:

// Gets a handle to the clipboard service.
ClipboardManager clipboard = (ClipboardManager)
        getSystemService(Context.CLIPBOARD_SERVICE);
</pre> </li> 
  <li> <p> Copy the data to a new <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object: </p> 
   <ul> 
    <li> <h4>For text</h4> <pre>
// Creates a new text clip to put on the clipboard
ClipData clip = ClipData.newPlainText(&quot;simple text&quot;,&quot;Hello, World!&quot;);
</pre> </li> 
    <li> <h4>For a URI</h4> <p> This snippet constructs a URI by encoding a record ID onto the content URI for the provider. This technique is covered in more detail in the section <a href="#Encoding">Encoding an identifier on the URI</a>: </p> <pre>
// Creates a Uri based on a base Uri and a record ID based on the contact's last name
// Declares the base URI string
private static final String CONTACTS = &quot;content://com.example.contacts&quot;;

// Declares a path string for URIs that you use to copy data
private static final String COPY_PATH = &quot;/copy&quot;;

// Declares the Uri to paste to the clipboard
Uri copyUri = Uri.parse(CONTACTS + COPY_PATH + &quot;/&quot; + lastName);

...

// Creates a new URI clip object. The system uses the anonymous getContentResolver() object to
// get MIME types from provider. The clip object's label is &quot;URI&quot;, and its data is
// the Uri previously created.
ClipData clip = ClipData.newUri(getContentResolver(),&quot;URI&quot;,copyUri);
</pre> </li> 
    <li> <h4>For an Intent</h4> <p> This snippet constructs an Intent for an application and then puts it in the clip object: </p> <pre>
// Creates the Intent
Intent appIntent = new Intent(this, com.example.demo.myapplication.class);

...

// Creates a clip object with the Intent in it. Its label is &quot;Intent&quot; and its data is
// the Intent object created previously
ClipData clip = ClipData.newIntent(&quot;Intent&quot;,appIntent);
</pre> </li> 
   </ul> </li> 
  <li> Put the new clip object on the clipboard: <pre>
// Set the clipboard's primary clip.
clipboard.setPrimaryClip(clip);
</pre> </li> 
 </ol> 
 ","ClipboardManager","android.content.ClipboardManager","class",1
,"Pasting from the Clipboard","Pasting plain text","<h3 id="PastePlainText">Pasting plain text</h3> 
 <p> To paste plain text, first get the global clipboard and verify that it can return plain text. Then get the clip object and copy its text to your own storage using <code><a href="../../../reference/android/content/ClipData.Item.html#getText()">getText()</a></code>, as described in the following procedure: </p> 
 <ol> 
  <li> Get the global <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> object using <code><a href="../../../reference/android/content/Context.html#getSystemService(java.lang.String)">getSystemService(CLIPBOARD_SERVICE)</a></code>. Also declare a global variable to contain the pasted text: <pre>
ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);

String pasteData = &quot;&quot;;

</pre> </li> 
  <li> Next, determine if you should enable or disable the &quot;paste&quot; option in the current Activity. You should verify that the clipboard contains a clip and that you can handle the type of data represented by the clip: <pre>
// Gets the ID of the &quot;paste&quot; menu item
MenuItem mPasteItem = menu.findItem(R.id.menu_paste);

// If the clipboard doesn't contain data, disable the paste menu item.
// If it does contain data, decide if you can handle the data.
if (!(clipboard.hasPrimaryClip())) {

    mPasteItem.setEnabled(false);

    } else if (!(clipboard.getPrimaryClipDescription().hasMimeType(MIMETYPE_TEXT_PLAIN))) {

        // This disables the paste menu item, since the clipboard has data but it is not plain text
        mPasteItem.setEnabled(false);
    } else {

        // This enables the paste menu item, since the clipboard contains plain text.
        mPasteItem.setEnabled(true);
    }
}
</pre> </li> 
  <li> Copy the data from the clipboard. This point in the program is only reachable if the &quot;paste&quot; menu item is enabled, so you can assume that the clipboard contains plain text. You do not yet know if it contains a text string or a URI that points to plain text. The following snippet tests this, but it only shows the code for handling plain text: <pre>
// Responds to the user selecting &quot;paste&quot;
case R.id.menu_paste:

// Examines the item on the clipboard. If getText() does not return null, the clip item contains the
// text. Assumes that this application can only handle one item at a time.
 ClipData.Item item = clipboard.getPrimaryClip().getItemAt(0);

// Gets the clipboard as text.
pasteData = item.getText();

// If the string contains data, then the paste operation is done
if (pasteData != null) {
    return;

// The clipboard does not contain text. If it contains a URI, attempts to get data from it
} else {
    Uri pasteUri = item.getUri();

    // If the URI contains something, try to get text from it
    if (pasteUri != null) {

        // calls a routine to resolve the URI and get data from it. This routine is not
        // presented here.
        pasteData = resolveUri(Uri);
        return;
    } else {

    // Something is wrong. The MIME type was plain text, but the clipboard does not contain either
    // text or a Uri. Report an error.
    Log.e(&quot;Clipboard contains an invalid data type&quot;);
    return;
    }
}
</pre> </li> 
 </ol> 
 ","ClipboardManager","android.content.ClipboardManager","class",1
,"Clipboard Classes","ClipData, ClipData.Item, and ClipDescription","<h3 id="ClipClasses">ClipData, ClipData.Item, and ClipDescription</h3> 
 <p> To add data to the clipboard, you create a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object that contains both a description of the data and the data itself. The clipboard holds only one <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> at a time. A <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> contains a <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object and one or more <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects. </p> 
 <p> A <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object contains metadata about the clip. In particular, it contains an array of available MIME types for the clip's data. When you put a clip on the clipboard, this array is available to pasting applications, which can examine it to see if they can handle any of available the MIME types. </p> 
 <p> A <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains the text, URI, or Intent data: </p> 
 <dl> 
  <dt>
   Text
  </dt> 
  <dd>
    A 
   <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code>. 
  </dd> 
  <dt>
   URI
  </dt> 
  <dd>
    A 
   <code><a href="../../../reference/android/net/Uri.html">Uri</a></code>. This usually contains a content provider URI, although any URI is allowed. The application that provides the data puts the URI on the clipboard. Applications that want to paste the data get the URI from the clipboard and use it to access the content provider (or other data source) and retrieve the data. 
  </dd> 
  <dt>
   Intent
  </dt> 
  <dd>
    An 
   <code><a href="../../../reference/android/content/Intent.html">Intent</a></code>. This data type allows you to copy an application shortcut to the clipboard. Users can then paste the shortcut into their applications for later use. 
  </dd> 
 </dl> 
 <p> You can add more than one <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object to a clip. This allows users to copy and paste multiple selections as a single clip. For example, if you have a list widget that allows the user to select more than one item at a time, you can copy all the items to the clipboard at once. To do this, you create a separate <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> for each list item, and then you add the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects to the <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object. </p> 
 ","ClipData","android.content.ClipData","class",1
,"Clipboard Classes","ClipData convenience methods","<h3 id="ClipDataMethods">ClipData convenience methods</h3> 
 <p> The <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> class provides static convenience methods for creating a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object with a single <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object and a simple <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object: </p> 
 <dl> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newPlainText(java.lang.CharSequence, java.lang.CharSequence)">newPlainText(label, text)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains a text string. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. The single MIME type in 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> is 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_PLAIN">MIMETYPE_TEXT_PLAIN</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newPlainText(java.lang.CharSequence, java.lang.CharSequence)">newPlainText()</a></code> to create a clip from a text string. </p>
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newUri(android.content.ContentResolver, java.lang.CharSequence, android.net.Uri)">newUri(resolver, label, URI)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains a URI. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. If the URI is a content URI (
   <code><a href="../../../reference/android/net/Uri.html#getScheme()">Uri.getScheme()</a></code> returns 
   <code>content:</code>), the method uses the 
   <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> object provided in 
   <code>resolver</code> to retrieve the available MIME types from the content provider and store them in 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code>. For a URI that is not a 
   <code>content:</code> URI, the method sets the MIME type to 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_URILIST">MIMETYPE_TEXT_URILIST</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newUri(android.content.ContentResolver, java.lang.CharSequence, android.net.Uri)">newUri()</a></code> to create a clip from a URI, particularly a <code>content:</code> URI. </p> 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newIntent(java.lang.CharSequence, android.content.Intent)">newIntent(label, intent)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains an 
   <code><a href="../../../reference/android/content/Intent.html">Intent</a></code>. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. The MIME type is set to 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_INTENT">MIMETYPE_TEXT_INTENT</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newIntent(java.lang.CharSequence, android.content.Intent)">newIntent()</a></code> to create a clip from an Intent object. </p>
  </dd> 
 </dl> 
 ","ClipData","android.content.ClipData","class",1
,"Clipboard Classes","Coercing the clipboard data to text","<h3 id="CoerceToText">Coercing the clipboard data to text</h3> 
 <p> Even if your application only handles text, you can copy non-text data from the clipboard by converting it with the method <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">ClipData.Item.coerceToText()</a></code>. </p> 
 <p> This method converts the data in <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> to text and returns a <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code>. The value that <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">ClipData.Item.coerceToText()</a></code> returns is based on the form of data in <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code>: </p> 
 <dl> 
  <dt>
   <em>Text</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is text (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getText()">getText()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns the text. 
  </dd> 
  <dt>
   <em>URI</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is a URI (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getUri()">getUri()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> tries to use it as a content URI: 
   <ul> 
    <li> If the URI is a content URI and the provider can return a text stream, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a text stream. </li> 
    <li> If the URI is a content URI but the provider does not offer a text stream, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a representation of the URI. The representation is the same as that returned by <code><a href="../../../reference/android/net/Uri.html#toString()">Uri.toString()</a></code>. </li> 
    <li> If the URI is not a content URI, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a representation of the URI. The representation is the same as that returned by <code><a href="../../../reference/android/net/Uri.html#toString()">Uri.toString()</a></code>. </li> 
   </ul> 
  </dd> 
  <dt>
   <em>Intent</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is an Intent (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getIntent()">getIntent()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> converts it to an Intent URI and returns it. The representation is the same as that returned by 
   <code><a href="../../../reference/android/content/Intent.html#toUri(int)">Intent.toUri(URI_INTENT_SCHEME)</a></code>. 
  </dd> 
 </dl> 
 <p> The clipboard framework is summarized in Figure 1. To copy data, an application puts a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object on the <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> global clipboard. The <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> contains one or more <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects and one <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object. To paste data, an application gets the <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code>, gets its MIME type from the <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code>, and gets the data either from the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> or from the content provider referred to by <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code>. </p> 
 <a name="framework"></a> 
 <img src="../../../images/ui/clipboard/copy_paste_framework.png" alt="A block diagram of the copy and paste framework" height="400px" id="figure1" /> 
 <p class="img-caption"> <strong>Figure 1.</strong> The Android clipboard framework </p> 
 ","ClipData","android.content.ClipData","class",0
,"Copy and Paste","Copying to the Clipboard","<h2 id="Copying">Copying to the Clipboard</h2> 
 <p> As described previously, to copy data to the clipboard you get a handle to the global <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> object, create a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object, add a <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> and one or more <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects to it, and add the finished <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object to the <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> object. This is described in detail in the following procedure: </p> 
 <ol> 
  <li> If you are copying data using a content URI, set up a content provider. <p> The <a href="../../../resources/samples/NotePad/index.html"> Note Pad</a> sample application is an example of using a content provider for copying and pasting. The <a href="../../../resources/samples/NotePad/src/com/example/android/notepad/NotePadProvider.html"> NotePadProvider</a> class implements the content provider. The <a href="../../../resources/samples/NotePad/src/com/example/android/notepad/NotePad.html"> NotePad</a> class defines a contract between the provider and other applications, including the supported MIME types. </p> </li> 
  <li> Get the system clipboard: <pre>

...

// if the user selects copy
case R.id.menu_copy:

// Gets a handle to the clipboard service.
ClipboardManager clipboard = (ClipboardManager)
        getSystemService(Context.CLIPBOARD_SERVICE);
</pre> </li> 
  <li> <p> Copy the data to a new <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object: </p> 
   <ul> 
    <li> <h4>For text</h4> <pre>
// Creates a new text clip to put on the clipboard
ClipData clip = ClipData.newPlainText(&quot;simple text&quot;,&quot;Hello, World!&quot;);
</pre> </li> 
    <li> <h4>For a URI</h4> <p> This snippet constructs a URI by encoding a record ID onto the content URI for the provider. This technique is covered in more detail in the section <a href="#Encoding">Encoding an identifier on the URI</a>: </p> <pre>
// Creates a Uri based on a base Uri and a record ID based on the contact's last name
// Declares the base URI string
private static final String CONTACTS = &quot;content://com.example.contacts&quot;;

// Declares a path string for URIs that you use to copy data
private static final String COPY_PATH = &quot;/copy&quot;;

// Declares the Uri to paste to the clipboard
Uri copyUri = Uri.parse(CONTACTS + COPY_PATH + &quot;/&quot; + lastName);

...

// Creates a new URI clip object. The system uses the anonymous getContentResolver() object to
// get MIME types from provider. The clip object's label is &quot;URI&quot;, and its data is
// the Uri previously created.
ClipData clip = ClipData.newUri(getContentResolver(),&quot;URI&quot;,copyUri);
</pre> </li> 
    <li> <h4>For an Intent</h4> <p> This snippet constructs an Intent for an application and then puts it in the clip object: </p> <pre>
// Creates the Intent
Intent appIntent = new Intent(this, com.example.demo.myapplication.class);

...

// Creates a clip object with the Intent in it. Its label is &quot;Intent&quot; and its data is
// the Intent object created previously
ClipData clip = ClipData.newIntent(&quot;Intent&quot;,appIntent);
</pre> </li> 
   </ul> </li> 
  <li> Put the new clip object on the clipboard: <pre>
// Set the clipboard's primary clip.
clipboard.setPrimaryClip(clip);
</pre> </li> 
 </ol> 
 ","ClipData","android.content.ClipData","class",0
,"Using Content Providers to Copy Complex Data","Copying data structures","<h3 id="Records">Copying data structures</h3> 
 <p> You set up a content provider for copying and pasting complex data as a subclass of the <code><a href="../../../reference/android/content/ContentProvider.html">ContentProvider</a></code> component. You should also encode the URI you put on the clipboard so that it points to the exact record you want to provide. In addition, you have to consider the existing state of your application: </p> 
 <ul> 
  <li> If you already have a content provider, you can add to its functionality. You may only need to modify its <code><a href="../../../reference/android/content/ContentResolver.html#query(android.net.Uri, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String)">query()</a></code> method to handle URIs coming from applications that want to paste data. You will probably want to modify the method to handle a &quot;copy&quot; URI pattern. </li> 
  <li> If your application maintains an internal database, you may want to move this database into a content provider to facilitate copying from it. </li> 
  <li> If you are not currently using a database, you can implement a simple content provider whose sole purpose is to offer data to applications that are pasting from the clipboard. </li> 
 </ul> 
 <p> In the content provider, you will want to override at least the following methods: </p> 
 <dl> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentResolver.html#query(android.net.Uri, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String)">query()</a></code> 
  </dt> 
  <dd>
    Pasting applications will assume that they can get your data by using this method with the URI you put on the clipboard. To support copying, you should have this method detect URIs that contain a special &quot;copy&quot; path. Your application can then create a &quot;copy&quot; URI to put on the clipboard, containing the copy path and a pointer to the exact record you want to copy. 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#getType(android.net.Uri)">getType()</a></code> 
  </dt> 
  <dd>
    This method should return the MIME type or types for the data you intend to copy. The method 
   <code><a href="../../../reference/android/content/ClipData.html#newUri(android.content.ContentResolver, java.lang.CharSequence, android.net.Uri)">newUri()</a></code> calls 
   <code><a href="../../../reference/android/content/ContentProvider.html#getType(android.net.Uri)">getType()</a></code> in order to put the MIME types into the new 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object. 
   <p> MIME types for complex data are described in the topic <a href="../../../guide/topics/providers/content-providers.html">Content Providers</a>. </p> 
  </dd> 
 </dl> 
 <p> Notice that you don't have to have any of the other content provider methods such as <code><a href="../../../reference/android/content/ContentProvider.html#insert(android.net.Uri, android.content.ContentValues)">insert()</a></code> or <code><a href="../../../reference/android/content/ContentProvider.html#update(android.net.Uri, android.content.ContentValues, java.lang.String, java.lang.String[])">update()</a></code>. A pasting application only needs to get your supported MIME types and copy data from your provider. If you already have these methods, they won't interfere with copy operations. </p> 
 <p> The following snippets demonsrate how to set up your application to copy complex data: </p> 
 <ol> 
  <li> <p> In the global constants for your application, declare a base URI string and a path that identifies URI strings you are using to copy data. Also declare a MIME type for the copied data: </p> <pre>
// Declares the base URI string
private static final String CONTACTS = &quot;content://com.example.contacts&quot;;

// Declares a path string for URIs that you use to copy data
private static final String COPY_PATH = &quot;/copy&quot;;

// Declares a MIME type for the copied data
public static final String MIME_TYPE_CONTACT = &quot;vnd.android.cursor.item/vnd.example.contact&quot;
</pre> </li> 
  <li> In the Activity from which users copy data, set up the code to copy data to the clipboard. In response to a copy request, put the URI on the clipboard: <pre>
public class MyCopyActivity extends Activity {

    ...

// The user has selected a name and is requesting a copy.
case R.id.menu_copy:

    // Appends the last name to the base URI
    // The name is stored in &quot;lastName&quot;
    uriString = CONTACTS + COPY_PATH + &quot;/&quot; + lastName;

    // Parses the string into a URI
    Uri copyUri = Uri.parse(uriString);

    // Gets a handle to the clipboard service.
    ClipboardManager clipboard = (ClipboardManager)
        getSystemService(Context.CLIPBOARD_SERVICE);

    ClipData clip = ClipData.newUri(getContentResolver(), &quot;URI&quot;, copyUri);

    // Set the clipboard's primary clip.
    clipboard.setPrimaryClip(clip);
</pre> </li> 
  <li> <p> In the global scope of your content provider, create a URI matcher and add a URI pattern that will match URIs you put on the clipboard: </p> <pre>
public class MyCopyProvider extends ContentProvider {

    ...

// A Uri Match object that simplifies matching content URIs to patterns.
private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);

// An integer to use in switching based on the incoming URI pattern
private static final int GET_SINGLE_CONTACT = 0;

...

// Adds a matcher for the content URI. It matches
// &quot;content://com.example.contacts/copy/*&quot;
sUriMatcher.addURI(CONTACTS, &quot;names/*&quot;, GET_SINGLE_CONTACT);
</pre> </li> 
  <li> <p> Set up the <code><a href="../../../reference/android/content/ContentProvider.html#query(android.net.Uri, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String)">query()</a></code> method. This method can handle different URI patterns, depending on how you code it, but only the pattern for the clipboard copying operation is shown: </p> <pre>
// Sets up your provider's query() method.
public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
    String sortOrder) {

    ...

    // Switch based on the incoming content URI
    switch (sUriMatcher.match(uri)) {

    case GET_SINGLE_CONTACT:

        // query and return the contact for the requested name. Here you would decode
        // the incoming URI, query the data model based on the last name, and return the result
        // as a Cursor.

    ...

}
</pre> </li> 
  <li> <p> Set up the <code><a href="../../../reference/android/content/ContentProvider.html#getType(android.net.Uri)">getType()</a></code> method to return an appropriate MIME type for copied data: </p> <pre>
// Sets up your provider's getType() method.
public String getType(Uri uri) {

    ...

    switch (sUriMatcher.match(uri)) {

    case GET_SINGLE_CONTACT:

            return (MIME_TYPE_CONTACT);
</pre> </li> 
 </ol> 
 <p> The section <a href="#PasteContentUri">Pasting data from a content URI</a> describes how to get a content URI from the clipboard and use it to get and paste data. </p> 
 ","ClipData","android.content.ClipData","class",0
,"Clipboard Classes","ClipData, ClipData.Item, and ClipDescription","<h3 id="ClipClasses">ClipData, ClipData.Item, and ClipDescription</h3> 
 <p> To add data to the clipboard, you create a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object that contains both a description of the data and the data itself. The clipboard holds only one <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> at a time. A <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> contains a <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object and one or more <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects. </p> 
 <p> A <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object contains metadata about the clip. In particular, it contains an array of available MIME types for the clip's data. When you put a clip on the clipboard, this array is available to pasting applications, which can examine it to see if they can handle any of available the MIME types. </p> 
 <p> A <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains the text, URI, or Intent data: </p> 
 <dl> 
  <dt>
   Text
  </dt> 
  <dd>
    A 
   <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code>. 
  </dd> 
  <dt>
   URI
  </dt> 
  <dd>
    A 
   <code><a href="../../../reference/android/net/Uri.html">Uri</a></code>. This usually contains a content provider URI, although any URI is allowed. The application that provides the data puts the URI on the clipboard. Applications that want to paste the data get the URI from the clipboard and use it to access the content provider (or other data source) and retrieve the data. 
  </dd> 
  <dt>
   Intent
  </dt> 
  <dd>
    An 
   <code><a href="../../../reference/android/content/Intent.html">Intent</a></code>. This data type allows you to copy an application shortcut to the clipboard. Users can then paste the shortcut into their applications for later use. 
  </dd> 
 </dl> 
 <p> You can add more than one <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object to a clip. This allows users to copy and paste multiple selections as a single clip. For example, if you have a list widget that allows the user to select more than one item at a time, you can copy all the items to the clipboard at once. To do this, you create a separate <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> for each list item, and then you add the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects to the <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object. </p> 
 ","CharSequence","java.lang.CharSequence","class",0
,"Clipboard Classes","Coercing the clipboard data to text","<h3 id="CoerceToText">Coercing the clipboard data to text</h3> 
 <p> Even if your application only handles text, you can copy non-text data from the clipboard by converting it with the method <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">ClipData.Item.coerceToText()</a></code>. </p> 
 <p> This method converts the data in <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> to text and returns a <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code>. The value that <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">ClipData.Item.coerceToText()</a></code> returns is based on the form of data in <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code>: </p> 
 <dl> 
  <dt>
   <em>Text</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is text (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getText()">getText()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns the text. 
  </dd> 
  <dt>
   <em>URI</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is a URI (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getUri()">getUri()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> tries to use it as a content URI: 
   <ul> 
    <li> If the URI is a content URI and the provider can return a text stream, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a text stream. </li> 
    <li> If the URI is a content URI but the provider does not offer a text stream, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a representation of the URI. The representation is the same as that returned by <code><a href="../../../reference/android/net/Uri.html#toString()">Uri.toString()</a></code>. </li> 
    <li> If the URI is not a content URI, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a representation of the URI. The representation is the same as that returned by <code><a href="../../../reference/android/net/Uri.html#toString()">Uri.toString()</a></code>. </li> 
   </ul> 
  </dd> 
  <dt>
   <em>Intent</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is an Intent (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getIntent()">getIntent()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> converts it to an Intent URI and returns it. The representation is the same as that returned by 
   <code><a href="../../../reference/android/content/Intent.html#toUri(int)">Intent.toUri(URI_INTENT_SCHEME)</a></code>. 
  </dd> 
 </dl> 
 <p> The clipboard framework is summarized in Figure 1. To copy data, an application puts a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object on the <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> global clipboard. The <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> contains one or more <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects and one <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object. To paste data, an application gets the <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code>, gets its MIME type from the <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code>, and gets the data either from the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> or from the content provider referred to by <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code>. </p> 
 <a name="framework"></a> 
 <img src="../../../images/ui/clipboard/copy_paste_framework.png" alt="A block diagram of the copy and paste framework" height="400px" id="figure1" /> 
 <p class="img-caption"> <strong>Figure 1.</strong> The Android clipboard framework </p> 
 ","CharSequence","java.lang.CharSequence","class",0
,"Sending Text to the Application","Editing the text around the cursor","<h3 id="EditingCursor">Editing the text around the cursor</h3> 
 <p> When you're handling the editing of existing text in a text field, some of the more useful methods in <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html">BaseInputConnection</a></code> are: </p> 
 <dl> 
  <dt> 
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html#getTextBeforeCursor(int, int)">getTextBeforeCursor()</a></code>
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code> containing the number of requested characters before the current cursor position. 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html#getTextAfterCursor(int, int)">getTextAfterCursor()</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code> containing the number of requested characters following the current cursor position. 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html#deleteSurroundingText(int, int)">deleteSurroundingText()</a></code> 
  </dt> 
  <dd>
    Deletes the specified number of characters before and following the current cursor position. 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html#commitText(java.lang.CharSequence, int)">commitText()</a></code> 
  </dt> 
  <dd>
    Commit a 
   <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code> to the text field and set a new cursor position. 
  </dd> 
 </dl> 
 <p> For example, the following snippet shows how to replace the text &quot;Fell&quot; to the left of the with the text &quot;Hello!&quot;: </p> 
 <pre>
    InputConnection ic = getCurrentInputConnection();
    
    ic.deleteSurroundingText(4, 0);
    
    ic.commitText(&quot;Hello&quot;, 1);
    
    ic.commitText(&quot;!&quot;, 1);
</pre> 
 ","CharSequence","java.lang.CharSequence","class",1
,"Clipboard Classes","ClipData, ClipData.Item, and ClipDescription","<h3 id="ClipClasses">ClipData, ClipData.Item, and ClipDescription</h3> 
 <p> To add data to the clipboard, you create a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object that contains both a description of the data and the data itself. The clipboard holds only one <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> at a time. A <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> contains a <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object and one or more <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects. </p> 
 <p> A <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object contains metadata about the clip. In particular, it contains an array of available MIME types for the clip's data. When you put a clip on the clipboard, this array is available to pasting applications, which can examine it to see if they can handle any of available the MIME types. </p> 
 <p> A <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains the text, URI, or Intent data: </p> 
 <dl> 
  <dt>
   Text
  </dt> 
  <dd>
    A 
   <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code>. 
  </dd> 
  <dt>
   URI
  </dt> 
  <dd>
    A 
   <code><a href="../../../reference/android/net/Uri.html">Uri</a></code>. This usually contains a content provider URI, although any URI is allowed. The application that provides the data puts the URI on the clipboard. Applications that want to paste the data get the URI from the clipboard and use it to access the content provider (or other data source) and retrieve the data. 
  </dd> 
  <dt>
   Intent
  </dt> 
  <dd>
    An 
   <code><a href="../../../reference/android/content/Intent.html">Intent</a></code>. This data type allows you to copy an application shortcut to the clipboard. Users can then paste the shortcut into their applications for later use. 
  </dd> 
 </dl> 
 <p> You can add more than one <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object to a clip. This allows users to copy and paste multiple selections as a single clip. For example, if you have a list widget that allows the user to select more than one item at a time, you can copy all the items to the clipboard at once. To do this, you create a separate <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> for each list item, and then you add the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects to the <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object. </p> 
 ","ClipDescription","android.content.ClipDescription","class",1
,"Clipboard Classes","ClipData convenience methods","<h3 id="ClipDataMethods">ClipData convenience methods</h3> 
 <p> The <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> class provides static convenience methods for creating a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object with a single <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object and a simple <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object: </p> 
 <dl> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newPlainText(java.lang.CharSequence, java.lang.CharSequence)">newPlainText(label, text)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains a text string. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. The single MIME type in 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> is 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_PLAIN">MIMETYPE_TEXT_PLAIN</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newPlainText(java.lang.CharSequence, java.lang.CharSequence)">newPlainText()</a></code> to create a clip from a text string. </p>
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newUri(android.content.ContentResolver, java.lang.CharSequence, android.net.Uri)">newUri(resolver, label, URI)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains a URI. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. If the URI is a content URI (
   <code><a href="../../../reference/android/net/Uri.html#getScheme()">Uri.getScheme()</a></code> returns 
   <code>content:</code>), the method uses the 
   <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> object provided in 
   <code>resolver</code> to retrieve the available MIME types from the content provider and store them in 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code>. For a URI that is not a 
   <code>content:</code> URI, the method sets the MIME type to 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_URILIST">MIMETYPE_TEXT_URILIST</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newUri(android.content.ContentResolver, java.lang.CharSequence, android.net.Uri)">newUri()</a></code> to create a clip from a URI, particularly a <code>content:</code> URI. </p> 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newIntent(java.lang.CharSequence, android.content.Intent)">newIntent(label, intent)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains an 
   <code><a href="../../../reference/android/content/Intent.html">Intent</a></code>. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. The MIME type is set to 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_INTENT">MIMETYPE_TEXT_INTENT</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newIntent(java.lang.CharSequence, android.content.Intent)">newIntent()</a></code> to create a clip from an Intent object. </p>
  </dd> 
 </dl> 
 ","ClipDescription","android.content.ClipDescription","class",1
,"Clipboard Classes","Coercing the clipboard data to text","<h3 id="CoerceToText">Coercing the clipboard data to text</h3> 
 <p> Even if your application only handles text, you can copy non-text data from the clipboard by converting it with the method <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">ClipData.Item.coerceToText()</a></code>. </p> 
 <p> This method converts the data in <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> to text and returns a <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code>. The value that <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">ClipData.Item.coerceToText()</a></code> returns is based on the form of data in <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code>: </p> 
 <dl> 
  <dt>
   <em>Text</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is text (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getText()">getText()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns the text. 
  </dd> 
  <dt>
   <em>URI</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is a URI (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getUri()">getUri()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> tries to use it as a content URI: 
   <ul> 
    <li> If the URI is a content URI and the provider can return a text stream, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a text stream. </li> 
    <li> If the URI is a content URI but the provider does not offer a text stream, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a representation of the URI. The representation is the same as that returned by <code><a href="../../../reference/android/net/Uri.html#toString()">Uri.toString()</a></code>. </li> 
    <li> If the URI is not a content URI, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a representation of the URI. The representation is the same as that returned by <code><a href="../../../reference/android/net/Uri.html#toString()">Uri.toString()</a></code>. </li> 
   </ul> 
  </dd> 
  <dt>
   <em>Intent</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is an Intent (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getIntent()">getIntent()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> converts it to an Intent URI and returns it. The representation is the same as that returned by 
   <code><a href="../../../reference/android/content/Intent.html#toUri(int)">Intent.toUri(URI_INTENT_SCHEME)</a></code>. 
  </dd> 
 </dl> 
 <p> The clipboard framework is summarized in Figure 1. To copy data, an application puts a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object on the <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> global clipboard. The <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> contains one or more <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects and one <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object. To paste data, an application gets the <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code>, gets its MIME type from the <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code>, and gets the data either from the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> or from the content provider referred to by <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code>. </p> 
 <a name="framework"></a> 
 <img src="../../../images/ui/clipboard/copy_paste_framework.png" alt="A block diagram of the copy and paste framework" height="400px" id="figure1" /> 
 <p class="img-caption"> <strong>Figure 1.</strong> The Android clipboard framework </p> 
 ","ClipDescription","android.content.ClipDescription","class",0
,"Copy and Paste","Copying to the Clipboard","<h2 id="Copying">Copying to the Clipboard</h2> 
 <p> As described previously, to copy data to the clipboard you get a handle to the global <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> object, create a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object, add a <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> and one or more <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects to it, and add the finished <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object to the <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> object. This is described in detail in the following procedure: </p> 
 <ol> 
  <li> If you are copying data using a content URI, set up a content provider. <p> The <a href="../../../resources/samples/NotePad/index.html"> Note Pad</a> sample application is an example of using a content provider for copying and pasting. The <a href="../../../resources/samples/NotePad/src/com/example/android/notepad/NotePadProvider.html"> NotePadProvider</a> class implements the content provider. The <a href="../../../resources/samples/NotePad/src/com/example/android/notepad/NotePad.html"> NotePad</a> class defines a contract between the provider and other applications, including the supported MIME types. </p> </li> 
  <li> Get the system clipboard: <pre>

...

// if the user selects copy
case R.id.menu_copy:

// Gets a handle to the clipboard service.
ClipboardManager clipboard = (ClipboardManager)
        getSystemService(Context.CLIPBOARD_SERVICE);
</pre> </li> 
  <li> <p> Copy the data to a new <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object: </p> 
   <ul> 
    <li> <h4>For text</h4> <pre>
// Creates a new text clip to put on the clipboard
ClipData clip = ClipData.newPlainText(&quot;simple text&quot;,&quot;Hello, World!&quot;);
</pre> </li> 
    <li> <h4>For a URI</h4> <p> This snippet constructs a URI by encoding a record ID onto the content URI for the provider. This technique is covered in more detail in the section <a href="#Encoding">Encoding an identifier on the URI</a>: </p> <pre>
// Creates a Uri based on a base Uri and a record ID based on the contact's last name
// Declares the base URI string
private static final String CONTACTS = &quot;content://com.example.contacts&quot;;

// Declares a path string for URIs that you use to copy data
private static final String COPY_PATH = &quot;/copy&quot;;

// Declares the Uri to paste to the clipboard
Uri copyUri = Uri.parse(CONTACTS + COPY_PATH + &quot;/&quot; + lastName);

...

// Creates a new URI clip object. The system uses the anonymous getContentResolver() object to
// get MIME types from provider. The clip object's label is &quot;URI&quot;, and its data is
// the Uri previously created.
ClipData clip = ClipData.newUri(getContentResolver(),&quot;URI&quot;,copyUri);
</pre> </li> 
    <li> <h4>For an Intent</h4> <p> This snippet constructs an Intent for an application and then puts it in the clip object: </p> <pre>
// Creates the Intent
Intent appIntent = new Intent(this, com.example.demo.myapplication.class);

...

// Creates a clip object with the Intent in it. Its label is &quot;Intent&quot; and its data is
// the Intent object created previously
ClipData clip = ClipData.newIntent(&quot;Intent&quot;,appIntent);
</pre> </li> 
   </ul> </li> 
  <li> Put the new clip object on the clipboard: <pre>
// Set the clipboard's primary clip.
clipboard.setPrimaryClip(clip);
</pre> </li> 
 </ol> 
 ","ClipDescription","android.content.ClipDescription","class",0
,"Copy and Paste","Designing Effective Copy/Paste Functionality","<h2 id="DataDesign">Designing Effective Copy/Paste Functionality</h2> 
 <p> To design effective copy and paste functionality for your application, remember these points: </p> 
 <ul> 
  <li> At any time, there is only one clip on the clipboard. A new copy operation by any application in the system overwrites the previous clip. Since the user may navigate away from your application and do a copy before returning, you can't assume that the clipboard contains the clip that the user previously copied in <em>your</em> application. </li> 
  <li> The intended purpose of multiple <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects per clip is to support copying and pasting of multiple selections rather than different forms of reference to a single selection. You usually want all of the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects in a clip to have the same form, that is, they should all be simple text, content URI, or <code><a href="../../../reference/android/content/Intent.html">Intent</a></code>, but not a mixture. </li> 
  <li> When you provide data, you can offer different MIME representations. Add the MIME types you support to the <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code>, and then implement the MIME types in your content provider. </li> 
  <li> When you get data from the clipboard, your application is responsible for checking the available MIME types and then deciding which one, if any, to use. Even if there is a clip on the clipboard and the user requests a paste, your application is not required to do the paste. You <em>should</em> do the paste if the MIME type is compatible. You may choose to coerce the data on the clipboard to text using <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> if you choose. If your application supports more than one of the available MIME types, you can allow the user to choose which one to use. </li> 
 </ul> 
</div> 
","ClipDescription","android.content.ClipDescription","class",0
,"Clipboard Classes","ClipData, ClipData.Item, and ClipDescription","<h3 id="ClipClasses">ClipData, ClipData.Item, and ClipDescription</h3> 
 <p> To add data to the clipboard, you create a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object that contains both a description of the data and the data itself. The clipboard holds only one <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> at a time. A <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> contains a <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object and one or more <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects. </p> 
 <p> A <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object contains metadata about the clip. In particular, it contains an array of available MIME types for the clip's data. When you put a clip on the clipboard, this array is available to pasting applications, which can examine it to see if they can handle any of available the MIME types. </p> 
 <p> A <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains the text, URI, or Intent data: </p> 
 <dl> 
  <dt>
   Text
  </dt> 
  <dd>
    A 
   <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code>. 
  </dd> 
  <dt>
   URI
  </dt> 
  <dd>
    A 
   <code><a href="../../../reference/android/net/Uri.html">Uri</a></code>. This usually contains a content provider URI, although any URI is allowed. The application that provides the data puts the URI on the clipboard. Applications that want to paste the data get the URI from the clipboard and use it to access the content provider (or other data source) and retrieve the data. 
  </dd> 
  <dt>
   Intent
  </dt> 
  <dd>
    An 
   <code><a href="../../../reference/android/content/Intent.html">Intent</a></code>. This data type allows you to copy an application shortcut to the clipboard. Users can then paste the shortcut into their applications for later use. 
  </dd> 
 </dl> 
 <p> You can add more than one <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object to a clip. This allows users to copy and paste multiple selections as a single clip. For example, if you have a list widget that allows the user to select more than one item at a time, you can copy all the items to the clipboard at once. To do this, you create a separate <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> for each list item, and then you add the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects to the <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object. </p> 
 ","Item","android.content.ClipData.Item","class",1
,"Clipboard Classes","ClipData convenience methods","<h3 id="ClipDataMethods">ClipData convenience methods</h3> 
 <p> The <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> class provides static convenience methods for creating a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object with a single <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object and a simple <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object: </p> 
 <dl> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newPlainText(java.lang.CharSequence, java.lang.CharSequence)">newPlainText(label, text)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains a text string. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. The single MIME type in 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> is 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_PLAIN">MIMETYPE_TEXT_PLAIN</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newPlainText(java.lang.CharSequence, java.lang.CharSequence)">newPlainText()</a></code> to create a clip from a text string. </p>
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newUri(android.content.ContentResolver, java.lang.CharSequence, android.net.Uri)">newUri(resolver, label, URI)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains a URI. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. If the URI is a content URI (
   <code><a href="../../../reference/android/net/Uri.html#getScheme()">Uri.getScheme()</a></code> returns 
   <code>content:</code>), the method uses the 
   <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> object provided in 
   <code>resolver</code> to retrieve the available MIME types from the content provider and store them in 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code>. For a URI that is not a 
   <code>content:</code> URI, the method sets the MIME type to 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_URILIST">MIMETYPE_TEXT_URILIST</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newUri(android.content.ContentResolver, java.lang.CharSequence, android.net.Uri)">newUri()</a></code> to create a clip from a URI, particularly a <code>content:</code> URI. </p> 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newIntent(java.lang.CharSequence, android.content.Intent)">newIntent(label, intent)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains an 
   <code><a href="../../../reference/android/content/Intent.html">Intent</a></code>. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. The MIME type is set to 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_INTENT">MIMETYPE_TEXT_INTENT</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newIntent(java.lang.CharSequence, android.content.Intent)">newIntent()</a></code> to create a clip from an Intent object. </p>
  </dd> 
 </dl> 
 ","Item","android.content.ClipData.Item","class",0
,"Clipboard Classes","Coercing the clipboard data to text","<h3 id="CoerceToText">Coercing the clipboard data to text</h3> 
 <p> Even if your application only handles text, you can copy non-text data from the clipboard by converting it with the method <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">ClipData.Item.coerceToText()</a></code>. </p> 
 <p> This method converts the data in <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> to text and returns a <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code>. The value that <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">ClipData.Item.coerceToText()</a></code> returns is based on the form of data in <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code>: </p> 
 <dl> 
  <dt>
   <em>Text</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is text (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getText()">getText()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns the text. 
  </dd> 
  <dt>
   <em>URI</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is a URI (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getUri()">getUri()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> tries to use it as a content URI: 
   <ul> 
    <li> If the URI is a content URI and the provider can return a text stream, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a text stream. </li> 
    <li> If the URI is a content URI but the provider does not offer a text stream, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a representation of the URI. The representation is the same as that returned by <code><a href="../../../reference/android/net/Uri.html#toString()">Uri.toString()</a></code>. </li> 
    <li> If the URI is not a content URI, <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> returns a representation of the URI. The representation is the same as that returned by <code><a href="../../../reference/android/net/Uri.html#toString()">Uri.toString()</a></code>. </li> 
   </ul> 
  </dd> 
  <dt>
   <em>Intent</em>
  </dt> 
  <dd>
    If 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> is an Intent (
   <code><a href="../../../reference/android/content/ClipData.Item.html#getIntent()">getIntent()</a></code> is not null), 
   <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> converts it to an Intent URI and returns it. The representation is the same as that returned by 
   <code><a href="../../../reference/android/content/Intent.html#toUri(int)">Intent.toUri(URI_INTENT_SCHEME)</a></code>. 
  </dd> 
 </dl> 
 <p> The clipboard framework is summarized in Figure 1. To copy data, an application puts a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object on the <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> global clipboard. The <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> contains one or more <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects and one <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object. To paste data, an application gets the <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code>, gets its MIME type from the <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code>, and gets the data either from the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> or from the content provider referred to by <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code>. </p> 
 <a name="framework"></a> 
 <img src="../../../images/ui/clipboard/copy_paste_framework.png" alt="A block diagram of the copy and paste framework" height="400px" id="figure1" /> 
 <p class="img-caption"> <strong>Figure 1.</strong> The Android clipboard framework </p> 
 ","Item","android.content.ClipData.Item","class",0
,"Copy and Paste","Copying to the Clipboard","<h2 id="Copying">Copying to the Clipboard</h2> 
 <p> As described previously, to copy data to the clipboard you get a handle to the global <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> object, create a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object, add a <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> and one or more <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects to it, and add the finished <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object to the <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> object. This is described in detail in the following procedure: </p> 
 <ol> 
  <li> If you are copying data using a content URI, set up a content provider. <p> The <a href="../../../resources/samples/NotePad/index.html"> Note Pad</a> sample application is an example of using a content provider for copying and pasting. The <a href="../../../resources/samples/NotePad/src/com/example/android/notepad/NotePadProvider.html"> NotePadProvider</a> class implements the content provider. The <a href="../../../resources/samples/NotePad/src/com/example/android/notepad/NotePad.html"> NotePad</a> class defines a contract between the provider and other applications, including the supported MIME types. </p> </li> 
  <li> Get the system clipboard: <pre>

...

// if the user selects copy
case R.id.menu_copy:

// Gets a handle to the clipboard service.
ClipboardManager clipboard = (ClipboardManager)
        getSystemService(Context.CLIPBOARD_SERVICE);
</pre> </li> 
  <li> <p> Copy the data to a new <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object: </p> 
   <ul> 
    <li> <h4>For text</h4> <pre>
// Creates a new text clip to put on the clipboard
ClipData clip = ClipData.newPlainText(&quot;simple text&quot;,&quot;Hello, World!&quot;);
</pre> </li> 
    <li> <h4>For a URI</h4> <p> This snippet constructs a URI by encoding a record ID onto the content URI for the provider. This technique is covered in more detail in the section <a href="#Encoding">Encoding an identifier on the URI</a>: </p> <pre>
// Creates a Uri based on a base Uri and a record ID based on the contact's last name
// Declares the base URI string
private static final String CONTACTS = &quot;content://com.example.contacts&quot;;

// Declares a path string for URIs that you use to copy data
private static final String COPY_PATH = &quot;/copy&quot;;

// Declares the Uri to paste to the clipboard
Uri copyUri = Uri.parse(CONTACTS + COPY_PATH + &quot;/&quot; + lastName);

...

// Creates a new URI clip object. The system uses the anonymous getContentResolver() object to
// get MIME types from provider. The clip object's label is &quot;URI&quot;, and its data is
// the Uri previously created.
ClipData clip = ClipData.newUri(getContentResolver(),&quot;URI&quot;,copyUri);
</pre> </li> 
    <li> <h4>For an Intent</h4> <p> This snippet constructs an Intent for an application and then puts it in the clip object: </p> <pre>
// Creates the Intent
Intent appIntent = new Intent(this, com.example.demo.myapplication.class);

...

// Creates a clip object with the Intent in it. Its label is &quot;Intent&quot; and its data is
// the Intent object created previously
ClipData clip = ClipData.newIntent(&quot;Intent&quot;,appIntent);
</pre> </li> 
   </ul> </li> 
  <li> Put the new clip object on the clipboard: <pre>
// Set the clipboard's primary clip.
clipboard.setPrimaryClip(clip);
</pre> </li> 
 </ol> 
 ","Item","android.content.ClipData.Item","class",0
,"Pasting from the Clipboard","Pasting plain text","<h3 id="PastePlainText">Pasting plain text</h3> 
 <p> To paste plain text, first get the global clipboard and verify that it can return plain text. Then get the clip object and copy its text to your own storage using <code><a href="../../../reference/android/content/ClipData.Item.html#getText()">getText()</a></code>, as described in the following procedure: </p> 
 <ol> 
  <li> Get the global <code><a href="../../../reference/android/content/ClipboardManager.html">ClipboardManager</a></code> object using <code><a href="../../../reference/android/content/Context.html#getSystemService(java.lang.String)">getSystemService(CLIPBOARD_SERVICE)</a></code>. Also declare a global variable to contain the pasted text: <pre>
ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);

String pasteData = &quot;&quot;;

</pre> </li> 
  <li> Next, determine if you should enable or disable the &quot;paste&quot; option in the current Activity. You should verify that the clipboard contains a clip and that you can handle the type of data represented by the clip: <pre>
// Gets the ID of the &quot;paste&quot; menu item
MenuItem mPasteItem = menu.findItem(R.id.menu_paste);

// If the clipboard doesn't contain data, disable the paste menu item.
// If it does contain data, decide if you can handle the data.
if (!(clipboard.hasPrimaryClip())) {

    mPasteItem.setEnabled(false);

    } else if (!(clipboard.getPrimaryClipDescription().hasMimeType(MIMETYPE_TEXT_PLAIN))) {

        // This disables the paste menu item, since the clipboard has data but it is not plain text
        mPasteItem.setEnabled(false);
    } else {

        // This enables the paste menu item, since the clipboard contains plain text.
        mPasteItem.setEnabled(true);
    }
}
</pre> </li> 
  <li> Copy the data from the clipboard. This point in the program is only reachable if the &quot;paste&quot; menu item is enabled, so you can assume that the clipboard contains plain text. You do not yet know if it contains a text string or a URI that points to plain text. The following snippet tests this, but it only shows the code for handling plain text: <pre>
// Responds to the user selecting &quot;paste&quot;
case R.id.menu_paste:

// Examines the item on the clipboard. If getText() does not return null, the clip item contains the
// text. Assumes that this application can only handle one item at a time.
 ClipData.Item item = clipboard.getPrimaryClip().getItemAt(0);

// Gets the clipboard as text.
pasteData = item.getText();

// If the string contains data, then the paste operation is done
if (pasteData != null) {
    return;

// The clipboard does not contain text. If it contains a URI, attempts to get data from it
} else {
    Uri pasteUri = item.getUri();

    // If the URI contains something, try to get text from it
    if (pasteUri != null) {

        // calls a routine to resolve the URI and get data from it. This routine is not
        // presented here.
        pasteData = resolveUri(Uri);
        return;
    } else {

    // Something is wrong. The MIME type was plain text, but the clipboard does not contain either
    // text or a Uri. Report an error.
    Log.e(&quot;Clipboard contains an invalid data type&quot;);
    return;
    }
}
</pre> </li> 
 </ol> 
 ","Item","android.content.ClipData.Item","class",0
,"Pasting from the Clipboard","Pasting data from a content URI","<h3 id="PasteContentUri">Pasting data from a content URI</h3> 
 <p> If the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains a content URI and you have determined that you can handle one of its MIME types, create a <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> and then call the appropriate content provider method to retrieve the data. </p> 
 <p> The following procedure describes how to get data from a content provider based on a content URI on the clipboard. It checks that a MIME type that the application can use is available from the provider: </p> 
 <ol> 
  <li> Declare a global variable to contain the MIME type: <pre>
// Declares a MIME type constant to match against the MIME types offered by the provider
public static final String MIME_TYPE_CONTACT = &quot;vnd.android.cursor.item/vnd.example.contact&quot;
</pre> </li> 
  <li> Get the global clipboard. Also get a content resolver so you can access the content provider: <pre>
// Gets a handle to the Clipboard Manager
ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);

// Gets a content resolver instance
ContentResolver cr = getContentResolver();
</pre> </li> 
  <li> Get the primary clip from the clipboard, and get its contents as a URI: <pre>
// Gets the clipboard data from the clipboard
ClipData clip = clipboard.getPrimaryClip();

if (clip != null) {

    // Gets the first item from the clipboard data
    ClipData.Item item = clip.getItemAt(0);

    // Tries to get the item's contents as a URI
    Uri pasteUri = item.getUri();
</pre> </li> 
  <li> Test to see if the URI is a content URI by calling <code><a href="../../../reference/android/content/ContentResolver.html#getType(android.net.Uri)">getType(Uri)</a></code>. This method returns null if <code>Uri</code> does not point to a valid content provider: <pre>
    // If the clipboard contains a URI reference
    if (pasteUri != null) {

        // Is this a content URI?
        String uriMimeType = cr.getType(pasteUri);
</pre> </li> 
  <li> Test to see if the content provider supports a MIME type that the current application understands. If it does, call <code><a href="../../../reference/android/content/ContentResolver.html#query(android.net.Uri, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String)">ContentResolver.query()</a></code> to get the data. The return value is a <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code>: <pre>
        // If the return value is not null, the Uri is a content Uri
        if (uriMimeType != null) {

            // Does the content provider offer a MIME type that the current application can use?
            if (uriMimeType.equals(MIME_TYPE_CONTACT)) {

                // Get the data from the content provider.
                Cursor pasteCursor = cr.query(uri, null, null, null, null);

                // If the Cursor contains data, move to the first record
                if (pasteCursor != null) {
                    if (pasteCursor.moveToFirst()) {

                    // get the data from the Cursor here. The code will vary according to the
                    // format of the data model.
                    }
                }

                // close the Cursor
                pasteCursor.close();
             }
         }
     }
}
</pre> </li> 
 </ol> 
 ","Item","android.content.ClipData.Item","class",0
,"Pasting from the Clipboard","Pasting an Intent","<h3 id="PasteIntent">Pasting an Intent</h3> 
 <p> To paste an Intent, first get the global clipboard. Examine the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object to see if it contains an Intent. Then call <code><a href="../../../reference/android/content/ClipData.Item.html#getIntent()">getIntent()</a></code> to copy the Intent to your own storage. The following snippet demonstrates this: </p> 
 <pre>
// Gets a handle to the Clipboard Manager
ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);

// Checks to see if the clip item contains an Intent, by testing to see if getIntent() returns null
Intent pasteIntent = clipboard.getPrimaryClip().getItemAt(0).getIntent();

if (pasteIntent != null) {

    // handle the Intent

} else {

    // ignore the clipboard, or issue an error if your application was expecting an Intent to be
    // on the clipboard
}
</pre> 
 ","Item","android.content.ClipData.Item","class",0
,"Copy and Paste","Designing Effective Copy/Paste Functionality","<h2 id="DataDesign">Designing Effective Copy/Paste Functionality</h2> 
 <p> To design effective copy and paste functionality for your application, remember these points: </p> 
 <ul> 
  <li> At any time, there is only one clip on the clipboard. A new copy operation by any application in the system overwrites the previous clip. Since the user may navigate away from your application and do a copy before returning, you can't assume that the clipboard contains the clip that the user previously copied in <em>your</em> application. </li> 
  <li> The intended purpose of multiple <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects per clip is to support copying and pasting of multiple selections rather than different forms of reference to a single selection. You usually want all of the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> objects in a clip to have the same form, that is, they should all be simple text, content URI, or <code><a href="../../../reference/android/content/Intent.html">Intent</a></code>, but not a mixture. </li> 
  <li> When you provide data, you can offer different MIME representations. Add the MIME types you support to the <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code>, and then implement the MIME types in your content provider. </li> 
  <li> When you get data from the clipboard, your application is responsible for checking the available MIME types and then deciding which one, if any, to use. Even if there is a clip on the clipboard and the user requests a paste, your application is not required to do the paste. You <em>should</em> do the paste if the MIME type is compatible. You may choose to coerce the data on the clipboard to text using <code><a href="../../../reference/android/content/ClipData.Item.html#coerceToText(android.content.Context)">coerceToText()</a></code> if you choose. If your application supports more than one of the available MIME types, you can allow the user to choose which one to use. </li> 
 </ul> 
</div> 
","Item","android.content.ClipData.Item","class",0
,"Clipboard Classes","ClipData convenience methods","<h3 id="ClipDataMethods">ClipData convenience methods</h3> 
 <p> The <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> class provides static convenience methods for creating a <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object with a single <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object and a simple <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object: </p> 
 <dl> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newPlainText(java.lang.CharSequence, java.lang.CharSequence)">newPlainText(label, text)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains a text string. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. The single MIME type in 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> is 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_PLAIN">MIMETYPE_TEXT_PLAIN</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newPlainText(java.lang.CharSequence, java.lang.CharSequence)">newPlainText()</a></code> to create a clip from a text string. </p>
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newUri(android.content.ContentResolver, java.lang.CharSequence, android.net.Uri)">newUri(resolver, label, URI)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains a URI. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. If the URI is a content URI (
   <code><a href="../../../reference/android/net/Uri.html#getScheme()">Uri.getScheme()</a></code> returns 
   <code>content:</code>), the method uses the 
   <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> object provided in 
   <code>resolver</code> to retrieve the available MIME types from the content provider and store them in 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code>. For a URI that is not a 
   <code>content:</code> URI, the method sets the MIME type to 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_URILIST">MIMETYPE_TEXT_URILIST</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newUri(android.content.ContentResolver, java.lang.CharSequence, android.net.Uri)">newUri()</a></code> to create a clip from a URI, particularly a <code>content:</code> URI. </p> 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ClipData.html#newIntent(java.lang.CharSequence, android.content.Intent)">newIntent(label, intent)</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object whose single 
   <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains an 
   <code><a href="../../../reference/android/content/Intent.html">Intent</a></code>. The 
   <code><a href="../../../reference/android/content/ClipDescription.html">ClipDescription</a></code> object's label is set to 
   <code>label</code>. The MIME type is set to 
   <code><a href="../../../reference/android/content/ClipDescription.html#MIMETYPE_TEXT_INTENT">MIMETYPE_TEXT_INTENT</a></code>. 
   <p> Use <code><a href="../../../reference/android/content/ClipData.html#newIntent(java.lang.CharSequence, android.content.Intent)">newIntent()</a></code> to create a clip from an Intent object. </p>
  </dd> 
 </dl> 
 ","ContentResolver","android.content.ContentResolver","class",0
,"Pasting from the Clipboard","Pasting data from a content URI","<h3 id="PasteContentUri">Pasting data from a content URI</h3> 
 <p> If the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains a content URI and you have determined that you can handle one of its MIME types, create a <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> and then call the appropriate content provider method to retrieve the data. </p> 
 <p> The following procedure describes how to get data from a content provider based on a content URI on the clipboard. It checks that a MIME type that the application can use is available from the provider: </p> 
 <ol> 
  <li> Declare a global variable to contain the MIME type: <pre>
// Declares a MIME type constant to match against the MIME types offered by the provider
public static final String MIME_TYPE_CONTACT = &quot;vnd.android.cursor.item/vnd.example.contact&quot;
</pre> </li> 
  <li> Get the global clipboard. Also get a content resolver so you can access the content provider: <pre>
// Gets a handle to the Clipboard Manager
ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);

// Gets a content resolver instance
ContentResolver cr = getContentResolver();
</pre> </li> 
  <li> Get the primary clip from the clipboard, and get its contents as a URI: <pre>
// Gets the clipboard data from the clipboard
ClipData clip = clipboard.getPrimaryClip();

if (clip != null) {

    // Gets the first item from the clipboard data
    ClipData.Item item = clip.getItemAt(0);

    // Tries to get the item's contents as a URI
    Uri pasteUri = item.getUri();
</pre> </li> 
  <li> Test to see if the URI is a content URI by calling <code><a href="../../../reference/android/content/ContentResolver.html#getType(android.net.Uri)">getType(Uri)</a></code>. This method returns null if <code>Uri</code> does not point to a valid content provider: <pre>
    // If the clipboard contains a URI reference
    if (pasteUri != null) {

        // Is this a content URI?
        String uriMimeType = cr.getType(pasteUri);
</pre> </li> 
  <li> Test to see if the content provider supports a MIME type that the current application understands. If it does, call <code><a href="../../../reference/android/content/ContentResolver.html#query(android.net.Uri, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String)">ContentResolver.query()</a></code> to get the data. The return value is a <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code>: <pre>
        // If the return value is not null, the Uri is a content Uri
        if (uriMimeType != null) {

            // Does the content provider offer a MIME type that the current application can use?
            if (uriMimeType.equals(MIME_TYPE_CONTACT)) {

                // Get the data from the content provider.
                Cursor pasteCursor = cr.query(uri, null, null, null, null);

                // If the Cursor contains data, move to the first record
                if (pasteCursor != null) {
                    if (pasteCursor.moveToFirst()) {

                    // get the data from the Cursor here. The code will vary according to the
                    // format of the data model.
                    }
                }

                // close the Cursor
                pasteCursor.close();
             }
         }
     }
}
</pre> </li> 
 </ol> 
 ","ContentResolver","android.content.ContentResolver","class",0
,"Using Content Providers to Copy Complex Data","Copying data structures","<h3 id="Records">Copying data structures</h3> 
 <p> You set up a content provider for copying and pasting complex data as a subclass of the <code><a href="../../../reference/android/content/ContentProvider.html">ContentProvider</a></code> component. You should also encode the URI you put on the clipboard so that it points to the exact record you want to provide. In addition, you have to consider the existing state of your application: </p> 
 <ul> 
  <li> If you already have a content provider, you can add to its functionality. You may only need to modify its <code><a href="../../../reference/android/content/ContentResolver.html#query(android.net.Uri, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String)">query()</a></code> method to handle URIs coming from applications that want to paste data. You will probably want to modify the method to handle a &quot;copy&quot; URI pattern. </li> 
  <li> If your application maintains an internal database, you may want to move this database into a content provider to facilitate copying from it. </li> 
  <li> If you are not currently using a database, you can implement a simple content provider whose sole purpose is to offer data to applications that are pasting from the clipboard. </li> 
 </ul> 
 <p> In the content provider, you will want to override at least the following methods: </p> 
 <dl> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentResolver.html#query(android.net.Uri, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String)">query()</a></code> 
  </dt> 
  <dd>
    Pasting applications will assume that they can get your data by using this method with the URI you put on the clipboard. To support copying, you should have this method detect URIs that contain a special &quot;copy&quot; path. Your application can then create a &quot;copy&quot; URI to put on the clipboard, containing the copy path and a pointer to the exact record you want to copy. 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#getType(android.net.Uri)">getType()</a></code> 
  </dt> 
  <dd>
    This method should return the MIME type or types for the data you intend to copy. The method 
   <code><a href="../../../reference/android/content/ClipData.html#newUri(android.content.ContentResolver, java.lang.CharSequence, android.net.Uri)">newUri()</a></code> calls 
   <code><a href="../../../reference/android/content/ContentProvider.html#getType(android.net.Uri)">getType()</a></code> in order to put the MIME types into the new 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object. 
   <p> MIME types for complex data are described in the topic <a href="../../../guide/topics/providers/content-providers.html">Content Providers</a>. </p> 
  </dd> 
 </dl> 
 <p> Notice that you don't have to have any of the other content provider methods such as <code><a href="../../../reference/android/content/ContentProvider.html#insert(android.net.Uri, android.content.ContentValues)">insert()</a></code> or <code><a href="../../../reference/android/content/ContentProvider.html#update(android.net.Uri, android.content.ContentValues, java.lang.String, java.lang.String[])">update()</a></code>. A pasting application only needs to get your supported MIME types and copy data from your provider. If you already have these methods, they won't interfere with copy operations. </p> 
 <p> The following snippets demonsrate how to set up your application to copy complex data: </p> 
 <ol> 
  <li> <p> In the global constants for your application, declare a base URI string and a path that identifies URI strings you are using to copy data. Also declare a MIME type for the copied data: </p> <pre>
// Declares the base URI string
private static final String CONTACTS = &quot;content://com.example.contacts&quot;;

// Declares a path string for URIs that you use to copy data
private static final String COPY_PATH = &quot;/copy&quot;;

// Declares a MIME type for the copied data
public static final String MIME_TYPE_CONTACT = &quot;vnd.android.cursor.item/vnd.example.contact&quot;
</pre> </li> 
  <li> In the Activity from which users copy data, set up the code to copy data to the clipboard. In response to a copy request, put the URI on the clipboard: <pre>
public class MyCopyActivity extends Activity {

    ...

// The user has selected a name and is requesting a copy.
case R.id.menu_copy:

    // Appends the last name to the base URI
    // The name is stored in &quot;lastName&quot;
    uriString = CONTACTS + COPY_PATH + &quot;/&quot; + lastName;

    // Parses the string into a URI
    Uri copyUri = Uri.parse(uriString);

    // Gets a handle to the clipboard service.
    ClipboardManager clipboard = (ClipboardManager)
        getSystemService(Context.CLIPBOARD_SERVICE);

    ClipData clip = ClipData.newUri(getContentResolver(), &quot;URI&quot;, copyUri);

    // Set the clipboard's primary clip.
    clipboard.setPrimaryClip(clip);
</pre> </li> 
  <li> <p> In the global scope of your content provider, create a URI matcher and add a URI pattern that will match URIs you put on the clipboard: </p> <pre>
public class MyCopyProvider extends ContentProvider {

    ...

// A Uri Match object that simplifies matching content URIs to patterns.
private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);

// An integer to use in switching based on the incoming URI pattern
private static final int GET_SINGLE_CONTACT = 0;

...

// Adds a matcher for the content URI. It matches
// &quot;content://com.example.contacts/copy/*&quot;
sUriMatcher.addURI(CONTACTS, &quot;names/*&quot;, GET_SINGLE_CONTACT);
</pre> </li> 
  <li> <p> Set up the <code><a href="../../../reference/android/content/ContentProvider.html#query(android.net.Uri, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String)">query()</a></code> method. This method can handle different URI patterns, depending on how you code it, but only the pattern for the clipboard copying operation is shown: </p> <pre>
// Sets up your provider's query() method.
public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
    String sortOrder) {

    ...

    // Switch based on the incoming content URI
    switch (sUriMatcher.match(uri)) {

    case GET_SINGLE_CONTACT:

        // query and return the contact for the requested name. Here you would decode
        // the incoming URI, query the data model based on the last name, and return the result
        // as a Cursor.

    ...

}
</pre> </li> 
  <li> <p> Set up the <code><a href="../../../reference/android/content/ContentProvider.html#getType(android.net.Uri)">getType()</a></code> method to return an appropriate MIME type for copied data: </p> <pre>
// Sets up your provider's getType() method.
public String getType(Uri uri) {

    ...

    switch (sUriMatcher.match(uri)) {

    case GET_SINGLE_CONTACT:

            return (MIME_TYPE_CONTACT);
</pre> </li> 
 </ol> 
 <p> The section <a href="#PasteContentUri">Pasting data from a content URI</a> describes how to get a content URI from the clipboard and use it to get and paste data. </p> 
 ","ContentResolver","android.content.ContentResolver","class",0
,"Using Content Providers to Copy Complex Data","Copying data streams","<h3 id="Streams">Copying data streams</h3> 
 <p> You can copy and paste large amounts of text and binary data as streams. The data can have forms such as the following: </p> 
 <ul> 
  <li> Files stored on the actual device. </li> 
  <li> Streams from sockets. </li> 
  <li> Large amounts of data stored in a provider's underlying database system. </li> 
 </ul> 
 <p> A content provider for data streams provides access to its data with a file descriptor object such as <code><a href="../../../reference/android/content/res/AssetFileDescriptor.html">AssetFileDescriptor</a></code> instead of a <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code> object. The pasting application reads the data stream using this file descriptor. </p> 
 <p> To set up your application to copy a data stream with a provider, follow these steps: </p> 
 <ol> 
  <li> Set up a content URI for the data stream you are putting on the clipboard. Options for doing this include the following: 
   <ul> 
    <li> Encode an identifier for the data stream onto the URI, as described in the section <a href="#Encoding">Encoding an identifier on the URI</a>, and then maintain a table in your provider that contains identifiers and the corresponding stream name. </li> 
    <li> Encode the stream name directly on the URI. </li> 
    <li> Use a unique URI that always returns the current stream from the provider. If you use this option, you have to remember to update your provider to point to a different stream whenever you copy the stream to the clipboard via the URI. </li> 
   </ul> </li> 
  <li> Provide a MIME type for each type of data stream you plan to offer. Pasting applications need this information to determine if they can paste the data on the clipboard. </li> 
  <li> Implement one of the <code><a href="../../../reference/android/content/ContentProvider.html">ContentProvider</a></code> methods that returns a file descriptor for a stream. If you encode identifiers on the content URI, use this method to determine which stream to open. </li> 
  <li> To copy the data stream to the clipboard, construct the content URI and place it on the clipboard. </li> 
 </ol> 
 <p> To paste a data stream, an application gets the clip from the clipboard, gets the URI, and uses it in a call to a <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> file descriptor method that opens the stream. The <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> method calls the corresponding <code><a href="../../../reference/android/content/ContentProvider.html">ContentProvider</a></code> method, passing it the content URI. Your provider returns the file descriptor to <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> method. The pasting application then has the responsibility to read the data from the stream. </p> 
 <p> The following list shows the most important file descriptor methods for a content provider. Each of these has a corresponding <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> method with the string &quot;Descriptor&quot; appended to the method name; for example, the <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> analog of <code><a href="../../../reference/android/content/ContentProvider.html#openAssetFile(android.net.Uri, java.lang.String)">openAssetFile()</a></code> is <code><a href="../../../reference/android/content/ContentResolver.html#openAssetFileDescriptor(android.net.Uri, java.lang.String)">openAssetFileDescriptor()</a></code>: </p> 
 <dl> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#openTypedAssetFile(android.net.Uri, java.lang.String, android.os.Bundle)">openTypedAssetFile()</a></code> 
  </dt> 
  <dd>
    This method should return an asset file descriptor, but only if the provided MIME type is supported by the provider. The caller (the application doing the pasting) provides a MIME type pattern. The content provider (of the application that has copied a URI to the clipboard) returns an 
   <code><a href="../../../reference/android/content/res/AssetFileDescriptor.html">AssetFileDescriptor</a></code> file handle if it can provide that MIME type, or throws an exception if it can not. 
   <p> This method handles subsections of files. You can use it to read assets that the content provider has copied to the clipboard. </p> 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#openAssetFile(android.net.Uri, java.lang.String)">openAssetFile()</a></code> 
  </dt> 
  <dd>
    This method is a more general form of 
   <code><a href="../../../reference/android/content/ContentProvider.html#openTypedAssetFile(android.net.Uri, java.lang.String, android.os.Bundle)">openTypedAssetFile()</a></code>. It does not filter for allowed MIME types, but it can read subsections of files. 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#openFile(android.net.Uri, java.lang.String)">openFile()</a></code> 
  </dt> 
  <dd>
    This is a more general form of 
   <code><a href="../../../reference/android/content/ContentProvider.html#openAssetFile(android.net.Uri, java.lang.String)">openAssetFile()</a></code>. It can't read subsections of files. 
  </dd> 
 </dl> 
 <p> You can optionally use the <code><a href="../../../reference/android/content/ContentProvider.html#openPipeHelper(android.net.Uri, java.lang.String, android.os.Bundle, T, android.content.ContentProvider.PipeDataWriter&lt;T&gt;)">openPipeHelper()</a></code> method with your file descriptor method. This allows the pasting application to read the stream data in a background thread using a pipe. To use this method, you need to implement the <code><a href="../../../reference/android/content/ContentProvider.PipeDataWriter.html">ContentProvider.PipeDataWriter</a></code> interface. An example of doing this is given in the <a href="../../../resources/samples/NotePad/index.html">Note Pad</a> sample application, in the <code>openTypedAssetFile()</code> method of <code>NotePadProvider.java</code>. </p> 
 ","ContentResolver","android.content.ContentResolver","class",0
,"Pasting from the Clipboard","Pasting data from a content URI","<h3 id="PasteContentUri">Pasting data from a content URI</h3> 
 <p> If the <code><a href="../../../reference/android/content/ClipData.Item.html">ClipData.Item</a></code> object contains a content URI and you have determined that you can handle one of its MIME types, create a <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> and then call the appropriate content provider method to retrieve the data. </p> 
 <p> The following procedure describes how to get data from a content provider based on a content URI on the clipboard. It checks that a MIME type that the application can use is available from the provider: </p> 
 <ol> 
  <li> Declare a global variable to contain the MIME type: <pre>
// Declares a MIME type constant to match against the MIME types offered by the provider
public static final String MIME_TYPE_CONTACT = &quot;vnd.android.cursor.item/vnd.example.contact&quot;
</pre> </li> 
  <li> Get the global clipboard. Also get a content resolver so you can access the content provider: <pre>
// Gets a handle to the Clipboard Manager
ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);

// Gets a content resolver instance
ContentResolver cr = getContentResolver();
</pre> </li> 
  <li> Get the primary clip from the clipboard, and get its contents as a URI: <pre>
// Gets the clipboard data from the clipboard
ClipData clip = clipboard.getPrimaryClip();

if (clip != null) {

    // Gets the first item from the clipboard data
    ClipData.Item item = clip.getItemAt(0);

    // Tries to get the item's contents as a URI
    Uri pasteUri = item.getUri();
</pre> </li> 
  <li> Test to see if the URI is a content URI by calling <code><a href="../../../reference/android/content/ContentResolver.html#getType(android.net.Uri)">getType(Uri)</a></code>. This method returns null if <code>Uri</code> does not point to a valid content provider: <pre>
    // If the clipboard contains a URI reference
    if (pasteUri != null) {

        // Is this a content URI?
        String uriMimeType = cr.getType(pasteUri);
</pre> </li> 
  <li> Test to see if the content provider supports a MIME type that the current application understands. If it does, call <code><a href="../../../reference/android/content/ContentResolver.html#query(android.net.Uri, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String)">ContentResolver.query()</a></code> to get the data. The return value is a <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code>: <pre>
        // If the return value is not null, the Uri is a content Uri
        if (uriMimeType != null) {

            // Does the content provider offer a MIME type that the current application can use?
            if (uriMimeType.equals(MIME_TYPE_CONTACT)) {

                // Get the data from the content provider.
                Cursor pasteCursor = cr.query(uri, null, null, null, null);

                // If the Cursor contains data, move to the first record
                if (pasteCursor != null) {
                    if (pasteCursor.moveToFirst()) {

                    // get the data from the Cursor here. The code will vary according to the
                    // format of the data model.
                    }
                }

                // close the Cursor
                pasteCursor.close();
             }
         }
     }
}
</pre> </li> 
 </ol> 
 ","Cursor","android.database.Cursor","class",0
,"Using Content Providers to Copy Complex Data","Copying data streams","<h3 id="Streams">Copying data streams</h3> 
 <p> You can copy and paste large amounts of text and binary data as streams. The data can have forms such as the following: </p> 
 <ul> 
  <li> Files stored on the actual device. </li> 
  <li> Streams from sockets. </li> 
  <li> Large amounts of data stored in a provider's underlying database system. </li> 
 </ul> 
 <p> A content provider for data streams provides access to its data with a file descriptor object such as <code><a href="../../../reference/android/content/res/AssetFileDescriptor.html">AssetFileDescriptor</a></code> instead of a <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code> object. The pasting application reads the data stream using this file descriptor. </p> 
 <p> To set up your application to copy a data stream with a provider, follow these steps: </p> 
 <ol> 
  <li> Set up a content URI for the data stream you are putting on the clipboard. Options for doing this include the following: 
   <ul> 
    <li> Encode an identifier for the data stream onto the URI, as described in the section <a href="#Encoding">Encoding an identifier on the URI</a>, and then maintain a table in your provider that contains identifiers and the corresponding stream name. </li> 
    <li> Encode the stream name directly on the URI. </li> 
    <li> Use a unique URI that always returns the current stream from the provider. If you use this option, you have to remember to update your provider to point to a different stream whenever you copy the stream to the clipboard via the URI. </li> 
   </ul> </li> 
  <li> Provide a MIME type for each type of data stream you plan to offer. Pasting applications need this information to determine if they can paste the data on the clipboard. </li> 
  <li> Implement one of the <code><a href="../../../reference/android/content/ContentProvider.html">ContentProvider</a></code> methods that returns a file descriptor for a stream. If you encode identifiers on the content URI, use this method to determine which stream to open. </li> 
  <li> To copy the data stream to the clipboard, construct the content URI and place it on the clipboard. </li> 
 </ol> 
 <p> To paste a data stream, an application gets the clip from the clipboard, gets the URI, and uses it in a call to a <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> file descriptor method that opens the stream. The <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> method calls the corresponding <code><a href="../../../reference/android/content/ContentProvider.html">ContentProvider</a></code> method, passing it the content URI. Your provider returns the file descriptor to <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> method. The pasting application then has the responsibility to read the data from the stream. </p> 
 <p> The following list shows the most important file descriptor methods for a content provider. Each of these has a corresponding <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> method with the string &quot;Descriptor&quot; appended to the method name; for example, the <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> analog of <code><a href="../../../reference/android/content/ContentProvider.html#openAssetFile(android.net.Uri, java.lang.String)">openAssetFile()</a></code> is <code><a href="../../../reference/android/content/ContentResolver.html#openAssetFileDescriptor(android.net.Uri, java.lang.String)">openAssetFileDescriptor()</a></code>: </p> 
 <dl> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#openTypedAssetFile(android.net.Uri, java.lang.String, android.os.Bundle)">openTypedAssetFile()</a></code> 
  </dt> 
  <dd>
    This method should return an asset file descriptor, but only if the provided MIME type is supported by the provider. The caller (the application doing the pasting) provides a MIME type pattern. The content provider (of the application that has copied a URI to the clipboard) returns an 
   <code><a href="../../../reference/android/content/res/AssetFileDescriptor.html">AssetFileDescriptor</a></code> file handle if it can provide that MIME type, or throws an exception if it can not. 
   <p> This method handles subsections of files. You can use it to read assets that the content provider has copied to the clipboard. </p> 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#openAssetFile(android.net.Uri, java.lang.String)">openAssetFile()</a></code> 
  </dt> 
  <dd>
    This method is a more general form of 
   <code><a href="../../../reference/android/content/ContentProvider.html#openTypedAssetFile(android.net.Uri, java.lang.String, android.os.Bundle)">openTypedAssetFile()</a></code>. It does not filter for allowed MIME types, but it can read subsections of files. 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#openFile(android.net.Uri, java.lang.String)">openFile()</a></code> 
  </dt> 
  <dd>
    This is a more general form of 
   <code><a href="../../../reference/android/content/ContentProvider.html#openAssetFile(android.net.Uri, java.lang.String)">openAssetFile()</a></code>. It can't read subsections of files. 
  </dd> 
 </dl> 
 <p> You can optionally use the <code><a href="../../../reference/android/content/ContentProvider.html#openPipeHelper(android.net.Uri, java.lang.String, android.os.Bundle, T, android.content.ContentProvider.PipeDataWriter&lt;T&gt;)">openPipeHelper()</a></code> method with your file descriptor method. This allows the pasting application to read the stream data in a background thread using a pipe. To use this method, you need to implement the <code><a href="../../../reference/android/content/ContentProvider.PipeDataWriter.html">ContentProvider.PipeDataWriter</a></code> interface. An example of doing this is given in the <a href="../../../resources/samples/NotePad/index.html">Note Pad</a> sample application, in the <code>openTypedAssetFile()</code> method of <code>NotePadProvider.java</code>. </p> 
 ","Cursor","android.database.Cursor","class",0
,"Using Content Providers to Copy Complex Data","Copying data structures","<h3 id="Records">Copying data structures</h3> 
 <p> You set up a content provider for copying and pasting complex data as a subclass of the <code><a href="../../../reference/android/content/ContentProvider.html">ContentProvider</a></code> component. You should also encode the URI you put on the clipboard so that it points to the exact record you want to provide. In addition, you have to consider the existing state of your application: </p> 
 <ul> 
  <li> If you already have a content provider, you can add to its functionality. You may only need to modify its <code><a href="../../../reference/android/content/ContentResolver.html#query(android.net.Uri, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String)">query()</a></code> method to handle URIs coming from applications that want to paste data. You will probably want to modify the method to handle a &quot;copy&quot; URI pattern. </li> 
  <li> If your application maintains an internal database, you may want to move this database into a content provider to facilitate copying from it. </li> 
  <li> If you are not currently using a database, you can implement a simple content provider whose sole purpose is to offer data to applications that are pasting from the clipboard. </li> 
 </ul> 
 <p> In the content provider, you will want to override at least the following methods: </p> 
 <dl> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentResolver.html#query(android.net.Uri, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String)">query()</a></code> 
  </dt> 
  <dd>
    Pasting applications will assume that they can get your data by using this method with the URI you put on the clipboard. To support copying, you should have this method detect URIs that contain a special &quot;copy&quot; path. Your application can then create a &quot;copy&quot; URI to put on the clipboard, containing the copy path and a pointer to the exact record you want to copy. 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#getType(android.net.Uri)">getType()</a></code> 
  </dt> 
  <dd>
    This method should return the MIME type or types for the data you intend to copy. The method 
   <code><a href="../../../reference/android/content/ClipData.html#newUri(android.content.ContentResolver, java.lang.CharSequence, android.net.Uri)">newUri()</a></code> calls 
   <code><a href="../../../reference/android/content/ContentProvider.html#getType(android.net.Uri)">getType()</a></code> in order to put the MIME types into the new 
   <code><a href="../../../reference/android/content/ClipData.html">ClipData</a></code> object. 
   <p> MIME types for complex data are described in the topic <a href="../../../guide/topics/providers/content-providers.html">Content Providers</a>. </p> 
  </dd> 
 </dl> 
 <p> Notice that you don't have to have any of the other content provider methods such as <code><a href="../../../reference/android/content/ContentProvider.html#insert(android.net.Uri, android.content.ContentValues)">insert()</a></code> or <code><a href="../../../reference/android/content/ContentProvider.html#update(android.net.Uri, android.content.ContentValues, java.lang.String, java.lang.String[])">update()</a></code>. A pasting application only needs to get your supported MIME types and copy data from your provider. If you already have these methods, they won't interfere with copy operations. </p> 
 <p> The following snippets demonsrate how to set up your application to copy complex data: </p> 
 <ol> 
  <li> <p> In the global constants for your application, declare a base URI string and a path that identifies URI strings you are using to copy data. Also declare a MIME type for the copied data: </p> <pre>
// Declares the base URI string
private static final String CONTACTS = &quot;content://com.example.contacts&quot;;

// Declares a path string for URIs that you use to copy data
private static final String COPY_PATH = &quot;/copy&quot;;

// Declares a MIME type for the copied data
public static final String MIME_TYPE_CONTACT = &quot;vnd.android.cursor.item/vnd.example.contact&quot;
</pre> </li> 
  <li> In the Activity from which users copy data, set up the code to copy data to the clipboard. In response to a copy request, put the URI on the clipboard: <pre>
public class MyCopyActivity extends Activity {

    ...

// The user has selected a name and is requesting a copy.
case R.id.menu_copy:

    // Appends the last name to the base URI
    // The name is stored in &quot;lastName&quot;
    uriString = CONTACTS + COPY_PATH + &quot;/&quot; + lastName;

    // Parses the string into a URI
    Uri copyUri = Uri.parse(uriString);

    // Gets a handle to the clipboard service.
    ClipboardManager clipboard = (ClipboardManager)
        getSystemService(Context.CLIPBOARD_SERVICE);

    ClipData clip = ClipData.newUri(getContentResolver(), &quot;URI&quot;, copyUri);

    // Set the clipboard's primary clip.
    clipboard.setPrimaryClip(clip);
</pre> </li> 
  <li> <p> In the global scope of your content provider, create a URI matcher and add a URI pattern that will match URIs you put on the clipboard: </p> <pre>
public class MyCopyProvider extends ContentProvider {

    ...

// A Uri Match object that simplifies matching content URIs to patterns.
private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);

// An integer to use in switching based on the incoming URI pattern
private static final int GET_SINGLE_CONTACT = 0;

...

// Adds a matcher for the content URI. It matches
// &quot;content://com.example.contacts/copy/*&quot;
sUriMatcher.addURI(CONTACTS, &quot;names/*&quot;, GET_SINGLE_CONTACT);
</pre> </li> 
  <li> <p> Set up the <code><a href="../../../reference/android/content/ContentProvider.html#query(android.net.Uri, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String)">query()</a></code> method. This method can handle different URI patterns, depending on how you code it, but only the pattern for the clipboard copying operation is shown: </p> <pre>
// Sets up your provider's query() method.
public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
    String sortOrder) {

    ...

    // Switch based on the incoming content URI
    switch (sUriMatcher.match(uri)) {

    case GET_SINGLE_CONTACT:

        // query and return the contact for the requested name. Here you would decode
        // the incoming URI, query the data model based on the last name, and return the result
        // as a Cursor.

    ...

}
</pre> </li> 
  <li> <p> Set up the <code><a href="../../../reference/android/content/ContentProvider.html#getType(android.net.Uri)">getType()</a></code> method to return an appropriate MIME type for copied data: </p> <pre>
// Sets up your provider's getType() method.
public String getType(Uri uri) {

    ...

    switch (sUriMatcher.match(uri)) {

    case GET_SINGLE_CONTACT:

            return (MIME_TYPE_CONTACT);
</pre> </li> 
 </ol> 
 <p> The section <a href="#PasteContentUri">Pasting data from a content URI</a> describes how to get a content URI from the clipboard and use it to get and paste data. </p> 
 ","ContentProvider","android.content.ContentProvider","class",0
,"Using Content Providers to Copy Complex Data","Copying data streams","<h3 id="Streams">Copying data streams</h3> 
 <p> You can copy and paste large amounts of text and binary data as streams. The data can have forms such as the following: </p> 
 <ul> 
  <li> Files stored on the actual device. </li> 
  <li> Streams from sockets. </li> 
  <li> Large amounts of data stored in a provider's underlying database system. </li> 
 </ul> 
 <p> A content provider for data streams provides access to its data with a file descriptor object such as <code><a href="../../../reference/android/content/res/AssetFileDescriptor.html">AssetFileDescriptor</a></code> instead of a <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code> object. The pasting application reads the data stream using this file descriptor. </p> 
 <p> To set up your application to copy a data stream with a provider, follow these steps: </p> 
 <ol> 
  <li> Set up a content URI for the data stream you are putting on the clipboard. Options for doing this include the following: 
   <ul> 
    <li> Encode an identifier for the data stream onto the URI, as described in the section <a href="#Encoding">Encoding an identifier on the URI</a>, and then maintain a table in your provider that contains identifiers and the corresponding stream name. </li> 
    <li> Encode the stream name directly on the URI. </li> 
    <li> Use a unique URI that always returns the current stream from the provider. If you use this option, you have to remember to update your provider to point to a different stream whenever you copy the stream to the clipboard via the URI. </li> 
   </ul> </li> 
  <li> Provide a MIME type for each type of data stream you plan to offer. Pasting applications need this information to determine if they can paste the data on the clipboard. </li> 
  <li> Implement one of the <code><a href="../../../reference/android/content/ContentProvider.html">ContentProvider</a></code> methods that returns a file descriptor for a stream. If you encode identifiers on the content URI, use this method to determine which stream to open. </li> 
  <li> To copy the data stream to the clipboard, construct the content URI and place it on the clipboard. </li> 
 </ol> 
 <p> To paste a data stream, an application gets the clip from the clipboard, gets the URI, and uses it in a call to a <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> file descriptor method that opens the stream. The <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> method calls the corresponding <code><a href="../../../reference/android/content/ContentProvider.html">ContentProvider</a></code> method, passing it the content URI. Your provider returns the file descriptor to <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> method. The pasting application then has the responsibility to read the data from the stream. </p> 
 <p> The following list shows the most important file descriptor methods for a content provider. Each of these has a corresponding <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> method with the string &quot;Descriptor&quot; appended to the method name; for example, the <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> analog of <code><a href="../../../reference/android/content/ContentProvider.html#openAssetFile(android.net.Uri, java.lang.String)">openAssetFile()</a></code> is <code><a href="../../../reference/android/content/ContentResolver.html#openAssetFileDescriptor(android.net.Uri, java.lang.String)">openAssetFileDescriptor()</a></code>: </p> 
 <dl> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#openTypedAssetFile(android.net.Uri, java.lang.String, android.os.Bundle)">openTypedAssetFile()</a></code> 
  </dt> 
  <dd>
    This method should return an asset file descriptor, but only if the provided MIME type is supported by the provider. The caller (the application doing the pasting) provides a MIME type pattern. The content provider (of the application that has copied a URI to the clipboard) returns an 
   <code><a href="../../../reference/android/content/res/AssetFileDescriptor.html">AssetFileDescriptor</a></code> file handle if it can provide that MIME type, or throws an exception if it can not. 
   <p> This method handles subsections of files. You can use it to read assets that the content provider has copied to the clipboard. </p> 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#openAssetFile(android.net.Uri, java.lang.String)">openAssetFile()</a></code> 
  </dt> 
  <dd>
    This method is a more general form of 
   <code><a href="../../../reference/android/content/ContentProvider.html#openTypedAssetFile(android.net.Uri, java.lang.String, android.os.Bundle)">openTypedAssetFile()</a></code>. It does not filter for allowed MIME types, but it can read subsections of files. 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#openFile(android.net.Uri, java.lang.String)">openFile()</a></code> 
  </dt> 
  <dd>
    This is a more general form of 
   <code><a href="../../../reference/android/content/ContentProvider.html#openAssetFile(android.net.Uri, java.lang.String)">openAssetFile()</a></code>. It can't read subsections of files. 
  </dd> 
 </dl> 
 <p> You can optionally use the <code><a href="../../../reference/android/content/ContentProvider.html#openPipeHelper(android.net.Uri, java.lang.String, android.os.Bundle, T, android.content.ContentProvider.PipeDataWriter&lt;T&gt;)">openPipeHelper()</a></code> method with your file descriptor method. This allows the pasting application to read the stream data in a background thread using a pipe. To use this method, you need to implement the <code><a href="../../../reference/android/content/ContentProvider.PipeDataWriter.html">ContentProvider.PipeDataWriter</a></code> interface. An example of doing this is given in the <a href="../../../resources/samples/NotePad/index.html">Note Pad</a> sample application, in the <code>openTypedAssetFile()</code> method of <code>NotePadProvider.java</code>. </p> 
 ","ContentProvider","android.content.ContentProvider","class",0
,"Using Content Providers to Copy Complex Data","Copying data streams","<h3 id="Streams">Copying data streams</h3> 
 <p> You can copy and paste large amounts of text and binary data as streams. The data can have forms such as the following: </p> 
 <ul> 
  <li> Files stored on the actual device. </li> 
  <li> Streams from sockets. </li> 
  <li> Large amounts of data stored in a provider's underlying database system. </li> 
 </ul> 
 <p> A content provider for data streams provides access to its data with a file descriptor object such as <code><a href="../../../reference/android/content/res/AssetFileDescriptor.html">AssetFileDescriptor</a></code> instead of a <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code> object. The pasting application reads the data stream using this file descriptor. </p> 
 <p> To set up your application to copy a data stream with a provider, follow these steps: </p> 
 <ol> 
  <li> Set up a content URI for the data stream you are putting on the clipboard. Options for doing this include the following: 
   <ul> 
    <li> Encode an identifier for the data stream onto the URI, as described in the section <a href="#Encoding">Encoding an identifier on the URI</a>, and then maintain a table in your provider that contains identifiers and the corresponding stream name. </li> 
    <li> Encode the stream name directly on the URI. </li> 
    <li> Use a unique URI that always returns the current stream from the provider. If you use this option, you have to remember to update your provider to point to a different stream whenever you copy the stream to the clipboard via the URI. </li> 
   </ul> </li> 
  <li> Provide a MIME type for each type of data stream you plan to offer. Pasting applications need this information to determine if they can paste the data on the clipboard. </li> 
  <li> Implement one of the <code><a href="../../../reference/android/content/ContentProvider.html">ContentProvider</a></code> methods that returns a file descriptor for a stream. If you encode identifiers on the content URI, use this method to determine which stream to open. </li> 
  <li> To copy the data stream to the clipboard, construct the content URI and place it on the clipboard. </li> 
 </ol> 
 <p> To paste a data stream, an application gets the clip from the clipboard, gets the URI, and uses it in a call to a <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> file descriptor method that opens the stream. The <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> method calls the corresponding <code><a href="../../../reference/android/content/ContentProvider.html">ContentProvider</a></code> method, passing it the content URI. Your provider returns the file descriptor to <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> method. The pasting application then has the responsibility to read the data from the stream. </p> 
 <p> The following list shows the most important file descriptor methods for a content provider. Each of these has a corresponding <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> method with the string &quot;Descriptor&quot; appended to the method name; for example, the <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> analog of <code><a href="../../../reference/android/content/ContentProvider.html#openAssetFile(android.net.Uri, java.lang.String)">openAssetFile()</a></code> is <code><a href="../../../reference/android/content/ContentResolver.html#openAssetFileDescriptor(android.net.Uri, java.lang.String)">openAssetFileDescriptor()</a></code>: </p> 
 <dl> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#openTypedAssetFile(android.net.Uri, java.lang.String, android.os.Bundle)">openTypedAssetFile()</a></code> 
  </dt> 
  <dd>
    This method should return an asset file descriptor, but only if the provided MIME type is supported by the provider. The caller (the application doing the pasting) provides a MIME type pattern. The content provider (of the application that has copied a URI to the clipboard) returns an 
   <code><a href="../../../reference/android/content/res/AssetFileDescriptor.html">AssetFileDescriptor</a></code> file handle if it can provide that MIME type, or throws an exception if it can not. 
   <p> This method handles subsections of files. You can use it to read assets that the content provider has copied to the clipboard. </p> 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#openAssetFile(android.net.Uri, java.lang.String)">openAssetFile()</a></code> 
  </dt> 
  <dd>
    This method is a more general form of 
   <code><a href="../../../reference/android/content/ContentProvider.html#openTypedAssetFile(android.net.Uri, java.lang.String, android.os.Bundle)">openTypedAssetFile()</a></code>. It does not filter for allowed MIME types, but it can read subsections of files. 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#openFile(android.net.Uri, java.lang.String)">openFile()</a></code> 
  </dt> 
  <dd>
    This is a more general form of 
   <code><a href="../../../reference/android/content/ContentProvider.html#openAssetFile(android.net.Uri, java.lang.String)">openAssetFile()</a></code>. It can't read subsections of files. 
  </dd> 
 </dl> 
 <p> You can optionally use the <code><a href="../../../reference/android/content/ContentProvider.html#openPipeHelper(android.net.Uri, java.lang.String, android.os.Bundle, T, android.content.ContentProvider.PipeDataWriter&lt;T&gt;)">openPipeHelper()</a></code> method with your file descriptor method. This allows the pasting application to read the stream data in a background thread using a pipe. To use this method, you need to implement the <code><a href="../../../reference/android/content/ContentProvider.PipeDataWriter.html">ContentProvider.PipeDataWriter</a></code> interface. An example of doing this is given in the <a href="../../../resources/samples/NotePad/index.html">Note Pad</a> sample application, in the <code>openTypedAssetFile()</code> method of <code>NotePadProvider.java</code>. </p> 
 ","AssetFileDescriptor","android.content.res.AssetFileDescriptor","class",0
,"Using Content Providers to Copy Complex Data","Copying data streams","<h3 id="Streams">Copying data streams</h3> 
 <p> You can copy and paste large amounts of text and binary data as streams. The data can have forms such as the following: </p> 
 <ul> 
  <li> Files stored on the actual device. </li> 
  <li> Streams from sockets. </li> 
  <li> Large amounts of data stored in a provider's underlying database system. </li> 
 </ul> 
 <p> A content provider for data streams provides access to its data with a file descriptor object such as <code><a href="../../../reference/android/content/res/AssetFileDescriptor.html">AssetFileDescriptor</a></code> instead of a <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code> object. The pasting application reads the data stream using this file descriptor. </p> 
 <p> To set up your application to copy a data stream with a provider, follow these steps: </p> 
 <ol> 
  <li> Set up a content URI for the data stream you are putting on the clipboard. Options for doing this include the following: 
   <ul> 
    <li> Encode an identifier for the data stream onto the URI, as described in the section <a href="#Encoding">Encoding an identifier on the URI</a>, and then maintain a table in your provider that contains identifiers and the corresponding stream name. </li> 
    <li> Encode the stream name directly on the URI. </li> 
    <li> Use a unique URI that always returns the current stream from the provider. If you use this option, you have to remember to update your provider to point to a different stream whenever you copy the stream to the clipboard via the URI. </li> 
   </ul> </li> 
  <li> Provide a MIME type for each type of data stream you plan to offer. Pasting applications need this information to determine if they can paste the data on the clipboard. </li> 
  <li> Implement one of the <code><a href="../../../reference/android/content/ContentProvider.html">ContentProvider</a></code> methods that returns a file descriptor for a stream. If you encode identifiers on the content URI, use this method to determine which stream to open. </li> 
  <li> To copy the data stream to the clipboard, construct the content URI and place it on the clipboard. </li> 
 </ol> 
 <p> To paste a data stream, an application gets the clip from the clipboard, gets the URI, and uses it in a call to a <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> file descriptor method that opens the stream. The <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> method calls the corresponding <code><a href="../../../reference/android/content/ContentProvider.html">ContentProvider</a></code> method, passing it the content URI. Your provider returns the file descriptor to <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> method. The pasting application then has the responsibility to read the data from the stream. </p> 
 <p> The following list shows the most important file descriptor methods for a content provider. Each of these has a corresponding <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> method with the string &quot;Descriptor&quot; appended to the method name; for example, the <code><a href="../../../reference/android/content/ContentResolver.html">ContentResolver</a></code> analog of <code><a href="../../../reference/android/content/ContentProvider.html#openAssetFile(android.net.Uri, java.lang.String)">openAssetFile()</a></code> is <code><a href="../../../reference/android/content/ContentResolver.html#openAssetFileDescriptor(android.net.Uri, java.lang.String)">openAssetFileDescriptor()</a></code>: </p> 
 <dl> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#openTypedAssetFile(android.net.Uri, java.lang.String, android.os.Bundle)">openTypedAssetFile()</a></code> 
  </dt> 
  <dd>
    This method should return an asset file descriptor, but only if the provided MIME type is supported by the provider. The caller (the application doing the pasting) provides a MIME type pattern. The content provider (of the application that has copied a URI to the clipboard) returns an 
   <code><a href="../../../reference/android/content/res/AssetFileDescriptor.html">AssetFileDescriptor</a></code> file handle if it can provide that MIME type, or throws an exception if it can not. 
   <p> This method handles subsections of files. You can use it to read assets that the content provider has copied to the clipboard. </p> 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#openAssetFile(android.net.Uri, java.lang.String)">openAssetFile()</a></code> 
  </dt> 
  <dd>
    This method is a more general form of 
   <code><a href="../../../reference/android/content/ContentProvider.html#openTypedAssetFile(android.net.Uri, java.lang.String, android.os.Bundle)">openTypedAssetFile()</a></code>. It does not filter for allowed MIME types, but it can read subsections of files. 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/content/ContentProvider.html#openFile(android.net.Uri, java.lang.String)">openFile()</a></code> 
  </dt> 
  <dd>
    This is a more general form of 
   <code><a href="../../../reference/android/content/ContentProvider.html#openAssetFile(android.net.Uri, java.lang.String)">openAssetFile()</a></code>. It can't read subsections of files. 
  </dd> 
 </dl> 
 <p> You can optionally use the <code><a href="../../../reference/android/content/ContentProvider.html#openPipeHelper(android.net.Uri, java.lang.String, android.os.Bundle, T, android.content.ContentProvider.PipeDataWriter&lt;T&gt;)">openPipeHelper()</a></code> method with your file descriptor method. This allows the pasting application to read the stream data in a background thread using a pipe. To use this method, you need to implement the <code><a href="../../../reference/android/content/ContentProvider.PipeDataWriter.html">ContentProvider.PipeDataWriter</a></code> interface. An example of doing this is given in the <a href="../../../resources/samples/NotePad/index.html">Note Pad</a> sample application, in the <code>openTypedAssetFile()</code> method of <code>NotePadProvider.java</code>. </p> 
 ","PipeDataWriter","android.content.ContentProvider.PipeDataWriter","class",0
,"Creating an Input Method","Creating an Input Method","<p> An input method editor (IME) is a user control that enables users to enter text. Android provides an extensible input method framework that allows applications to provide users alternative input methods, such as on-screen keyboards or even speech input. Once installed, users can select which IME they want to use from the system settings and use it across the entire system; only one IME may be enabled at a time. </p> 
 <p> To add an IME to the Android system, you create an Android application containing a class that extends <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code>. In addition, you usually create a &quot;settings&quot; activity that passes options to the IME service. You can also define a settings UI that's displayed as part of the system settings. </p> 
 <p>This article covers the following:</p> 
 <ul> 
  <li>The IME lifecycle.</li> 
  <li>Declaring IME components in the application manifest.</li> 
  <li>The IME API.</li> 
  <li>Designing an IME UI.</li> 
  <li>Sending text from an IME to an application.</li> 
  <li>Working with IME subtypes.</li> 
 </ul> 
 <p> If you haven't worked with IMEs before, you should read the introductory article <a href="http://android-developers.blogspot.com/2009/04/updating-applications-for-on-screen.html">Onscreen Input Methods</a> first. Also, the Soft Keyboard sample app included in the SDK contains sample code that you can modify to start building your own IME. </p> 
 ","InputMethodService","android.inputmethodservice.InputMethodService","class",0
,"Creating an Input Method","The Input Method API","<h2 id="IMEAPI">The Input Method API</h2> 
 <p> Classes specific to IMEs are found in the <code><a href="../../../reference/android/inputmethodservice/package-summary.html">android.inputmethodservice</a></code> and <code><a href="../../../reference/android/view/inputmethod/package-summary.html">android.view.inputmethod</a></code> packages. The <code><a href="../../../reference/android/view/KeyEvent.html">KeyEvent</a></code> class is important for handling keyboard characters. </p> 
 <p> The central part of an IME is a service component, a class that extends <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code>. In addition to implementing the normal service lifecycle, this class has callbacks for providing your IME's UI, handling user input, and delivering text to the field that currently has focus. By default, the <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code> class provides most of the implementation for managing the state and visibility of the IME and communicating with the current input field. </p> 
 <p> The following classes are also important: </p> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html">BaseInputConnection</a></code>
  </dt> 
  <dd>
    Defines the communication channel from an 
   <code><a href="../../../reference/android/view/inputmethod/InputMethod.html">InputMethod</a></code> back to the application that is receiving its input. You use it to read text around the cursor, commit text to the text box, and send raw key events to the application. Applications should extend this class rather than implementing the base interface 
   <code><a href="../../../reference/android/view/inputmethod/InputConnection.html">InputConnection</a></code>. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/inputmethodservice/KeyboardView.html">KeyboardView</a></code>
  </dt> 
  <dd>
    An extension of 
   <code><a href="../../../reference/android/view/View.html">View</a></code> that renders a keyboard and responds to user input events. The keyboard layout is specified by an instance of 
   <code><a href="../../../reference/android/inputmethodservice/Keyboard.html">Keyboard</a></code>, which you can define in an XML file. 
  </dd> 
 </dl> 
 ","InputMethodService","android.inputmethodservice.InputMethodService","class",1
,"Designing the Input Method UI","Input view","<h3 id="InputView">Input view</h3> 
 <p> The input view is the UI where the user inputs text, in the form of keyclicks, handwriting or gestures. When the iIME is displayed for the first time, the system calls the <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html#onCreateInputView()">onCreateInputView()</a></code> callback. In your implementation of this method, you create the layout you want to display in the IME window and return the layout to the system. This snippet is an example of implementing the <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html#onCreateInputView()">onCreateInputView()</a></code> method: </p>
 <pre>
    @Override 
    public View onCreateInputView() { 
        MyKeyboardView inputView = 
            (MyKeyboardView) getLayoutInflater().inflate( R.layout.input, null);
    
        inputView.setOnKeyboardActionListener(this); inputView.setKeyboard(mLatinKeyboard); 
        
        return mInputView; 
    } 
</pre> 
 <p> In this example, <code>MyKeyboardView</code> is an instance of a custom implementation of <code><a href="../../../reference/android/inputmethodservice/KeyboardView.html">KeyboardView</a></code> that renders a <code><a href="../../../reference/android/inputmethodservice/Keyboard.html">Keyboard</a></code>. If youre building a traditional QWERTY keyboard, see the Soft Keyboard <a href="../../../tools/samples/index.html">sample app</a> for an example of how to extend the <code><a href="../../../reference/android/inputmethodservice/KeyboardView.html">KeyboardView</a></code> class. </p> 
 ","InputMethodService","android.inputmethodservice.InputMethodService","class",0
,"Designing the Input Method UI","Candidates view","<h3 id="CandidateView">Candidates view</h3> 
 <p> The candidates view is the UI where the IME displays potential word corrections or suggestions for the user to select. In the IME lifecycle, the system calls <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html#onCreateCandidatesView()">onCreateCandidatesView()</a></code> when it's ready to display the candidate view. In your implementation of this method, return a layout that shows word suggestions, or return null if you dont want to show anything (a null response is the default behavior, so you dont have to implement this if you dont provide suggestions).</p> 
 <p> For an example implementation that provides user suggestions, see the Soft Keyboard <a href="../../../tools/samples/index.html">sample app</a>. </p> 
 ","InputMethodService","android.inputmethodservice.InputMethodService","class",0
,"UI design considerations","Handling different input types","<h4>Handling different input types</h4> 
 <p> Android text fields allow you to set a specific input type, such as free form text, numbers, URLs, email addresses, and search strings. When you implement a new IME, you need to detect the input type of each field and provide the appropriate interface for it. However, you don't have to set up your IME to check that the user entered text that's valid for the input type; that's the responsibility of the application that owns the text field. </p> 
 <p> For example, here are screenshots of the interfaces that the Latin IME provided with the Android platform provides for text and phone number inputs: </p> 
 <img src="../../../resources/articles/images/inputmethod_text_type_screenshot.png" alt="" height="142" id="figure2" /> 
 <img src="../../../resources/articles/images/inputmethod_numeric_type_screenshot.png" alt="" height="120" id="figure2a" /> 
 <p class="img-caption"> <strong>Figure 2.</strong> Latin IME input types. </p> 
 <p> When an input field receives focus and your IME starts, the system calls <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html#onStartInputView(android.view.inputmethod.EditorInfo, boolean)">onStartInputView()</a></code>, passing in an <code><a href="../../../reference/android/view/inputmethod/EditorInfo.html">EditorInfo</a></code> object that contains details about the input type and other attributes of the text field. In this object, the <code><a href="../../../reference/android/view/inputmethod/EditorInfo.html#inputType">inputType</a></code> field contains the text field's input type. </p> 
 <p> The <code><a href="../../../reference/android/view/inputmethod/EditorInfo.html#inputType">inputType</a></code> field is an <code>int</code> that contains bit patterns for various input type settings. To test it for the text field's input type, mask it with the constant <code><a href="../../../reference/android/text/InputType.html#TYPE_MASK_CLASS">TYPE_MASK_CLASS</a></code>, like this: </p> 
 <pre>
inputType &amp; InputType.TYPE_MASK_CLASS 
</pre> 
 <p> The input type bit pattern can have one of several values, including: </p> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_NUMBER">TYPE_CLASS_NUMBER</a></code>
  </dt> 
  <dd>
    A text field for entering numbers. As illustrated in the previous screen shot, the Latin IME displays a number pad for fields of this type. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_DATETIME">TYPE_CLASS_DATETIME</a></code>
  </dt> 
  <dd>
    A text field for entering a date and time. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_PHONE">TYPE_CLASS_PHONE</a></code>
  </dt> 
  <dd>
    A text field for entering telephone numbers. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_TEXT">TYPE_CLASS_TEXT</a></code>
  </dt> 
  <dd>
    A text field for entering all supported characters. 
  </dd> 
 </dl> 
 <p> These constants are described in more detail in the reference documentation for <code><a href="../../../reference/android/text/InputType.html">InputType</a></code>. </p> 
 <p> The <code><a href="../../../reference/android/view/inputmethod/EditorInfo.html#inputType">inputType</a></code> field can contain other bits that indicate a variant of the text field type, such as: </p> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_TEXT_VARIATION_PASSWORD">TYPE_TEXT_VARIATION_PASSWORD</a></code>
  </dt> 
  <dd>
    A variant of 
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_TEXT">TYPE_CLASS_TEXT</a></code> for entering passwords. The input method will display dingbats instead of the actual text. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_TEXT_VARIATION_URI">TYPE_TEXT_VARIATION_URI</a></code>
  </dt> 
  <dd>
    A variant of 
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_TEXT">TYPE_CLASS_TEXT</a></code> for entering web URLs and other Uniform Resource Identifiers (URIs). 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_TEXT_FLAG_AUTO_COMPLETE">TYPE_TEXT_FLAG_AUTO_COMPLETE</a></code>
  </dt> 
  <dd>
    A variant of 
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_TEXT">TYPE_CLASS_TEXT</a></code> for entering text that the application &quot;auto-completes&quot; from a dictionary, search, or other facility. 
  </dd> 
 </dl> 
 <p> Remember to mask <code><a href="../../../reference/android/view/inputmethod/EditorInfo.html#inputType">inputType</a></code> with the appropriate constant when you test for these variants. The available mask constants are listed in the reference documentation for <code><a href="../../../reference/android/text/InputType.html">InputType</a></code>. </p> 
 <p class="caution"> <strong>Caution:</strong> In your own IME, make sure you handle text correctly when you send it to a password field. Hide the password in your UI both in the input view and in the candidates view. Also remember that you shouldn't store passwords on a device. To learn more, see the <a href="../../../guide/practices/security.html">Designing for Security</a> guide. </p> 
 ","InputMethodService","android.inputmethodservice.InputMethodService","class",0
,"Creating an Input Method","Sending Text to the Application","<h2 id="SendText">Sending Text to the Application</h2> 
 <p> As the user inputs text with your IME, you can send text to the application by sending individual key events or by editing the text around the cursor in the application's text field. In either case, you use an instance of <code><a href="../../../reference/android/view/inputmethod/InputConnection.html">InputConnection</a></code> to deliver the text. To get this instance, call <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html#getCurrentInputConnection()">InputMethodService.getCurrentInputConnection()</a></code>. </p> 
 ","InputMethodService","android.inputmethodservice.InputMethodService","class",0
,"Sending Text to the Application","Intercepting hardware key events","<h3 id="HardwareKeyEvents">Intercepting hardware key events</h3> 
 <p> Even though the input method window doesn't have explicit focus, it receives hardware key events first and can choose to consume them or forward them along to the application. For example, you may want to consume the directional keys to navigate within your UI for candidate selection during composition. You may also want to trap the back key to dismiss any popups originating from the input method window.</p> 
 <p> To intercept hardware keys, override <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html#onKeyDown(int, android.view.KeyEvent)">onKeyDown()</a></code> and <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html#onKeyUp(int, android.view.KeyEvent)">onKeyUp()</a></code>. See the Soft Keyboard <a href="../../../tools/samples/index.html">sample app</a> for an example. </p> 
 <p> Remember to call the <code>super()</code> method for keys you don't want to handle yourself. </p> 
 ","InputMethodService","android.inputmethodservice.InputMethodService","class",0
,"Creating an Input Method","Declaring IME Components in the Manifest","<h2 id="DefiningIME">Declaring IME Components in the Manifest</h2> 
 <p> In the Android system, an IME is an Android application that contains a special IME service. The application's manifest file must declare the service, request the necessary permissions, provide an intent filter that matches the action <code>action.view.InputMethod</code>, and provide metadata that defines characteristics of the IME. In addition, to provide a settings interface that allows the user to modify the behavior of the IME, you can define a &quot;settings&quot; activity that can be launched from System Settings. </p> 
 <p> The following snippet declares IME service. It requests the permission <code><a href="../../../reference/android/Manifest.permission.html#BIND_INPUT_METHOD">BIND_INPUT_METHOD</a></code> to allow the service to connect the IME to the system, sets up an intent filter that matches the action <code>android.view.InputMethod</code>, and defines metadata for the IME: </p> 
 <pre>
&lt;!-- Declares the input method service --&gt;
    &lt;service android:name=&quot;FastInputIME&quot;
        android:label=&quot;@string/fast_input_label&quot;
        android:permission=&quot;android.permission.BIND_INPUT_METHOD&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.view.InputMethod&quot; /&gt;
        &lt;/intent-filter&gt;
        &lt;meta-data android:name=&quot;android.view.im&quot; android:resource=&quot;@xml/method&quot; /&gt;
    &lt;/service&gt;
</pre> 
 <p> This next snippet declares the settings activity for the IME. It has an intent filter for <code><a href="../../../reference/android/content/Intent.html#ACTION_MAIN">ACTION_MAIN</a></code> that indicates this activity is the main entry point for the IME application:</p> 
 <pre>
    &lt;!-- Optional: an activity for controlling the IME settings --&gt;
    &lt;activity android:name=&quot;FastInputIMESettings&quot; 
        android:label=&quot;@string/fast_input_settings&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
</pre> 
 <p> You can also provide access to the IME's settings directly from its UI. </p> 
 ","permission","android.Manifest.permission","class",0
,"Implementing a Spell Checker Service","Spell checker manifest and metadata","<h3 id="SpellCheckXML">Spell checker manifest and metadata</h3> 
 <p> In addition to code, you need to provide the appropriate manifest file and a metadata file for the spelling checker. </p> 
 <p> The manifest file defines the application, the service, and the activity for controlling settings, as shown in the following snippet: </p> 
 <pre>
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.example.android.samplespellcheckerservice&quot; &gt;
    &lt;application
        android:label=&quot;@string/app_name&quot; &gt;
        &lt;service
            android:label=&quot;@string/app_name&quot;
            android:name=&quot;.SampleSpellCheckerService&quot;
            android:permission=&quot;android.permission.BIND_TEXT_SERVICE&quot; &gt;
            &lt;intent-filter &gt;
                &lt;action android:name=&quot;android.service.textservice.SpellCheckerService&quot; /&gt;
            &lt;/intent-filter&gt;

            &lt;meta-data
                android:name=&quot;android.view.textservice.scs&quot;
                android:resource=&quot;@xml/spellchecker&quot; /&gt;
        &lt;/service&gt;

        &lt;activity
            android:label=&quot;@string/sample_settings&quot;
            android:name=&quot;SpellCheckerSettingsActivity&quot; &gt;
            &lt;intent-filter &gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;
&lt;/manifest&gt;
</pre> 
 <p> Notice that components that want to use the service must request the permission <code><a href="../../../reference/android/Manifest.permission.html#BIND_TEXT_SERVICE">BIND_TEXT_SERVICE</a></code> to ensure that only the system binds to the service. The service's definition also specifies the <code>spellchecker.xml</code> metadata file, which is described in the next section. </p> 
 <p> The metadata file <code>spellchecker.xml</code> contains the following XML: </p> 
 <pre>
&lt;spell-checker xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:label=&quot;@string/spellchecker_name&quot;
        android:settingsActivity=&quot;com.example.SpellCheckerSettingsActivity&quot;&gt;
    &lt;subtype
            android:label=&quot;@string/subtype_generic&quot;
            android:subtypeLocale=&quot;en
    /&gt;
    &lt;subtype
            android:label=&quot;@string/subtype_generic&quot;
            android:subtypeLocale=&quot;fr
    /&gt;
&lt;/spell-checker&gt;
</pre> 
 <p> The metadata specifies the activity that the spelling checker uses for controlling settings. It also defines subtypes for the spelling checker; in this case, the subtypes define locales that the spelling checker can handle. </p> 
 <!--  Accessing the Spell Checker Service from a Client --> 
 ","permission","android.Manifest.permission","class",1
,"Creating an Input Method","The Input Method API","<h2 id="IMEAPI">The Input Method API</h2> 
 <p> Classes specific to IMEs are found in the <code><a href="../../../reference/android/inputmethodservice/package-summary.html">android.inputmethodservice</a></code> and <code><a href="../../../reference/android/view/inputmethod/package-summary.html">android.view.inputmethod</a></code> packages. The <code><a href="../../../reference/android/view/KeyEvent.html">KeyEvent</a></code> class is important for handling keyboard characters. </p> 
 <p> The central part of an IME is a service component, a class that extends <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code>. In addition to implementing the normal service lifecycle, this class has callbacks for providing your IME's UI, handling user input, and delivering text to the field that currently has focus. By default, the <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code> class provides most of the implementation for managing the state and visibility of the IME and communicating with the current input field. </p> 
 <p> The following classes are also important: </p> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html">BaseInputConnection</a></code>
  </dt> 
  <dd>
    Defines the communication channel from an 
   <code><a href="../../../reference/android/view/inputmethod/InputMethod.html">InputMethod</a></code> back to the application that is receiving its input. You use it to read text around the cursor, commit text to the text box, and send raw key events to the application. Applications should extend this class rather than implementing the base interface 
   <code><a href="../../../reference/android/view/inputmethod/InputConnection.html">InputConnection</a></code>. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/inputmethodservice/KeyboardView.html">KeyboardView</a></code>
  </dt> 
  <dd>
    An extension of 
   <code><a href="../../../reference/android/view/View.html">View</a></code> that renders a keyboard and responds to user input events. The keyboard layout is specified by an instance of 
   <code><a href="../../../reference/android/inputmethodservice/Keyboard.html">Keyboard</a></code>, which you can define in an XML file. 
  </dd> 
 </dl> 
 ","KeyboardView","android.inputmethodservice.KeyboardView","class",1
,"Designing the Input Method UI","Input view","<h3 id="InputView">Input view</h3> 
 <p> The input view is the UI where the user inputs text, in the form of keyclicks, handwriting or gestures. When the iIME is displayed for the first time, the system calls the <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html#onCreateInputView()">onCreateInputView()</a></code> callback. In your implementation of this method, you create the layout you want to display in the IME window and return the layout to the system. This snippet is an example of implementing the <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html#onCreateInputView()">onCreateInputView()</a></code> method: </p>
 <pre>
    @Override 
    public View onCreateInputView() { 
        MyKeyboardView inputView = 
            (MyKeyboardView) getLayoutInflater().inflate( R.layout.input, null);
    
        inputView.setOnKeyboardActionListener(this); inputView.setKeyboard(mLatinKeyboard); 
        
        return mInputView; 
    } 
</pre> 
 <p> In this example, <code>MyKeyboardView</code> is an instance of a custom implementation of <code><a href="../../../reference/android/inputmethodservice/KeyboardView.html">KeyboardView</a></code> that renders a <code><a href="../../../reference/android/inputmethodservice/Keyboard.html">Keyboard</a></code>. If youre building a traditional QWERTY keyboard, see the Soft Keyboard <a href="../../../tools/samples/index.html">sample app</a> for an example of how to extend the <code><a href="../../../reference/android/inputmethodservice/KeyboardView.html">KeyboardView</a></code> class. </p> 
 ","KeyboardView","android.inputmethodservice.KeyboardView","class",0
,"Creating an Input Method","The Input Method API","<h2 id="IMEAPI">The Input Method API</h2> 
 <p> Classes specific to IMEs are found in the <code><a href="../../../reference/android/inputmethodservice/package-summary.html">android.inputmethodservice</a></code> and <code><a href="../../../reference/android/view/inputmethod/package-summary.html">android.view.inputmethod</a></code> packages. The <code><a href="../../../reference/android/view/KeyEvent.html">KeyEvent</a></code> class is important for handling keyboard characters. </p> 
 <p> The central part of an IME is a service component, a class that extends <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code>. In addition to implementing the normal service lifecycle, this class has callbacks for providing your IME's UI, handling user input, and delivering text to the field that currently has focus. By default, the <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code> class provides most of the implementation for managing the state and visibility of the IME and communicating with the current input field. </p> 
 <p> The following classes are also important: </p> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html">BaseInputConnection</a></code>
  </dt> 
  <dd>
    Defines the communication channel from an 
   <code><a href="../../../reference/android/view/inputmethod/InputMethod.html">InputMethod</a></code> back to the application that is receiving its input. You use it to read text around the cursor, commit text to the text box, and send raw key events to the application. Applications should extend this class rather than implementing the base interface 
   <code><a href="../../../reference/android/view/inputmethod/InputConnection.html">InputConnection</a></code>. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/inputmethodservice/KeyboardView.html">KeyboardView</a></code>
  </dt> 
  <dd>
    An extension of 
   <code><a href="../../../reference/android/view/View.html">View</a></code> that renders a keyboard and responds to user input events. The keyboard layout is specified by an instance of 
   <code><a href="../../../reference/android/inputmethodservice/Keyboard.html">Keyboard</a></code>, which you can define in an XML file. 
  </dd> 
 </dl> 
 ","package-summary","android.inputmethodservice.package-summary","class",0
,"Creating an Input Method","The Input Method API","<h2 id="IMEAPI">The Input Method API</h2> 
 <p> Classes specific to IMEs are found in the <code><a href="../../../reference/android/inputmethodservice/package-summary.html">android.inputmethodservice</a></code> and <code><a href="../../../reference/android/view/inputmethod/package-summary.html">android.view.inputmethod</a></code> packages. The <code><a href="../../../reference/android/view/KeyEvent.html">KeyEvent</a></code> class is important for handling keyboard characters. </p> 
 <p> The central part of an IME is a service component, a class that extends <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code>. In addition to implementing the normal service lifecycle, this class has callbacks for providing your IME's UI, handling user input, and delivering text to the field that currently has focus. By default, the <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code> class provides most of the implementation for managing the state and visibility of the IME and communicating with the current input field. </p> 
 <p> The following classes are also important: </p> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html">BaseInputConnection</a></code>
  </dt> 
  <dd>
    Defines the communication channel from an 
   <code><a href="../../../reference/android/view/inputmethod/InputMethod.html">InputMethod</a></code> back to the application that is receiving its input. You use it to read text around the cursor, commit text to the text box, and send raw key events to the application. Applications should extend this class rather than implementing the base interface 
   <code><a href="../../../reference/android/view/inputmethod/InputConnection.html">InputConnection</a></code>. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/inputmethodservice/KeyboardView.html">KeyboardView</a></code>
  </dt> 
  <dd>
    An extension of 
   <code><a href="../../../reference/android/view/View.html">View</a></code> that renders a keyboard and responds to user input events. The keyboard layout is specified by an instance of 
   <code><a href="../../../reference/android/inputmethodservice/Keyboard.html">Keyboard</a></code>, which you can define in an XML file. 
  </dd> 
 </dl> 
 ","KeyEvent","android.view.KeyEvent","class",1
,"Creating an Input Method","The Input Method API","<h2 id="IMEAPI">The Input Method API</h2> 
 <p> Classes specific to IMEs are found in the <code><a href="../../../reference/android/inputmethodservice/package-summary.html">android.inputmethodservice</a></code> and <code><a href="../../../reference/android/view/inputmethod/package-summary.html">android.view.inputmethod</a></code> packages. The <code><a href="../../../reference/android/view/KeyEvent.html">KeyEvent</a></code> class is important for handling keyboard characters. </p> 
 <p> The central part of an IME is a service component, a class that extends <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code>. In addition to implementing the normal service lifecycle, this class has callbacks for providing your IME's UI, handling user input, and delivering text to the field that currently has focus. By default, the <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code> class provides most of the implementation for managing the state and visibility of the IME and communicating with the current input field. </p> 
 <p> The following classes are also important: </p> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html">BaseInputConnection</a></code>
  </dt> 
  <dd>
    Defines the communication channel from an 
   <code><a href="../../../reference/android/view/inputmethod/InputMethod.html">InputMethod</a></code> back to the application that is receiving its input. You use it to read text around the cursor, commit text to the text box, and send raw key events to the application. Applications should extend this class rather than implementing the base interface 
   <code><a href="../../../reference/android/view/inputmethod/InputConnection.html">InputConnection</a></code>. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/inputmethodservice/KeyboardView.html">KeyboardView</a></code>
  </dt> 
  <dd>
    An extension of 
   <code><a href="../../../reference/android/view/View.html">View</a></code> that renders a keyboard and responds to user input events. The keyboard layout is specified by an instance of 
   <code><a href="../../../reference/android/inputmethodservice/Keyboard.html">Keyboard</a></code>, which you can define in an XML file. 
  </dd> 
 </dl> 
 ","Keyboard","android.inputmethodservice.Keyboard","class",0
,"Designing the Input Method UI","Input view","<h3 id="InputView">Input view</h3> 
 <p> The input view is the UI where the user inputs text, in the form of keyclicks, handwriting or gestures. When the iIME is displayed for the first time, the system calls the <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html#onCreateInputView()">onCreateInputView()</a></code> callback. In your implementation of this method, you create the layout you want to display in the IME window and return the layout to the system. This snippet is an example of implementing the <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html#onCreateInputView()">onCreateInputView()</a></code> method: </p>
 <pre>
    @Override 
    public View onCreateInputView() { 
        MyKeyboardView inputView = 
            (MyKeyboardView) getLayoutInflater().inflate( R.layout.input, null);
    
        inputView.setOnKeyboardActionListener(this); inputView.setKeyboard(mLatinKeyboard); 
        
        return mInputView; 
    } 
</pre> 
 <p> In this example, <code>MyKeyboardView</code> is an instance of a custom implementation of <code><a href="../../../reference/android/inputmethodservice/KeyboardView.html">KeyboardView</a></code> that renders a <code><a href="../../../reference/android/inputmethodservice/Keyboard.html">Keyboard</a></code>. If youre building a traditional QWERTY keyboard, see the Soft Keyboard <a href="../../../tools/samples/index.html">sample app</a> for an example of how to extend the <code><a href="../../../reference/android/inputmethodservice/KeyboardView.html">KeyboardView</a></code> class. </p> 
 ","Keyboard","android.inputmethodservice.Keyboard","class",0
,"Creating an Input Method","The Input Method API","<h2 id="IMEAPI">The Input Method API</h2> 
 <p> Classes specific to IMEs are found in the <code><a href="../../../reference/android/inputmethodservice/package-summary.html">android.inputmethodservice</a></code> and <code><a href="../../../reference/android/view/inputmethod/package-summary.html">android.view.inputmethod</a></code> packages. The <code><a href="../../../reference/android/view/KeyEvent.html">KeyEvent</a></code> class is important for handling keyboard characters. </p> 
 <p> The central part of an IME is a service component, a class that extends <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code>. In addition to implementing the normal service lifecycle, this class has callbacks for providing your IME's UI, handling user input, and delivering text to the field that currently has focus. By default, the <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code> class provides most of the implementation for managing the state and visibility of the IME and communicating with the current input field. </p> 
 <p> The following classes are also important: </p> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html">BaseInputConnection</a></code>
  </dt> 
  <dd>
    Defines the communication channel from an 
   <code><a href="../../../reference/android/view/inputmethod/InputMethod.html">InputMethod</a></code> back to the application that is receiving its input. You use it to read text around the cursor, commit text to the text box, and send raw key events to the application. Applications should extend this class rather than implementing the base interface 
   <code><a href="../../../reference/android/view/inputmethod/InputConnection.html">InputConnection</a></code>. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/inputmethodservice/KeyboardView.html">KeyboardView</a></code>
  </dt> 
  <dd>
    An extension of 
   <code><a href="../../../reference/android/view/View.html">View</a></code> that renders a keyboard and responds to user input events. The keyboard layout is specified by an instance of 
   <code><a href="../../../reference/android/inputmethodservice/Keyboard.html">Keyboard</a></code>, which you can define in an XML file. 
  </dd> 
 </dl> 
 ","InputMethod","android.view.inputmethod.InputMethod","class",1
,"Creating an Input Method","The Input Method API","<h2 id="IMEAPI">The Input Method API</h2> 
 <p> Classes specific to IMEs are found in the <code><a href="../../../reference/android/inputmethodservice/package-summary.html">android.inputmethodservice</a></code> and <code><a href="../../../reference/android/view/inputmethod/package-summary.html">android.view.inputmethod</a></code> packages. The <code><a href="../../../reference/android/view/KeyEvent.html">KeyEvent</a></code> class is important for handling keyboard characters. </p> 
 <p> The central part of an IME is a service component, a class that extends <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code>. In addition to implementing the normal service lifecycle, this class has callbacks for providing your IME's UI, handling user input, and delivering text to the field that currently has focus. By default, the <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code> class provides most of the implementation for managing the state and visibility of the IME and communicating with the current input field. </p> 
 <p> The following classes are also important: </p> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html">BaseInputConnection</a></code>
  </dt> 
  <dd>
    Defines the communication channel from an 
   <code><a href="../../../reference/android/view/inputmethod/InputMethod.html">InputMethod</a></code> back to the application that is receiving its input. You use it to read text around the cursor, commit text to the text box, and send raw key events to the application. Applications should extend this class rather than implementing the base interface 
   <code><a href="../../../reference/android/view/inputmethod/InputConnection.html">InputConnection</a></code>. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/inputmethodservice/KeyboardView.html">KeyboardView</a></code>
  </dt> 
  <dd>
    An extension of 
   <code><a href="../../../reference/android/view/View.html">View</a></code> that renders a keyboard and responds to user input events. The keyboard layout is specified by an instance of 
   <code><a href="../../../reference/android/inputmethodservice/Keyboard.html">Keyboard</a></code>, which you can define in an XML file. 
  </dd> 
 </dl> 
 ","InputConnection","android.view.inputmethod.InputConnection","class",0
,"Creating an Input Method","Sending Text to the Application","<h2 id="SendText">Sending Text to the Application</h2> 
 <p> As the user inputs text with your IME, you can send text to the application by sending individual key events or by editing the text around the cursor in the application's text field. In either case, you use an instance of <code><a href="../../../reference/android/view/inputmethod/InputConnection.html">InputConnection</a></code> to deliver the text. To get this instance, call <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html#getCurrentInputConnection()">InputMethodService.getCurrentInputConnection()</a></code>. </p> 
 ","InputConnection","android.view.inputmethod.InputConnection","class",0
,"Creating an Input Method","The Input Method API","<h2 id="IMEAPI">The Input Method API</h2> 
 <p> Classes specific to IMEs are found in the <code><a href="../../../reference/android/inputmethodservice/package-summary.html">android.inputmethodservice</a></code> and <code><a href="../../../reference/android/view/inputmethod/package-summary.html">android.view.inputmethod</a></code> packages. The <code><a href="../../../reference/android/view/KeyEvent.html">KeyEvent</a></code> class is important for handling keyboard characters. </p> 
 <p> The central part of an IME is a service component, a class that extends <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code>. In addition to implementing the normal service lifecycle, this class has callbacks for providing your IME's UI, handling user input, and delivering text to the field that currently has focus. By default, the <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code> class provides most of the implementation for managing the state and visibility of the IME and communicating with the current input field. </p> 
 <p> The following classes are also important: </p> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html">BaseInputConnection</a></code>
  </dt> 
  <dd>
    Defines the communication channel from an 
   <code><a href="../../../reference/android/view/inputmethod/InputMethod.html">InputMethod</a></code> back to the application that is receiving its input. You use it to read text around the cursor, commit text to the text box, and send raw key events to the application. Applications should extend this class rather than implementing the base interface 
   <code><a href="../../../reference/android/view/inputmethod/InputConnection.html">InputConnection</a></code>. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/inputmethodservice/KeyboardView.html">KeyboardView</a></code>
  </dt> 
  <dd>
    An extension of 
   <code><a href="../../../reference/android/view/View.html">View</a></code> that renders a keyboard and responds to user input events. The keyboard layout is specified by an instance of 
   <code><a href="../../../reference/android/inputmethodservice/Keyboard.html">Keyboard</a></code>, which you can define in an XML file. 
  </dd> 
 </dl> 
 ","View","android.view.View","class",1
,"Creating an Input Method","The Input Method API","<h2 id="IMEAPI">The Input Method API</h2> 
 <p> Classes specific to IMEs are found in the <code><a href="../../../reference/android/inputmethodservice/package-summary.html">android.inputmethodservice</a></code> and <code><a href="../../../reference/android/view/inputmethod/package-summary.html">android.view.inputmethod</a></code> packages. The <code><a href="../../../reference/android/view/KeyEvent.html">KeyEvent</a></code> class is important for handling keyboard characters. </p> 
 <p> The central part of an IME is a service component, a class that extends <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code>. In addition to implementing the normal service lifecycle, this class has callbacks for providing your IME's UI, handling user input, and delivering text to the field that currently has focus. By default, the <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code> class provides most of the implementation for managing the state and visibility of the IME and communicating with the current input field. </p> 
 <p> The following classes are also important: </p> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html">BaseInputConnection</a></code>
  </dt> 
  <dd>
    Defines the communication channel from an 
   <code><a href="../../../reference/android/view/inputmethod/InputMethod.html">InputMethod</a></code> back to the application that is receiving its input. You use it to read text around the cursor, commit text to the text box, and send raw key events to the application. Applications should extend this class rather than implementing the base interface 
   <code><a href="../../../reference/android/view/inputmethod/InputConnection.html">InputConnection</a></code>. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/inputmethodservice/KeyboardView.html">KeyboardView</a></code>
  </dt> 
  <dd>
    An extension of 
   <code><a href="../../../reference/android/view/View.html">View</a></code> that renders a keyboard and responds to user input events. The keyboard layout is specified by an instance of 
   <code><a href="../../../reference/android/inputmethodservice/Keyboard.html">Keyboard</a></code>, which you can define in an XML file. 
  </dd> 
 </dl> 
 ","BaseInputConnection","android.view.inputmethod.BaseInputConnection","class",1
,"Sending Text to the Application","Editing the text around the cursor","<h3 id="EditingCursor">Editing the text around the cursor</h3> 
 <p> When you're handling the editing of existing text in a text field, some of the more useful methods in <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html">BaseInputConnection</a></code> are: </p> 
 <dl> 
  <dt> 
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html#getTextBeforeCursor(int, int)">getTextBeforeCursor()</a></code>
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code> containing the number of requested characters before the current cursor position. 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html#getTextAfterCursor(int, int)">getTextAfterCursor()</a></code> 
  </dt> 
  <dd>
    Returns a 
   <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code> containing the number of requested characters following the current cursor position. 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html#deleteSurroundingText(int, int)">deleteSurroundingText()</a></code> 
  </dt> 
  <dd>
    Deletes the specified number of characters before and following the current cursor position. 
  </dd> 
  <dt> 
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html#commitText(java.lang.CharSequence, int)">commitText()</a></code> 
  </dt> 
  <dd>
    Commit a 
   <code><a href="../../../reference/java/lang/CharSequence.html">CharSequence</a></code> to the text field and set a new cursor position. 
  </dd> 
 </dl> 
 <p> For example, the following snippet shows how to replace the text &quot;Fell&quot; to the left of the with the text &quot;Hello!&quot;: </p> 
 <pre>
    InputConnection ic = getCurrentInputConnection();
    
    ic.deleteSurroundingText(4, 0);
    
    ic.commitText(&quot;Hello&quot;, 1);
    
    ic.commitText(&quot;!&quot;, 1);
</pre> 
 ","BaseInputConnection","android.view.inputmethod.BaseInputConnection","class",0
,"Creating an Input Method","The Input Method API","<h2 id="IMEAPI">The Input Method API</h2> 
 <p> Classes specific to IMEs are found in the <code><a href="../../../reference/android/inputmethodservice/package-summary.html">android.inputmethodservice</a></code> and <code><a href="../../../reference/android/view/inputmethod/package-summary.html">android.view.inputmethod</a></code> packages. The <code><a href="../../../reference/android/view/KeyEvent.html">KeyEvent</a></code> class is important for handling keyboard characters. </p> 
 <p> The central part of an IME is a service component, a class that extends <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code>. In addition to implementing the normal service lifecycle, this class has callbacks for providing your IME's UI, handling user input, and delivering text to the field that currently has focus. By default, the <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html">InputMethodService</a></code> class provides most of the implementation for managing the state and visibility of the IME and communicating with the current input field. </p> 
 <p> The following classes are also important: </p> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/view/inputmethod/BaseInputConnection.html">BaseInputConnection</a></code>
  </dt> 
  <dd>
    Defines the communication channel from an 
   <code><a href="../../../reference/android/view/inputmethod/InputMethod.html">InputMethod</a></code> back to the application that is receiving its input. You use it to read text around the cursor, commit text to the text box, and send raw key events to the application. Applications should extend this class rather than implementing the base interface 
   <code><a href="../../../reference/android/view/inputmethod/InputConnection.html">InputConnection</a></code>. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/inputmethodservice/KeyboardView.html">KeyboardView</a></code>
  </dt> 
  <dd>
    An extension of 
   <code><a href="../../../reference/android/view/View.html">View</a></code> that renders a keyboard and responds to user input events. The keyboard layout is specified by an instance of 
   <code><a href="../../../reference/android/inputmethodservice/Keyboard.html">Keyboard</a></code>, which you can define in an XML file. 
  </dd> 
 </dl> 
 ","package-summary","android.view.inputmethod.package-summary","class",0
,"UI design considerations","Handling different input types","<h4>Handling different input types</h4> 
 <p> Android text fields allow you to set a specific input type, such as free form text, numbers, URLs, email addresses, and search strings. When you implement a new IME, you need to detect the input type of each field and provide the appropriate interface for it. However, you don't have to set up your IME to check that the user entered text that's valid for the input type; that's the responsibility of the application that owns the text field. </p> 
 <p> For example, here are screenshots of the interfaces that the Latin IME provided with the Android platform provides for text and phone number inputs: </p> 
 <img src="../../../resources/articles/images/inputmethod_text_type_screenshot.png" alt="" height="142" id="figure2" /> 
 <img src="../../../resources/articles/images/inputmethod_numeric_type_screenshot.png" alt="" height="120" id="figure2a" /> 
 <p class="img-caption"> <strong>Figure 2.</strong> Latin IME input types. </p> 
 <p> When an input field receives focus and your IME starts, the system calls <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html#onStartInputView(android.view.inputmethod.EditorInfo, boolean)">onStartInputView()</a></code>, passing in an <code><a href="../../../reference/android/view/inputmethod/EditorInfo.html">EditorInfo</a></code> object that contains details about the input type and other attributes of the text field. In this object, the <code><a href="../../../reference/android/view/inputmethod/EditorInfo.html#inputType">inputType</a></code> field contains the text field's input type. </p> 
 <p> The <code><a href="../../../reference/android/view/inputmethod/EditorInfo.html#inputType">inputType</a></code> field is an <code>int</code> that contains bit patterns for various input type settings. To test it for the text field's input type, mask it with the constant <code><a href="../../../reference/android/text/InputType.html#TYPE_MASK_CLASS">TYPE_MASK_CLASS</a></code>, like this: </p> 
 <pre>
inputType &amp; InputType.TYPE_MASK_CLASS 
</pre> 
 <p> The input type bit pattern can have one of several values, including: </p> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_NUMBER">TYPE_CLASS_NUMBER</a></code>
  </dt> 
  <dd>
    A text field for entering numbers. As illustrated in the previous screen shot, the Latin IME displays a number pad for fields of this type. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_DATETIME">TYPE_CLASS_DATETIME</a></code>
  </dt> 
  <dd>
    A text field for entering a date and time. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_PHONE">TYPE_CLASS_PHONE</a></code>
  </dt> 
  <dd>
    A text field for entering telephone numbers. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_TEXT">TYPE_CLASS_TEXT</a></code>
  </dt> 
  <dd>
    A text field for entering all supported characters. 
  </dd> 
 </dl> 
 <p> These constants are described in more detail in the reference documentation for <code><a href="../../../reference/android/text/InputType.html">InputType</a></code>. </p> 
 <p> The <code><a href="../../../reference/android/view/inputmethod/EditorInfo.html#inputType">inputType</a></code> field can contain other bits that indicate a variant of the text field type, such as: </p> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_TEXT_VARIATION_PASSWORD">TYPE_TEXT_VARIATION_PASSWORD</a></code>
  </dt> 
  <dd>
    A variant of 
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_TEXT">TYPE_CLASS_TEXT</a></code> for entering passwords. The input method will display dingbats instead of the actual text. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_TEXT_VARIATION_URI">TYPE_TEXT_VARIATION_URI</a></code>
  </dt> 
  <dd>
    A variant of 
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_TEXT">TYPE_CLASS_TEXT</a></code> for entering web URLs and other Uniform Resource Identifiers (URIs). 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_TEXT_FLAG_AUTO_COMPLETE">TYPE_TEXT_FLAG_AUTO_COMPLETE</a></code>
  </dt> 
  <dd>
    A variant of 
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_TEXT">TYPE_CLASS_TEXT</a></code> for entering text that the application &quot;auto-completes&quot; from a dictionary, search, or other facility. 
  </dd> 
 </dl> 
 <p> Remember to mask <code><a href="../../../reference/android/view/inputmethod/EditorInfo.html#inputType">inputType</a></code> with the appropriate constant when you test for these variants. The available mask constants are listed in the reference documentation for <code><a href="../../../reference/android/text/InputType.html">InputType</a></code>. </p> 
 <p class="caution"> <strong>Caution:</strong> In your own IME, make sure you handle text correctly when you send it to a password field. Hide the password in your UI both in the input view and in the candidates view. Also remember that you shouldn't store passwords on a device. To learn more, see the <a href="../../../guide/practices/security.html">Designing for Security</a> guide. </p> 
 ","InputType","android.text.InputType","class",0
,"UI design considerations","Handling different input types","<h4>Handling different input types</h4> 
 <p> Android text fields allow you to set a specific input type, such as free form text, numbers, URLs, email addresses, and search strings. When you implement a new IME, you need to detect the input type of each field and provide the appropriate interface for it. However, you don't have to set up your IME to check that the user entered text that's valid for the input type; that's the responsibility of the application that owns the text field. </p> 
 <p> For example, here are screenshots of the interfaces that the Latin IME provided with the Android platform provides for text and phone number inputs: </p> 
 <img src="../../../resources/articles/images/inputmethod_text_type_screenshot.png" alt="" height="142" id="figure2" /> 
 <img src="../../../resources/articles/images/inputmethod_numeric_type_screenshot.png" alt="" height="120" id="figure2a" /> 
 <p class="img-caption"> <strong>Figure 2.</strong> Latin IME input types. </p> 
 <p> When an input field receives focus and your IME starts, the system calls <code><a href="../../../reference/android/inputmethodservice/InputMethodService.html#onStartInputView(android.view.inputmethod.EditorInfo, boolean)">onStartInputView()</a></code>, passing in an <code><a href="../../../reference/android/view/inputmethod/EditorInfo.html">EditorInfo</a></code> object that contains details about the input type and other attributes of the text field. In this object, the <code><a href="../../../reference/android/view/inputmethod/EditorInfo.html#inputType">inputType</a></code> field contains the text field's input type. </p> 
 <p> The <code><a href="../../../reference/android/view/inputmethod/EditorInfo.html#inputType">inputType</a></code> field is an <code>int</code> that contains bit patterns for various input type settings. To test it for the text field's input type, mask it with the constant <code><a href="../../../reference/android/text/InputType.html#TYPE_MASK_CLASS">TYPE_MASK_CLASS</a></code>, like this: </p> 
 <pre>
inputType &amp; InputType.TYPE_MASK_CLASS 
</pre> 
 <p> The input type bit pattern can have one of several values, including: </p> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_NUMBER">TYPE_CLASS_NUMBER</a></code>
  </dt> 
  <dd>
    A text field for entering numbers. As illustrated in the previous screen shot, the Latin IME displays a number pad for fields of this type. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_DATETIME">TYPE_CLASS_DATETIME</a></code>
  </dt> 
  <dd>
    A text field for entering a date and time. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_PHONE">TYPE_CLASS_PHONE</a></code>
  </dt> 
  <dd>
    A text field for entering telephone numbers. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_TEXT">TYPE_CLASS_TEXT</a></code>
  </dt> 
  <dd>
    A text field for entering all supported characters. 
  </dd> 
 </dl> 
 <p> These constants are described in more detail in the reference documentation for <code><a href="../../../reference/android/text/InputType.html">InputType</a></code>. </p> 
 <p> The <code><a href="../../../reference/android/view/inputmethod/EditorInfo.html#inputType">inputType</a></code> field can contain other bits that indicate a variant of the text field type, such as: </p> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_TEXT_VARIATION_PASSWORD">TYPE_TEXT_VARIATION_PASSWORD</a></code>
  </dt> 
  <dd>
    A variant of 
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_TEXT">TYPE_CLASS_TEXT</a></code> for entering passwords. The input method will display dingbats instead of the actual text. 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_TEXT_VARIATION_URI">TYPE_TEXT_VARIATION_URI</a></code>
  </dt> 
  <dd>
    A variant of 
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_TEXT">TYPE_CLASS_TEXT</a></code> for entering web URLs and other Uniform Resource Identifiers (URIs). 
  </dd> 
  <dt>
   <code><a href="../../../reference/android/text/InputType.html#TYPE_TEXT_FLAG_AUTO_COMPLETE">TYPE_TEXT_FLAG_AUTO_COMPLETE</a></code>
  </dt> 
  <dd>
    A variant of 
   <code><a href="../../../reference/android/text/InputType.html#TYPE_CLASS_TEXT">TYPE_CLASS_TEXT</a></code> for entering text that the application &quot;auto-completes&quot; from a dictionary, search, or other facility. 
  </dd> 
 </dl> 
 <p> Remember to mask <code><a href="../../../reference/android/view/inputmethod/EditorInfo.html#inputType">inputType</a></code> with the appropriate constant when you test for these variants. The available mask constants are listed in the reference documentation for <code><a href="../../../reference/android/text/InputType.html">InputType</a></code>. </p> 
 <p class="caution"> <strong>Caution:</strong> In your own IME, make sure you handle text correctly when you send it to a password field. Hide the password in your UI both in the input view and in the candidates view. Also remember that you shouldn't store passwords on a device. To learn more, see the <a href="../../../guide/practices/security.html">Designing for Security</a> guide. </p> 
 ","EditorInfo","android.view.inputmethod.EditorInfo","class",0
,"Implementing a Spell Checker Service","Spell checker classes","<h3 id="SpellCheckCode">Spell checker classes</h3> 
 <p> Define the service and session object with the following classes: </p> 
 <dl> 
  <dt>
    A subclass of 
   <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html">SpellCheckerService</a></code> 
  </dt> 
  <dd>
    The 
   <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html">SpellCheckerService</a></code> implements both the 
   <code><a href="../../../reference/android/app/Service.html">Service</a></code> class and the spelling checker framework interface. Within your subclass, you must implement the following method: 
   <dl> 
    <dt>
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html#createSession()">createSession()</a></code>
    </dt> 
    <dd>
      A factory method that returns a 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html">SpellCheckerService.Session</a></code> object to a client that wants to do spell checking. 
    </dd> 
   </dl> 
   <p> See the <a href="../../../resources/samples/SpellChecker/SampleSpellCheckerService/index.html"> Spell Checker Service</a> sample app to learn more about implementing this class. </p> 
  </dd> 
  <dt>
    An implementation of 
   <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html">SpellCheckerService.Session</a></code> 
  </dt> 
  <dd>
    An object that the spelling checker service provides to clients, to let them pass text to the spelling checker and receive suggestions. Within this class, you must implement the following methods: 
   <dl> 
    <dt> 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onCreate()">onCreate()</a></code> 
    </dt> 
    <dd>
      Called by the system in response to 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html#createSession()">createSession()</a></code>. In this method, you can initialize the 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html">SpellCheckerService.Session</a></code> object based on the current locale and so forth. 
    </dd> 
    <dt> 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onGetSentenceSuggestionsMultiple(android.view.textservice.TextInfo[], int)">onGetSentenceSuggestionsMultiple()</a></code> 
    </dt> 
    <dd>
      Does the actual spell checking. This method returns an array of 
     <code><a href="../../../reference/android/view/textservice/SentenceSuggestionsInfo.html">SentenceSuggestionsInfo</a></code> containing suggestions for the sentences passed to it. 
    </dd> 
   </dl> 
   <p> Optionally, you can implement <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onCancel()">onCancel()</a></code>, which handles requests to cancel spell checking, <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onGetSuggestions(android.view.textservice.TextInfo, int)">onGetSuggestions()</a></code>, which handles a word suggestion request, or <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onGetSuggestionsMultiple(android.view.textservice.TextInfo[], int, boolean)">onGetSuggestionsMultiple()</a></code>, which handles batches of word suggestion requests. </p> 
   <p> See the <a href="../../../resources/samples/SpellChecker/HelloSpellChecker/index.html"> Spell Checker Client</a> sample app to learn more about implementing this class. </p> 
  </dd> 
 </dl> 
 <p class="note"> <strong>Note:</strong> You must implement all aspects of spell checking as asynchronous and thread-safe. A spelling checker may be called simultaneously by different threads running on different cores. The <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html">SpellCheckerService</a></code> and <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html">SpellCheckerService.Session</a></code> take care of this automatically. </p> 
 ","SentenceSuggestionsInfo","android.view.textservice.SentenceSuggestionsInfo","class",0
,"Implementing a Spell Checker Service","Spell checker classes","<h3 id="SpellCheckCode">Spell checker classes</h3> 
 <p> Define the service and session object with the following classes: </p> 
 <dl> 
  <dt>
    A subclass of 
   <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html">SpellCheckerService</a></code> 
  </dt> 
  <dd>
    The 
   <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html">SpellCheckerService</a></code> implements both the 
   <code><a href="../../../reference/android/app/Service.html">Service</a></code> class and the spelling checker framework interface. Within your subclass, you must implement the following method: 
   <dl> 
    <dt>
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html#createSession()">createSession()</a></code>
    </dt> 
    <dd>
      A factory method that returns a 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html">SpellCheckerService.Session</a></code> object to a client that wants to do spell checking. 
    </dd> 
   </dl> 
   <p> See the <a href="../../../resources/samples/SpellChecker/SampleSpellCheckerService/index.html"> Spell Checker Service</a> sample app to learn more about implementing this class. </p> 
  </dd> 
  <dt>
    An implementation of 
   <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html">SpellCheckerService.Session</a></code> 
  </dt> 
  <dd>
    An object that the spelling checker service provides to clients, to let them pass text to the spelling checker and receive suggestions. Within this class, you must implement the following methods: 
   <dl> 
    <dt> 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onCreate()">onCreate()</a></code> 
    </dt> 
    <dd>
      Called by the system in response to 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html#createSession()">createSession()</a></code>. In this method, you can initialize the 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html">SpellCheckerService.Session</a></code> object based on the current locale and so forth. 
    </dd> 
    <dt> 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onGetSentenceSuggestionsMultiple(android.view.textservice.TextInfo[], int)">onGetSentenceSuggestionsMultiple()</a></code> 
    </dt> 
    <dd>
      Does the actual spell checking. This method returns an array of 
     <code><a href="../../../reference/android/view/textservice/SentenceSuggestionsInfo.html">SentenceSuggestionsInfo</a></code> containing suggestions for the sentences passed to it. 
    </dd> 
   </dl> 
   <p> Optionally, you can implement <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onCancel()">onCancel()</a></code>, which handles requests to cancel spell checking, <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onGetSuggestions(android.view.textservice.TextInfo, int)">onGetSuggestions()</a></code>, which handles a word suggestion request, or <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onGetSuggestionsMultiple(android.view.textservice.TextInfo[], int, boolean)">onGetSuggestionsMultiple()</a></code>, which handles batches of word suggestion requests. </p> 
   <p> See the <a href="../../../resources/samples/SpellChecker/HelloSpellChecker/index.html"> Spell Checker Client</a> sample app to learn more about implementing this class. </p> 
  </dd> 
 </dl> 
 <p class="note"> <strong>Note:</strong> You must implement all aspects of spell checking as asynchronous and thread-safe. A spelling checker may be called simultaneously by different threads running on different cores. The <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html">SpellCheckerService</a></code> and <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html">SpellCheckerService.Session</a></code> take care of this automatically. </p> 
 ","Session","android.service.textservice.SpellCheckerService.Session","class",1
,"Implementing a Spell Checker Service","Spell checker classes","<h3 id="SpellCheckCode">Spell checker classes</h3> 
 <p> Define the service and session object with the following classes: </p> 
 <dl> 
  <dt>
    A subclass of 
   <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html">SpellCheckerService</a></code> 
  </dt> 
  <dd>
    The 
   <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html">SpellCheckerService</a></code> implements both the 
   <code><a href="../../../reference/android/app/Service.html">Service</a></code> class and the spelling checker framework interface. Within your subclass, you must implement the following method: 
   <dl> 
    <dt>
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html#createSession()">createSession()</a></code>
    </dt> 
    <dd>
      A factory method that returns a 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html">SpellCheckerService.Session</a></code> object to a client that wants to do spell checking. 
    </dd> 
   </dl> 
   <p> See the <a href="../../../resources/samples/SpellChecker/SampleSpellCheckerService/index.html"> Spell Checker Service</a> sample app to learn more about implementing this class. </p> 
  </dd> 
  <dt>
    An implementation of 
   <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html">SpellCheckerService.Session</a></code> 
  </dt> 
  <dd>
    An object that the spelling checker service provides to clients, to let them pass text to the spelling checker and receive suggestions. Within this class, you must implement the following methods: 
   <dl> 
    <dt> 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onCreate()">onCreate()</a></code> 
    </dt> 
    <dd>
      Called by the system in response to 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html#createSession()">createSession()</a></code>. In this method, you can initialize the 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html">SpellCheckerService.Session</a></code> object based on the current locale and so forth. 
    </dd> 
    <dt> 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onGetSentenceSuggestionsMultiple(android.view.textservice.TextInfo[], int)">onGetSentenceSuggestionsMultiple()</a></code> 
    </dt> 
    <dd>
      Does the actual spell checking. This method returns an array of 
     <code><a href="../../../reference/android/view/textservice/SentenceSuggestionsInfo.html">SentenceSuggestionsInfo</a></code> containing suggestions for the sentences passed to it. 
    </dd> 
   </dl> 
   <p> Optionally, you can implement <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onCancel()">onCancel()</a></code>, which handles requests to cancel spell checking, <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onGetSuggestions(android.view.textservice.TextInfo, int)">onGetSuggestions()</a></code>, which handles a word suggestion request, or <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onGetSuggestionsMultiple(android.view.textservice.TextInfo[], int, boolean)">onGetSuggestionsMultiple()</a></code>, which handles batches of word suggestion requests. </p> 
   <p> See the <a href="../../../resources/samples/SpellChecker/HelloSpellChecker/index.html"> Spell Checker Client</a> sample app to learn more about implementing this class. </p> 
  </dd> 
 </dl> 
 <p class="note"> <strong>Note:</strong> You must implement all aspects of spell checking as asynchronous and thread-safe. A spelling checker may be called simultaneously by different threads running on different cores. The <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html">SpellCheckerService</a></code> and <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html">SpellCheckerService.Session</a></code> take care of this automatically. </p> 
 ","Service","android.app.Service","class",1
,"Implementing a Spell Checker Service","Spell checker classes","<h3 id="SpellCheckCode">Spell checker classes</h3> 
 <p> Define the service and session object with the following classes: </p> 
 <dl> 
  <dt>
    A subclass of 
   <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html">SpellCheckerService</a></code> 
  </dt> 
  <dd>
    The 
   <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html">SpellCheckerService</a></code> implements both the 
   <code><a href="../../../reference/android/app/Service.html">Service</a></code> class and the spelling checker framework interface. Within your subclass, you must implement the following method: 
   <dl> 
    <dt>
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html#createSession()">createSession()</a></code>
    </dt> 
    <dd>
      A factory method that returns a 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html">SpellCheckerService.Session</a></code> object to a client that wants to do spell checking. 
    </dd> 
   </dl> 
   <p> See the <a href="../../../resources/samples/SpellChecker/SampleSpellCheckerService/index.html"> Spell Checker Service</a> sample app to learn more about implementing this class. </p> 
  </dd> 
  <dt>
    An implementation of 
   <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html">SpellCheckerService.Session</a></code> 
  </dt> 
  <dd>
    An object that the spelling checker service provides to clients, to let them pass text to the spelling checker and receive suggestions. Within this class, you must implement the following methods: 
   <dl> 
    <dt> 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onCreate()">onCreate()</a></code> 
    </dt> 
    <dd>
      Called by the system in response to 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html#createSession()">createSession()</a></code>. In this method, you can initialize the 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html">SpellCheckerService.Session</a></code> object based on the current locale and so forth. 
    </dd> 
    <dt> 
     <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onGetSentenceSuggestionsMultiple(android.view.textservice.TextInfo[], int)">onGetSentenceSuggestionsMultiple()</a></code> 
    </dt> 
    <dd>
      Does the actual spell checking. This method returns an array of 
     <code><a href="../../../reference/android/view/textservice/SentenceSuggestionsInfo.html">SentenceSuggestionsInfo</a></code> containing suggestions for the sentences passed to it. 
    </dd> 
   </dl> 
   <p> Optionally, you can implement <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onCancel()">onCancel()</a></code>, which handles requests to cancel spell checking, <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onGetSuggestions(android.view.textservice.TextInfo, int)">onGetSuggestions()</a></code>, which handles a word suggestion request, or <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html#onGetSuggestionsMultiple(android.view.textservice.TextInfo[], int, boolean)">onGetSuggestionsMultiple()</a></code>, which handles batches of word suggestion requests. </p> 
   <p> See the <a href="../../../resources/samples/SpellChecker/HelloSpellChecker/index.html"> Spell Checker Client</a> sample app to learn more about implementing this class. </p> 
  </dd> 
 </dl> 
 <p class="note"> <strong>Note:</strong> You must implement all aspects of spell checking as asynchronous and thread-safe. A spelling checker may be called simultaneously by different threads running on different cores. The <code><a href="../../../reference/android/service/textservice/SpellCheckerService.html">SpellCheckerService</a></code> and <code><a href="../../../reference/android/service/textservice/SpellCheckerService.Session.html">SpellCheckerService.Session</a></code> take care of this automatically. </p> 
 ","SpellCheckerService","android.service.textservice.SpellCheckerService","class",1
,"Spelling Checker Framework","Accessing the Spell Checker Service from a Client","<h2 id="SpellCheckClient">Accessing the Spell Checker Service from a Client</h2> 
 <p> Applications that use <code><a href="../../../reference/android/widget/TextView.html">TextView</a></code> views automatically benefit from spell checking, because <code><a href="../../../reference/android/widget/TextView.html">TextView</a></code> automatically uses a spelling checker. The following screenshots show this: </p> 
 <img src="../../../resources/articles/images/textview_spellcheck_screenshot_1.png" alt="" height="45" id="figure2a" /> 
 <br /> 
 <img src="../../../resources/articles/images/textview_spellcheck_screenshot_2.png" alt="" height="121" id="figure2b" /> 
 <p class="img-caption"> <strong>Figure 2.</strong> Spell checking in TextView. </p> 
 <p> However, you may want to interact directly with a spelling checker service in other cases as well. The following diagram shows the flow of control for interacting with a spelling checker service: </p> 
 <img src="../../../resources/articles/images/spellcheck_client_flow.png" alt="" height="393" id="figure3" /> 
 <p class="img-caption"> <strong>Figure 3.</strong> Interacting with a spelling checker service. </p> 
 <p> The <a href="../../../resources/samples/SpellChecker/HelloSpellChecker/index.html"> Spell Checker Client</a> sample app shows how to interact with a spelling checker service. The LatinIME input method editor in the Android Open Source Project also contains an example of spell checking. </p> 
</div> 
","TextView","android.widget.TextView","class",0
