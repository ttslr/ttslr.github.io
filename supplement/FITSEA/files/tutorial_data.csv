,"Data Backup","Data Backup","<p>Android's <code><a href="../../../reference/android/app/backup/package-summary.html">backup</a></code> service allows you to copy your persistent application data to remote &quot;cloud&quot; storage, in order to provide a restore point for the application data and settings. If a user performs a factory reset or converts to a new Android-powered device, the system automatically restores your backup data when the application is re-installed. This way, your users don't need to reproduce their previous data or application settings. This process is completely transparent to the user and does not affect the functionality or user experience in your application.</p> 
 <p>During a backup operation (which your application can request), Android's Backup Manager (<code><a href="../../../reference/android/app/backup/BackupManager.html">BackupManager</a></code>) queries your application for backup data, then hands it to a backup transport, which then delivers the data to the cloud storage. During a restore operation, the Backup Manager retrieves the backup data from the backup transport and returns it to your application so your application can restore the data to the device. It's possible for your application to request a restore, but that shouldn't be necessary！Android automatically performs a restore operation when your application is installed and there exists backup data associated with the user. The primary scenario in which backup data is restored is when a user resets their device or upgrades to a new device and their previously installed applications are re-installed.</p> 
 <p class="note"><strong>Note:</strong> The backup service is <em>not</em> designed for synchronizing application data with other clients or saving data that you'd like to access during the normal application lifecycle. You cannot read or write backup data on demand and cannot access it in any way other than through the APIs provided by the Backup Manager.</p> 
 <p>The backup transport is the client-side component of Android's backup framework, which is customizable by the device manufacturer and service provider. The backup transport may differ from device to device and which backup transport is available on any given device is transparent to your application. The Backup Manager APIs isolate your application from the actual backup transport available on a given device！your application communicates with the Backup Manager through a fixed set of APIs, regardless of the underlying transport.</p> 
 <p>Data backup is <em>not</em> guaranteed to be available on all Android-powered devices. However, your application is not adversely affected in the event that a device does not provide a backup transport. If you believe that users will benefit from data backup in your application, then you can implement it as described in this document, test it, then publish your application without any concern about which devices actually perform backup. When your application runs on a device that does not provide a backup transport, your application operates normally, but will not receive callbacks from the Backup Manager to backup data.</p> 
 <p>Although you cannot know what the current transport is, you are always assured that your backup data cannot be read by other applications on the device. Only the Backup Manager and backup transport have access to the data you provide during a backup operation.</p> 
 <p class="caution"><strong>Caution:</strong> Because the cloud storage and transport service can differ from device to device, Android makes no guarantees about the security of your data while using backup. You should always be cautious about using backup to store sensitive data, such as usernames and passwords.</p> 
 ","BackupManager","android.app.backup.BackupManager","class",0
,"Extending BackupAgent","Performing backup","<h3 id="PerformingBackup">Performing backup</h3> 
 <p>When it's time to back up your application data, the Backup Manager calls your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method. This is where you must provide your application data to the Backup Manager so it can be saved to cloud storage.</p> 
 <p>Only the Backup Manager can call your backup agent's <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method. Each time that your application data changes and you want to perform a backup, you must request a backup operation by calling <code><a href="../../../reference/android/app/backup/BackupManager.html#dataChanged()">dataChanged()</a></code> (see <a href="#RequestingBackup">Requesting Backup</a> for more information). A backup request does not result in an immediate call to your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method. Instead, the Backup Manager waits for an appropriate time, then performs backup for all applications that have requested a backup since the last backup was performed.</p> 
 <p class="note"><strong>Tip:</strong> While developing your application, you can initiate an immediate backup operation from the Backup Manager with the <a href="../../../tools/help/bmgr.html"><code>bmgr</code> tool</a>.</p> 
 <p>When the Backup Manager calls your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method, it passes three parameters:</p> 
 <dl> 
  <dt>
   <code>oldState</code>
  </dt> 
  <dd>
   An open, read-only 
   <code><a href="../../../reference/android/os/ParcelFileDescriptor.html">ParcelFileDescriptor</a></code> pointing to the last backup state provided by your application. This is not the backup data from cloud storage, but a local representation of the data that was backed up the last time 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> was called (as defined by 
   <code>newState</code>, below, or from 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>！more about this in the next section). Because 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> does not allow you to read existing backup data in the cloud storage, you can use this local representation to determine whether your data has changed since the last backup.
  </dd> 
  <dt>
   <code>data</code>
  </dt> 
  <dd>
   A 
   <code><a href="../../../reference/android/app/backup/BackupDataOutput.html">BackupDataOutput</a></code> object, which you use to deliver your backup data to the Backup Manager.
  </dd> 
  <dt>
   <code>newState</code>
  </dt> 
  <dd>
   An open, read/write 
   <code><a href="../../../reference/android/os/ParcelFileDescriptor.html">ParcelFileDescriptor</a></code> pointing to a file in which you must write a representation of the data that you delivered to 
   <code>data</code> (a representation can be as simple as the last-modified timestamp for your file). This object is returned as 
   <code>oldState</code> the next time the Backup Manager calls your 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method. If you do not write your backup data to 
   <code>newState</code>, then 
   <code>oldState</code> will point to an empty file next time Backup Manager calls 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code>.
  </dd> 
 </dl> 
 <p>Using these parameters, you should implement your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method to do the following:</p> 
 <ol> 
  <li>Check whether your data has changed since the last backup by comparing <code>oldState</code> to your current data. How you read data in <code>oldState</code> depends on how you originally wrote it to <code>newState</code> (see step 3). The easiest way to record the state of a file is with its last-modified timestamp. For example, here's how you can read and compare a timestamp from <code>oldState</code>: <pre>
// Get the oldState input stream
FileInputStream instream = new FileInputStream(oldState.getFileDescriptor());
DataInputStream in = new DataInputStream(instream);

try {
    // Get the last modified timestamp from the state file and data file
    long stateModified = in.readLong();
    long fileModified = mDataFile.lastModified();

    if (stateModified != fileModified) {
        // The file has been modified, so do a backup
        // Or the time on the device changed, so be safe and do a backup
    } else {
        // Don't back up because the file hasn't changed
        return;
    }
} catch (IOException e) {
    // Unable to read state file... be safe and do a backup
}
</pre> <p>If nothing has changed and you don't need to back up, skip to step 3.</p> </li> 
  <li>If your data has changed, compared to <code>oldState</code>, write the current data to <code>data</code> to back it up to the cloud storage. <p>You must write each chunk of data as an &quot;entity&quot; in the <code><a href="../../../reference/android/app/backup/BackupDataOutput.html">BackupDataOutput</a></code>. An entity is a flattened binary data record that is identified by a unique key string. Thus, the data set that you back up is conceptually a set of key-value pairs.</p> <p>To add an entity to your backup data set, you must:</p> 
   <ol> 
    <li>Call <code><a href="../../../reference/android/app/backup/BackupDataOutput.html#writeEntityHeader(java.lang.String, int)">writeEntityHeader()</a></code>, passing a unique string key for the data you're about to write and the data size.</li> 
    <li>Call <code><a href="../../../reference/android/app/backup/BackupDataOutput.html#writeEntityData(byte[], int)">writeEntityData()</a></code>, passing a byte buffer that contains your data and the number of bytes to write from the buffer (which should match the size passed to <code><a href="../../../reference/android/app/backup/BackupDataOutput.html#writeEntityHeader(java.lang.String, int)">writeEntityHeader()</a></code>).</li> 
   </ol> <p>For example, the following code flattens some data into a byte stream and writes it into a single entity:</p> <pre>
// Create buffer stream and data output stream for our data
ByteArrayOutputStream bufStream = new ByteArrayOutputStream();
DataOutputStream outWriter = new DataOutputStream(bufStream);
// Write structured data
outWriter.writeUTF(mPlayerName);
outWriter.writeInt(mPlayerScore);
// Send the data to the Backup Manager via the BackupDataOutput
byte[] buffer = bufStream.toByteArray();
int len = buffer.length;
data.writeEntityHeader(TOPSCORE_BACKUP_KEY, len);
data.writeEntityData(buffer, len);
</pre> <p>Perform this for each piece of data that you want to back up. How you divide your data into entities is up to you (and you might use just one entity).</p> </li> 
  <li>Whether or not you perform a backup (in step 2), write a representation of the current data to the <code>newState</code> <code><a href="../../../reference/android/os/ParcelFileDescriptor.html">ParcelFileDescriptor</a></code>. The Backup Manager retains this object locally as a representation of the data that is currently backed up. It passes this back to you as <code>oldState</code> the next time it calls <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> so you can determine whether another backup is necessary (as handled in step 1). If you do not write the current data state to this file, then <code>oldState</code> will be empty during the next callback. <p>The following example saves a representation of the current data into <code>newState</code> using the file's last-modified timestamp:</p> <pre>
FileOutputStream outstream = new FileOutputStream(newState.getFileDescriptor());
DataOutputStream out = new DataOutputStream(outstream);

long modified = mDataFile.lastModified();
out.writeLong(modified);
</pre> </li> 
 </ol> 
 <p class="caution"><strong>Caution:</strong> If your application data is saved to a file, make sure that you use synchronized statements while accessing the file so that your backup agent does not read the file while an Activity in your application is also writing the file.</p> 
 ","BackupManager","android.app.backup.BackupManager","class",0
,"Extending BackupAgent","Performing restore","<h3 id="PerformingRestore">Performing restore</h3> 
 <p>When it's time to restore your application data, the Backup Manager calls your backup agent's <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method. When it calls this method, the Backup Manager delivers your backup data so you can restore it onto the device.</p> 
 <p>Only the Backup Manager can call <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>, which happens automatically when the system installs your application and finds existing backup data. However, you can request a restore operation for your application by calling <code><a href="../../../reference/android/app/backup/BackupManager.html#requestRestore(android.app.backup.RestoreObserver)">requestRestore()</a></code> (see <a href="#RequestingRestore">Requesting restore</a> for more information).</p> 
 <p class="note"><strong>Note:</strong> While developing your application, you can also request a restore operation with the <a href="../../../tools/help/bmgr.html"><code>bmgr</code> tool</a>.</p> 
 <p>When the Backup Manager calls your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method, it passes three parameters:</p> 
 <dl> 
  <dt>
   <code>data</code>
  </dt> 
  <dd>
   A 
   <code><a href="../../../reference/android/app/backup/BackupDataInput.html">BackupDataInput</a></code>, which allows you to read your backup data.
  </dd> 
  <dt>
   <code>appVersionCode</code>
  </dt> 
  <dd>
   An integer representing the value of your application's 
   <a href="../../../guide/topics/manifest/manifest-element.html#vcode"><code>android:versionCode</code></a> manifest attribute, as it was when this data was backed up. You can use this to cross-check the current application version and determine if the data format is compatible. For more information about using this to handle different versions of restore data, see the section below about 
   <a href="#RestoreVersion">Checking the Restore Data Version</a>.
  </dd> 
  <dt>
   <code>newState</code>
  </dt> 
  <dd>
   An open, read/write 
   <code><a href="../../../reference/android/os/ParcelFileDescriptor.html">ParcelFileDescriptor</a></code> pointing to a file in which you must write the final backup state that was provided with 
   <code>data</code>. This object is returned as 
   <code>oldState</code> the next time 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> is called. Recall that you must also write the same 
   <code>newState</code> object in the 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> callback！also doing it here ensures that the 
   <code>oldState</code> object given to 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> is valid even the first time 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> is called after the device is restored.
  </dd> 
 </dl> 
 <p>In your implementation of <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>, you should call <code><a href="../../../reference/android/app/backup/BackupDataInput.html#readNextHeader()">readNextHeader()</a></code> on the <code>data</code> to iterate through all entities in the data set. For each entity found, do the following:</p> 
 <ol> 
  <li>Get the entity key with <code><a href="../../../reference/android/app/backup/BackupDataInput.html#getKey()">getKey()</a></code>.</li> 
  <li>Compare the entity key to a list of known key values that you should have declared as static final strings inside your <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code> class. When the key matches one of your known key strings, enter into a statement to extract the entity data and save it to the device: 
   <ol> 
    <li>Get the entity data size with <code><a href="../../../reference/android/app/backup/BackupDataInput.html#getDataSize()">getDataSize()</a></code> and create a byte array of that size.</li> 
    <li>Call <code><a href="../../../reference/android/app/backup/BackupDataInput.html#readEntityData(byte[], int, int)">readEntityData()</a></code> and pass it the byte array, which is where the data will go, and specify the start offset and the size to read.</li> 
    <li>Your byte array is now full and you can read the data and write it to the device however you like.</li> 
   </ol> </li> 
  <li>After you read and write your data back to the device, write the state of your data to the <code>newState</code> parameter the same as you do during <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code>. </li>
 </ol> 
 <p>For example, here's how you can restore the data backed up by the example in the previous section:</p> 
 <pre>
@Override
public void onRestore(BackupDataInput data, int appVersionCode,
                      ParcelFileDescriptor newState) throws IOException {
    // There should be only one entity, but the safest
    // way to consume it is using a while loop
    while (data.readNextHeader()) {
        String key = data.getKey();
        int dataSize = data.getDataSize();

        // If the key is ours (for saving top score). Note this key was used when
        // we wrote the backup entity header
        if (TOPSCORE_BACKUP_KEY.equals(key)) {
            // Create an input stream for the BackupDataInput
            byte[] dataBuf = new byte[dataSize];
            data.readEntityData(dataBuf, 0, dataSize);
            ByteArrayInputStream baStream = new ByteArrayInputStream(dataBuf);
            DataInputStream in = new DataInputStream(baStream);

            // Read the player name and score from the backup data
            mPlayerName = in.readUTF();
            mPlayerScore = in.readInt();

            // Record the score on the device (to a file or something)
            recordScore(mPlayerName, mPlayerScore);
        } else {
            // We don't know this entity key. Skip it. (Shouldn't happen.)
            data.skipEntityData();
        }
    }

    // Finally, write to the state blob (newState) that describes the restored data
    FileOutputStream outstream = new FileOutputStream(newState.getFileDescriptor());
    DataOutputStream out = new DataOutputStream(outstream);
    out.writeUTF(mPlayerName);
    out.writeInt(mPlayerScore);
}
</pre> 
 <p>In this example, the <code>appVersionCode</code> parameter passed to <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> is not used. However, you might want to use it if you've chosen to perform backup when the user's version of the application has actually moved backward (for example, the user went from version 1.5 of your app to 1.0). For more information, see the section about <a href="#RestoreVersion">Checking the Restore Data Version</a>.</p> 
 <div class="special"> 
  <p>For an example implementation of <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code>, see the <a href="../../../resources/samples/BackupRestore/src/com/example/android/backuprestore/ExampleAgent.html"><code>ExampleAgent</code></a> class in the <a href="../../../resources/samples/BackupRestore/index.html">Backup and Restore</a> sample application.</p> 
 </div> 
 ","BackupManager","android.app.backup.BackupManager","class",0
,"Data Backup","Requesting Backup","<h2 id="RequestingBackup">Requesting Backup</h2> 
 <p>You can request a backup operation at any time by calling <code><a href="../../../reference/android/app/backup/BackupManager.html#dataChanged()">dataChanged()</a></code>. This method notifies the Backup Manager that you'd like to backup your data using your backup agent. The Backup Manager then calls your backup agent's <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method at an opportune time in the future. Typically, you should request a backup each time your data changes (such as when the user changes an application preference that you'd like to back up). If you call <code><a href="../../../reference/android/app/backup/BackupManager.html#dataChanged()">dataChanged()</a></code> several times consecutively, before the Backup Manager requests a backup from your agent, your agent still receives just one call to <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code>.</p> 
 <p class="note"><strong>Note:</strong> While developing your application, you can request a backup and initiate an immediate backup operation with the <a href="../../../tools/help/bmgr.html"><code>bmgr</code> tool</a>.</p> 
 ","BackupManager","android.app.backup.BackupManager","class",0
,"Data Backup","Requesting Restore","<h2 id="RequestingRestore">Requesting Restore</h2> 
 <p>During the normal life of your application, you shouldn't need to request a restore operation. They system automatically checks for backup data and performs a restore when your application is installed. However, you can manually request a restore operation by calling <code><a href="../../../reference/android/app/backup/BackupManager.html#requestRestore(android.app.backup.RestoreObserver)">requestRestore()</a></code>, if necessary. In which case, the Backup Manager calls your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> implementation, passing the data from the current set of backup data.</p> 
 <p class="note"><strong>Note:</strong> While developing your application, you can request a restore operation with the <a href="../../../tools/help/bmgr.html"><code>bmgr</code> tool</a>.</p> 
 ","BackupManager","android.app.backup.BackupManager","class",0
,"Data Backup","Testing Your Backup Agent","<h2 id="Testing">Testing Your Backup Agent</h2> 
 <p>Once you've implemented your backup agent, you can test the backup and restore functionality with the following procedure, using <a href="../../../tools/help/bmgr.html"><code>bmgr</code></a>.</p> 
 <ol> 
  <li>Install your application on a suitable Android system image 
   <ul> 
    <li>If using the emulator, create and use an AVD with Android 2.2 (API Level 8).</li> 
    <li>If using a device, the device must be running Android 2.2 or greater and have Google Play built in.</li> 
   </ul> </li> 
  <li>Ensure that backup is enabled 
   <ul> 
    <li>If using the emulator, you can enable backup with the following command from your SDK <code>tools/</code> path: <pre class="no-pretty-print">adb shell bmgr enable true</pre> </li> 
    <li>If using a device, open the system <b>Settings</b>, select <b>Privacy</b>, then enable <b>Back up my data</b> and <b>Automatic restore</b>. </li>
   </ul> </li> 
  <li>Open your application and initialize some data <p>If you've properly implemented backup in your application, then it should request a backup each time the data changes. For example, each time the user changes some data, your app should call <code><a href="../../../reference/android/app/backup/BackupManager.html#dataChanged()">dataChanged()</a></code>, which adds a backup request to the Backup Manager queue. For testing purposes, you can also make a request with the following <code>bmgr</code> command:</p> <pre class="no-pretty-print">adb shell bmgr backup <em>your.package.name</em></pre> </li> 
  <li>Initiate a backup operation: <pre class="no-pretty-print">adb shell bmgr run</pre> <p>This forces the Backup Manager to perform all backup requests that are in its queue.</p> </li>
  <li>Uninstall your application: <pre class="no-pretty-print">adb uninstall <em>your.package.name</em></pre> </li> 
  <li>Re-install your application.</li> 
 </ol> 
 <p>If your backup agent is successful, all the data you initialized in step 4 is restored.</p> 
</div> 
","BackupManager","android.app.backup.BackupManager","class",0
,"Data Backup","Data Backup","<p>Android's <code><a href="../../../reference/android/app/backup/package-summary.html">backup</a></code> service allows you to copy your persistent application data to remote &quot;cloud&quot; storage, in order to provide a restore point for the application data and settings. If a user performs a factory reset or converts to a new Android-powered device, the system automatically restores your backup data when the application is re-installed. This way, your users don't need to reproduce their previous data or application settings. This process is completely transparent to the user and does not affect the functionality or user experience in your application.</p> 
 <p>During a backup operation (which your application can request), Android's Backup Manager (<code><a href="../../../reference/android/app/backup/BackupManager.html">BackupManager</a></code>) queries your application for backup data, then hands it to a backup transport, which then delivers the data to the cloud storage. During a restore operation, the Backup Manager retrieves the backup data from the backup transport and returns it to your application so your application can restore the data to the device. It's possible for your application to request a restore, but that shouldn't be necessary！Android automatically performs a restore operation when your application is installed and there exists backup data associated with the user. The primary scenario in which backup data is restored is when a user resets their device or upgrades to a new device and their previously installed applications are re-installed.</p> 
 <p class="note"><strong>Note:</strong> The backup service is <em>not</em> designed for synchronizing application data with other clients or saving data that you'd like to access during the normal application lifecycle. You cannot read or write backup data on demand and cannot access it in any way other than through the APIs provided by the Backup Manager.</p> 
 <p>The backup transport is the client-side component of Android's backup framework, which is customizable by the device manufacturer and service provider. The backup transport may differ from device to device and which backup transport is available on any given device is transparent to your application. The Backup Manager APIs isolate your application from the actual backup transport available on a given device！your application communicates with the Backup Manager through a fixed set of APIs, regardless of the underlying transport.</p> 
 <p>Data backup is <em>not</em> guaranteed to be available on all Android-powered devices. However, your application is not adversely affected in the event that a device does not provide a backup transport. If you believe that users will benefit from data backup in your application, then you can implement it as described in this document, test it, then publish your application without any concern about which devices actually perform backup. When your application runs on a device that does not provide a backup transport, your application operates normally, but will not receive callbacks from the Backup Manager to backup data.</p> 
 <p>Although you cannot know what the current transport is, you are always assured that your backup data cannot be read by other applications on the device. Only the Backup Manager and backup transport have access to the data you provide during a backup operation.</p> 
 <p class="caution"><strong>Caution:</strong> Because the cloud storage and transport service can differ from device to device, Android makes no guarantees about the security of your data while using backup. You should always be cautious about using backup to store sensitive data, such as usernames and passwords.</p> 
 ","package-summary","android.app.backup.package-summary","class",1
,"Data Backup","The Basics","<h2 id="Basics">The Basics</h2> 
 <p>To backup your application data, you need to implement a backup agent. Your backup agent is called by the Backup Manager to provide the data you want to back up. It is also called to restore your backup data when the application is re-installed. The Backup Manager handles all your data transactions with the cloud storage (using the backup transport) and your backup agent handles all your data transactions on the device.</p> 
 <p>To implement a backup agent, you must:</p> 
 <ol> 
  <li>Declare your backup agent in your manifest file with the <a href="../../../guide/topics/manifest/application-element.html#agent"><code>android:backupAgent</code></a> attribute.</li> 
  <li>Register your application with a backup service. Google offers <a href="http://code.google.com/android/backup/index.html">Android Backup Service</a> as a backup service for most Android-powered devices, which requires that you register your application in order for it to work. Any other backup services available might also require you to register in order to store your data on their servers.</li> 
  <li>Define a backup agent by either:<p></p> 
   <ol type="a"> 
    <li><a href="#BackupAgent">Extending BackupAgent</a> <p>The <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code> class provides the central interface with which your application communicates with the Backup Manager. If you extend this class directly, you must override <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> to handle the backup and restore operations for your data.</p> <p><em>Or</em></p> </li>
    <li><a href="#BackupAgentHelper">Extending BackupAgentHelper</a> <p>The <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> class provides a convenient wrapper around the <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code> class, which minimizes the amount of code you need to write. In your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, you must use one or more &quot;helper&quot; objects, which automatically backup and restore certain types of data, so that you do not need to implement <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>.</p> <p>Android currently provides backup helpers that will backup and restore complete files from <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> and <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>.</p> </li> 
   </ol> </li> 
 </ol> 
 ","SharedPreferences","android.content.SharedPreferences","class",1
,"Data Backup","Extending BackupAgent","<h2 id="BackupAgent">Extending BackupAgent</h2> 
 <p>Most applications shouldn't need to extend the <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code> class directly, but should instead <a href="#BackupAgentHelper">extend BackupAgentHelper</a> to take advantage of the built-in helper classes that automatically backup and restore your files. However, you might want to extend <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code> directly if you need to:</p> 
 <ul> 
  <li>Version your data format. For instance, if you anticipate the need to revise the format in which you write your application data, you can build a backup agent to cross-check your application version during a restore operation and perform any necessary compatibility work if the version on the device is different than that of the backup data. For more information, see <a href="#RestoreVersion">Checking the Restore Data Version</a>.</li> 
  <li>Instead of backing up an entire file, you can specify the portions of data the should be backed up and how each portion is then restored to the device. (This can also help you manage different versions, because you read and write your data as unique entities, rather than complete files.)</li> 
  <li>Back up data in a database. If you have an SQLite database that you want to restore when the user re-installs your application, you need to build a custom <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code> that reads the appropriate data during a backup operation, then create your table and insert the data during a restore operation.</li> 
 </ul> 
 <p>If you don't need to perform any of the tasks above and want to back up complete files from <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> or <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>, you should skip to <a href="#BackupAgentHelper">Extending BackupAgentHelper</a>.</p> 
 ","SharedPreferences","android.content.SharedPreferences","class",0
,"Data Backup","Extending BackupAgentHelper","<h2 id="BackupAgentHelper">Extending BackupAgentHelper</h2> 
 <p>You should build your backup agent using <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> if you want to back up complete files (from either <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> or <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>). Building your backup agent with <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> requires far less code than extending <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code>, because you don't have to implement <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>.</p> 
 <p>Your implementation of <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> must use one or more backup helpers. A backup helper is a specialized component that <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> summons to perform backup and restore operations for a particular type of data. The Android framework currently provides two different helpers:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code> to backup <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> files.</li> 
  <li><code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code> to backup files from <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>.</li> 
 </ul> 
 <p>You can include multiple helpers in your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, but only one helper is needed for each data type. That is, if you have multiple <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> files, then you need only one <code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code>.</p> 
 <p>For each helper you want to add to your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, you must do the following during your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onCreate()">onCreate()</a></code> method:</p> 
 <ol> 
  <li>Instantiate in instance of the desired helper class. In the class constructor, you must specify the appropriate file(s) you want to backup.</li> 
  <li>Call <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html#addHelper(java.lang.String, android.app.backup.BackupHelper)">addHelper()</a></code> to add the helper to your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>.</li> 
 </ol> 
 <p>The following sections describe how to create a backup agent using each of the available helpers.</p> 
 ","SharedPreferences","android.content.SharedPreferences","class",1
,"Extending BackupAgentHelper","Backing up SharedPreferences","<h3 id="SharedPreferences">Backing up SharedPreferences</h3> 
 <p>When you instantiate a <code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code>, you must include the name of one or more <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> files.</p> 
 <p>For example, to back up a <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> file named &quot;user_preferences&quot;, a complete backup agent using <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> looks like this:</p> 
 <pre>
public class MyPrefsBackupAgent extends BackupAgentHelper {
    // The name of the SharedPreferences file
    static final String PREFS = &quot;user_preferences&quot;;

    // A key to uniquely identify the set of backup data
    static final String PREFS_BACKUP_KEY = &quot;prefs&quot;;

    // Allocate a helper and add it to the backup agent
    @Override
    public void onCreate() {
        SharedPreferencesBackupHelper helper = new SharedPreferencesBackupHelper(this, PREFS);
        addHelper(PREFS_BACKUP_KEY, helper);
    }
}
</pre> 
 <p>That's it! That's your entire backup agent. The <code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code> includes all the code needed to backup and restore a <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> file.</p> 
 <p>When the Backup Manager calls <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>, <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> calls your backup helpers to perform backup and restore for your specified files.</p> 
 <p class="note"><strong>Note:</strong> <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> are threadsafe, so you can safely read and write the shared preferences file from your backup agent and other activities.</p> 
 ","SharedPreferences","android.content.SharedPreferences","class",0
,"Storage Options","Using Shared Preferences","<h2 id="pref">Using Shared Preferences</h2> 
 <p>The <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> class provides a general framework that allows you to save and retrieve persistent key-value pairs of primitive data types. You can use <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> to save any primitive data: booleans, floats, ints, longs, and strings. This data will persist across user sessions (even if your application is killed).</p> 
 <div class="sidebox-wrapper"> 
  <div class="sidebox"> 
   ","SharedPreferences","android.content.SharedPreferences","class",1
,"Using Shared Preferences","User Preferences","<h3>User Preferences</h3> 
   <p>Shared preferences are not strictly for saving &quot;user preferences,&quot; such as what ringtone a user has chosen. If you're interested in creating user preferences for your application, see <code><a href="../../../reference/android/preference/PreferenceActivity.html">PreferenceActivity</a></code>, which provides an Activity framework for you to create user preferences, which will be automatically persisted (using shared preferences).</p> 
  </div> 
 </div> 
 <p>To get a <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> object for your application, use one of two methods:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/content/Context.html#getSharedPreferences(java.lang.String, int)">getSharedPreferences()</a></code> - Use this if you need multiple preferences files identified by name, which you specify with the first parameter.</li> 
  <li><code><a href="../../../reference/android/app/Activity.html#getPreferences(int)">getPreferences()</a></code> - Use this if you need only one preferences file for your Activity. Because this will be the only preferences file for your Activity, you don't supply a name.</li> 
 </ul> 
 <p>To write values:</p> 
 <ol> 
  <li>Call <code><a href="../../../reference/android/content/SharedPreferences.html#edit()">edit()</a></code> to get a <code><a href="../../../reference/android/content/SharedPreferences.Editor.html">SharedPreferences.Editor</a></code>.</li> 
  <li>Add values with methods such as <code><a href="../../../reference/android/content/SharedPreferences.Editor.html#putBoolean(java.lang.String, boolean)">putBoolean()</a></code> and <code><a href="../../../reference/android/content/SharedPreferences.Editor.html#putString(java.lang.String, java.lang.String)">putString()</a></code>.</li> 
  <li>Commit the new values with <code><a href="../../../reference/android/content/SharedPreferences.Editor.html#commit()">commit()</a></code></li> 
 </ol> 
 <p>To read values, use <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> methods such as <code><a href="../../../reference/android/content/SharedPreferences.html#getBoolean(java.lang.String, boolean)">getBoolean()</a></code> and <code><a href="../../../reference/android/content/SharedPreferences.html#getString(java.lang.String, java.lang.String)">getString()</a></code>.</p> 
 <p> Here is an example that saves a preference for silent keypress mode in a calculator: </p> 
 <pre>
public class Calc extends Activity {
    public static final String PREFS_NAME = &quot;MyPrefsFile&quot;;

    @Override
    protected void onCreate(Bundle state){
       super.onCreate(state);
       . . .

       // Restore preferences
       SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
       boolean silent = settings.getBoolean(&quot;silentMode&quot;, false);
       setSilent(silent);
    }

    @Override
    protected void onStop(){
       super.onStop();

      // We need an Editor object to make preference changes.
      // All objects are from android.context.Context
      SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
      SharedPreferences.Editor editor = settings.edit();
      editor.putBoolean(&quot;silentMode&quot;, mSilentMode);

      // Commit the edits!
      editor.commit();
    }
}
</pre> 
 <a name="files"></a> 
 ","SharedPreferences","android.content.SharedPreferences","class",1
,"Data Backup","The Basics","<h2 id="Basics">The Basics</h2> 
 <p>To backup your application data, you need to implement a backup agent. Your backup agent is called by the Backup Manager to provide the data you want to back up. It is also called to restore your backup data when the application is re-installed. The Backup Manager handles all your data transactions with the cloud storage (using the backup transport) and your backup agent handles all your data transactions on the device.</p> 
 <p>To implement a backup agent, you must:</p> 
 <ol> 
  <li>Declare your backup agent in your manifest file with the <a href="../../../guide/topics/manifest/application-element.html#agent"><code>android:backupAgent</code></a> attribute.</li> 
  <li>Register your application with a backup service. Google offers <a href="http://code.google.com/android/backup/index.html">Android Backup Service</a> as a backup service for most Android-powered devices, which requires that you register your application in order for it to work. Any other backup services available might also require you to register in order to store your data on their servers.</li> 
  <li>Define a backup agent by either:<p></p> 
   <ol type="a"> 
    <li><a href="#BackupAgent">Extending BackupAgent</a> <p>The <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code> class provides the central interface with which your application communicates with the Backup Manager. If you extend this class directly, you must override <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> to handle the backup and restore operations for your data.</p> <p><em>Or</em></p> </li>
    <li><a href="#BackupAgentHelper">Extending BackupAgentHelper</a> <p>The <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> class provides a convenient wrapper around the <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code> class, which minimizes the amount of code you need to write. In your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, you must use one or more &quot;helper&quot; objects, which automatically backup and restore certain types of data, so that you do not need to implement <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>.</p> <p>Android currently provides backup helpers that will backup and restore complete files from <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> and <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>.</p> </li> 
   </ol> </li> 
 </ol> 
 ","BackupAgentHelper","android.app.backup.BackupAgentHelper","class",1
,"Data Backup","Extending BackupAgentHelper","<h2 id="BackupAgentHelper">Extending BackupAgentHelper</h2> 
 <p>You should build your backup agent using <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> if you want to back up complete files (from either <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> or <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>). Building your backup agent with <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> requires far less code than extending <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code>, because you don't have to implement <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>.</p> 
 <p>Your implementation of <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> must use one or more backup helpers. A backup helper is a specialized component that <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> summons to perform backup and restore operations for a particular type of data. The Android framework currently provides two different helpers:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code> to backup <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> files.</li> 
  <li><code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code> to backup files from <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>.</li> 
 </ul> 
 <p>You can include multiple helpers in your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, but only one helper is needed for each data type. That is, if you have multiple <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> files, then you need only one <code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code>.</p> 
 <p>For each helper you want to add to your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, you must do the following during your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onCreate()">onCreate()</a></code> method:</p> 
 <ol> 
  <li>Instantiate in instance of the desired helper class. In the class constructor, you must specify the appropriate file(s) you want to backup.</li> 
  <li>Call <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html#addHelper(java.lang.String, android.app.backup.BackupHelper)">addHelper()</a></code> to add the helper to your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>.</li> 
 </ol> 
 <p>The following sections describe how to create a backup agent using each of the available helpers.</p> 
 ","BackupAgentHelper","android.app.backup.BackupAgentHelper","class",0
,"Extending BackupAgentHelper","Backing up SharedPreferences","<h3 id="SharedPreferences">Backing up SharedPreferences</h3> 
 <p>When you instantiate a <code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code>, you must include the name of one or more <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> files.</p> 
 <p>For example, to back up a <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> file named &quot;user_preferences&quot;, a complete backup agent using <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> looks like this:</p> 
 <pre>
public class MyPrefsBackupAgent extends BackupAgentHelper {
    // The name of the SharedPreferences file
    static final String PREFS = &quot;user_preferences&quot;;

    // A key to uniquely identify the set of backup data
    static final String PREFS_BACKUP_KEY = &quot;prefs&quot;;

    // Allocate a helper and add it to the backup agent
    @Override
    public void onCreate() {
        SharedPreferencesBackupHelper helper = new SharedPreferencesBackupHelper(this, PREFS);
        addHelper(PREFS_BACKUP_KEY, helper);
    }
}
</pre> 
 <p>That's it! That's your entire backup agent. The <code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code> includes all the code needed to backup and restore a <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> file.</p> 
 <p>When the Backup Manager calls <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>, <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> calls your backup helpers to perform backup and restore for your specified files.</p> 
 <p class="note"><strong>Note:</strong> <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> are threadsafe, so you can safely read and write the shared preferences file from your backup agent and other activities.</p> 
 ","BackupAgentHelper","android.app.backup.BackupAgentHelper","class",1
,"Extending BackupAgentHelper","Backing up other files","<h3 id="Files">Backing up other files</h3> 
 <p>When you instantiate a <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code>, you must include the name of one or more files that are saved to your application's <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a> (as specified by <code><a href="../../../reference/android/content/ContextWrapper.html#getFilesDir()">getFilesDir()</a></code>, which is the same location where <code><a href="../../../reference/android/content/Context.html#openFileOutput(java.lang.String, int)">openFileOutput()</a></code> writes files).</p> 
 <p>For example, to backup two files named &quot;scores&quot; and &quot;stats,&quot; a backup agent using <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> looks like this:</p> 
 <pre>
public class MyFileBackupAgent extends BackupAgentHelper {
    // The name of the file
    static final String TOP_SCORES = &quot;scores&quot;;
    static final String PLAYER_STATS = &quot;stats&quot;;

    // A key to uniquely identify the set of backup data
    static final String FILES_BACKUP_KEY = &quot;myfiles&quot;;

    // Allocate a helper and add it to the backup agent
    void onCreate() {
        FileBackupHelper helper = new FileBackupHelper(this, TOP_SCORES, PLAYER_STATS);
        addHelper(FILES_BACKUP_KEY, helper);
    }
}
</pre> 
 <p>The <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code> includes all the code necessary to backup and restore files that are saved to your application's <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>..</p> 
 <p>However, reading and writing to files on internal storage is <strong>not threadsafe</strong>. To ensure that your backup agent does not read or write your files at the same time as your activities, you must use synchronized statements each time you perform a read or write. For example, in any Activity where you read and write the file, you need an object to use as the intrinsic lock for the synchronized statements:</p> 
 <pre>
// Object for intrinsic lock
static final Object sDataLock = new Object();
</pre> 
 <p>Then create a synchronized statement with this lock each time you read or write the files. For example, here's a synchronized statement for writing the latest score in a game to a file:</p> 
 <pre>
try {
    synchronized (MyActivity.sDataLock) {
        File dataFile = new File(<code><a href="../../../reference/android/content/Context.html#getFilesDir()">getFilesDir()</a></code>, TOP_SCORES);
        RandomAccessFile raFile = new RandomAccessFile(dataFile, &quot;rw&quot;);
        raFile.writeInt(score);
    }
} catch (IOException e) {
    Log.e(TAG, &quot;Unable to write to file&quot;);
}
</pre> 
 <p>You should synchronize your read statements with the same lock.</p> 
 <p>Then, in your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, you must override <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> to synchronize the backup and restore operations with the same intrinsic lock. For example, the <code>MyFileBackupAgent</code> example from above needs the following methods:</p> 
 <pre>
@Override
public void onBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
          ParcelFileDescriptor newState) throws IOException {
    // Hold the lock while the FileBackupHelper performs backup
    synchronized (MyActivity.sDataLock) {
        super.onBackup(oldState, data, newState);
    }
}

@Override
public void onRestore(BackupDataInput data, int appVersionCode,
        ParcelFileDescriptor newState) throws IOException {
    // Hold the lock while the FileBackupHelper restores the file
    synchronized (MyActivity.sDataLock) {
        super.onRestore(data, appVersionCode, newState);
    }
}
</pre> 
 <p>That's it. All you need to do is add your <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code> in the <code><a href="../../../reference/android/app/backup/BackupAgent.html#onCreate()">onCreate()</a></code> method and override <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> to synchronize read and write operations.</p> 
 <div class="special"> 
  <p>For an example implementation of <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> with <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code>, see the <code>FileHelperExampleAgent</code> class in the <a href="../../../resources/samples/BackupRestore/index.html">Backup and Restore</a> sample application.</p> 
 </div> 
 ","BackupAgentHelper","android.app.backup.BackupAgentHelper","class",1
,"Data Backup","The Basics","<h2 id="Basics">The Basics</h2> 
 <p>To backup your application data, you need to implement a backup agent. Your backup agent is called by the Backup Manager to provide the data you want to back up. It is also called to restore your backup data when the application is re-installed. The Backup Manager handles all your data transactions with the cloud storage (using the backup transport) and your backup agent handles all your data transactions on the device.</p> 
 <p>To implement a backup agent, you must:</p> 
 <ol> 
  <li>Declare your backup agent in your manifest file with the <a href="../../../guide/topics/manifest/application-element.html#agent"><code>android:backupAgent</code></a> attribute.</li> 
  <li>Register your application with a backup service. Google offers <a href="http://code.google.com/android/backup/index.html">Android Backup Service</a> as a backup service for most Android-powered devices, which requires that you register your application in order for it to work. Any other backup services available might also require you to register in order to store your data on their servers.</li> 
  <li>Define a backup agent by either:<p></p> 
   <ol type="a"> 
    <li><a href="#BackupAgent">Extending BackupAgent</a> <p>The <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code> class provides the central interface with which your application communicates with the Backup Manager. If you extend this class directly, you must override <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> to handle the backup and restore operations for your data.</p> <p><em>Or</em></p> </li>
    <li><a href="#BackupAgentHelper">Extending BackupAgentHelper</a> <p>The <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> class provides a convenient wrapper around the <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code> class, which minimizes the amount of code you need to write. In your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, you must use one or more &quot;helper&quot; objects, which automatically backup and restore certain types of data, so that you do not need to implement <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>.</p> <p>Android currently provides backup helpers that will backup and restore complete files from <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> and <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>.</p> </li> 
   </ol> </li> 
 </ol> 
 ","BackupAgent","android.app.backup.BackupAgent","class",1
,"Data Backup","Extending BackupAgent","<h2 id="BackupAgent">Extending BackupAgent</h2> 
 <p>Most applications shouldn't need to extend the <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code> class directly, but should instead <a href="#BackupAgentHelper">extend BackupAgentHelper</a> to take advantage of the built-in helper classes that automatically backup and restore your files. However, you might want to extend <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code> directly if you need to:</p> 
 <ul> 
  <li>Version your data format. For instance, if you anticipate the need to revise the format in which you write your application data, you can build a backup agent to cross-check your application version during a restore operation and perform any necessary compatibility work if the version on the device is different than that of the backup data. For more information, see <a href="#RestoreVersion">Checking the Restore Data Version</a>.</li> 
  <li>Instead of backing up an entire file, you can specify the portions of data the should be backed up and how each portion is then restored to the device. (This can also help you manage different versions, because you read and write your data as unique entities, rather than complete files.)</li> 
  <li>Back up data in a database. If you have an SQLite database that you want to restore when the user re-installs your application, you need to build a custom <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code> that reads the appropriate data during a backup operation, then create your table and insert the data during a restore operation.</li> 
 </ul> 
 <p>If you don't need to perform any of the tasks above and want to back up complete files from <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> or <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>, you should skip to <a href="#BackupAgentHelper">Extending BackupAgentHelper</a>.</p> 
 ","BackupAgent","android.app.backup.BackupAgent","class",1
,"Extending BackupAgent","Required Methods","<h3 id="RequiredMethods">Required Methods</h3> 
 <p>When you create a backup agent by extending <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code>, you must implement the following callback methods:</p> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code>
  </dt> 
  <dd>
   The Backup Manager calls this method after you 
   <a href="#RequestingBackup">request a backup</a>. In this method, you read your application data from the device and pass the data you want to back up to the Backup Manager, as described below in 
   <a href="#PerformingBackup">Performing backup</a>.
  </dd> 
  <dt>
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>
  </dt> 
  <dd>
   The Backup Manager calls this method during a restore operation (you can 
   <a href="#RequestingRestore">request a restore</a>, but the system automatically performs restore when the user re-installs your application). When it calls this method, the Backup Manager delivers your backup data, which you then restore to the device, as described below in 
   <a href="#PerformingRestore">Performing restore</a>.
  </dd> 
 </dl> 
 ","BackupAgent","android.app.backup.BackupAgent","class",1
,"Extending BackupAgent","Performing backup","<h3 id="PerformingBackup">Performing backup</h3> 
 <p>When it's time to back up your application data, the Backup Manager calls your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method. This is where you must provide your application data to the Backup Manager so it can be saved to cloud storage.</p> 
 <p>Only the Backup Manager can call your backup agent's <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method. Each time that your application data changes and you want to perform a backup, you must request a backup operation by calling <code><a href="../../../reference/android/app/backup/BackupManager.html#dataChanged()">dataChanged()</a></code> (see <a href="#RequestingBackup">Requesting Backup</a> for more information). A backup request does not result in an immediate call to your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method. Instead, the Backup Manager waits for an appropriate time, then performs backup for all applications that have requested a backup since the last backup was performed.</p> 
 <p class="note"><strong>Tip:</strong> While developing your application, you can initiate an immediate backup operation from the Backup Manager with the <a href="../../../tools/help/bmgr.html"><code>bmgr</code> tool</a>.</p> 
 <p>When the Backup Manager calls your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method, it passes three parameters:</p> 
 <dl> 
  <dt>
   <code>oldState</code>
  </dt> 
  <dd>
   An open, read-only 
   <code><a href="../../../reference/android/os/ParcelFileDescriptor.html">ParcelFileDescriptor</a></code> pointing to the last backup state provided by your application. This is not the backup data from cloud storage, but a local representation of the data that was backed up the last time 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> was called (as defined by 
   <code>newState</code>, below, or from 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>！more about this in the next section). Because 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> does not allow you to read existing backup data in the cloud storage, you can use this local representation to determine whether your data has changed since the last backup.
  </dd> 
  <dt>
   <code>data</code>
  </dt> 
  <dd>
   A 
   <code><a href="../../../reference/android/app/backup/BackupDataOutput.html">BackupDataOutput</a></code> object, which you use to deliver your backup data to the Backup Manager.
  </dd> 
  <dt>
   <code>newState</code>
  </dt> 
  <dd>
   An open, read/write 
   <code><a href="../../../reference/android/os/ParcelFileDescriptor.html">ParcelFileDescriptor</a></code> pointing to a file in which you must write a representation of the data that you delivered to 
   <code>data</code> (a representation can be as simple as the last-modified timestamp for your file). This object is returned as 
   <code>oldState</code> the next time the Backup Manager calls your 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method. If you do not write your backup data to 
   <code>newState</code>, then 
   <code>oldState</code> will point to an empty file next time Backup Manager calls 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code>.
  </dd> 
 </dl> 
 <p>Using these parameters, you should implement your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method to do the following:</p> 
 <ol> 
  <li>Check whether your data has changed since the last backup by comparing <code>oldState</code> to your current data. How you read data in <code>oldState</code> depends on how you originally wrote it to <code>newState</code> (see step 3). The easiest way to record the state of a file is with its last-modified timestamp. For example, here's how you can read and compare a timestamp from <code>oldState</code>: <pre>
// Get the oldState input stream
FileInputStream instream = new FileInputStream(oldState.getFileDescriptor());
DataInputStream in = new DataInputStream(instream);

try {
    // Get the last modified timestamp from the state file and data file
    long stateModified = in.readLong();
    long fileModified = mDataFile.lastModified();

    if (stateModified != fileModified) {
        // The file has been modified, so do a backup
        // Or the time on the device changed, so be safe and do a backup
    } else {
        // Don't back up because the file hasn't changed
        return;
    }
} catch (IOException e) {
    // Unable to read state file... be safe and do a backup
}
</pre> <p>If nothing has changed and you don't need to back up, skip to step 3.</p> </li> 
  <li>If your data has changed, compared to <code>oldState</code>, write the current data to <code>data</code> to back it up to the cloud storage. <p>You must write each chunk of data as an &quot;entity&quot; in the <code><a href="../../../reference/android/app/backup/BackupDataOutput.html">BackupDataOutput</a></code>. An entity is a flattened binary data record that is identified by a unique key string. Thus, the data set that you back up is conceptually a set of key-value pairs.</p> <p>To add an entity to your backup data set, you must:</p> 
   <ol> 
    <li>Call <code><a href="../../../reference/android/app/backup/BackupDataOutput.html#writeEntityHeader(java.lang.String, int)">writeEntityHeader()</a></code>, passing a unique string key for the data you're about to write and the data size.</li> 
    <li>Call <code><a href="../../../reference/android/app/backup/BackupDataOutput.html#writeEntityData(byte[], int)">writeEntityData()</a></code>, passing a byte buffer that contains your data and the number of bytes to write from the buffer (which should match the size passed to <code><a href="../../../reference/android/app/backup/BackupDataOutput.html#writeEntityHeader(java.lang.String, int)">writeEntityHeader()</a></code>).</li> 
   </ol> <p>For example, the following code flattens some data into a byte stream and writes it into a single entity:</p> <pre>
// Create buffer stream and data output stream for our data
ByteArrayOutputStream bufStream = new ByteArrayOutputStream();
DataOutputStream outWriter = new DataOutputStream(bufStream);
// Write structured data
outWriter.writeUTF(mPlayerName);
outWriter.writeInt(mPlayerScore);
// Send the data to the Backup Manager via the BackupDataOutput
byte[] buffer = bufStream.toByteArray();
int len = buffer.length;
data.writeEntityHeader(TOPSCORE_BACKUP_KEY, len);
data.writeEntityData(buffer, len);
</pre> <p>Perform this for each piece of data that you want to back up. How you divide your data into entities is up to you (and you might use just one entity).</p> </li> 
  <li>Whether or not you perform a backup (in step 2), write a representation of the current data to the <code>newState</code> <code><a href="../../../reference/android/os/ParcelFileDescriptor.html">ParcelFileDescriptor</a></code>. The Backup Manager retains this object locally as a representation of the data that is currently backed up. It passes this back to you as <code>oldState</code> the next time it calls <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> so you can determine whether another backup is necessary (as handled in step 1). If you do not write the current data state to this file, then <code>oldState</code> will be empty during the next callback. <p>The following example saves a representation of the current data into <code>newState</code> using the file's last-modified timestamp:</p> <pre>
FileOutputStream outstream = new FileOutputStream(newState.getFileDescriptor());
DataOutputStream out = new DataOutputStream(outstream);

long modified = mDataFile.lastModified();
out.writeLong(modified);
</pre> </li> 
 </ol> 
 <p class="caution"><strong>Caution:</strong> If your application data is saved to a file, make sure that you use synchronized statements while accessing the file so that your backup agent does not read the file while an Activity in your application is also writing the file.</p> 
 ","BackupAgent","android.app.backup.BackupAgent","class",0
,"Extending BackupAgent","Performing restore","<h3 id="PerformingRestore">Performing restore</h3> 
 <p>When it's time to restore your application data, the Backup Manager calls your backup agent's <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method. When it calls this method, the Backup Manager delivers your backup data so you can restore it onto the device.</p> 
 <p>Only the Backup Manager can call <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>, which happens automatically when the system installs your application and finds existing backup data. However, you can request a restore operation for your application by calling <code><a href="../../../reference/android/app/backup/BackupManager.html#requestRestore(android.app.backup.RestoreObserver)">requestRestore()</a></code> (see <a href="#RequestingRestore">Requesting restore</a> for more information).</p> 
 <p class="note"><strong>Note:</strong> While developing your application, you can also request a restore operation with the <a href="../../../tools/help/bmgr.html"><code>bmgr</code> tool</a>.</p> 
 <p>When the Backup Manager calls your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method, it passes three parameters:</p> 
 <dl> 
  <dt>
   <code>data</code>
  </dt> 
  <dd>
   A 
   <code><a href="../../../reference/android/app/backup/BackupDataInput.html">BackupDataInput</a></code>, which allows you to read your backup data.
  </dd> 
  <dt>
   <code>appVersionCode</code>
  </dt> 
  <dd>
   An integer representing the value of your application's 
   <a href="../../../guide/topics/manifest/manifest-element.html#vcode"><code>android:versionCode</code></a> manifest attribute, as it was when this data was backed up. You can use this to cross-check the current application version and determine if the data format is compatible. For more information about using this to handle different versions of restore data, see the section below about 
   <a href="#RestoreVersion">Checking the Restore Data Version</a>.
  </dd> 
  <dt>
   <code>newState</code>
  </dt> 
  <dd>
   An open, read/write 
   <code><a href="../../../reference/android/os/ParcelFileDescriptor.html">ParcelFileDescriptor</a></code> pointing to a file in which you must write the final backup state that was provided with 
   <code>data</code>. This object is returned as 
   <code>oldState</code> the next time 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> is called. Recall that you must also write the same 
   <code>newState</code> object in the 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> callback！also doing it here ensures that the 
   <code>oldState</code> object given to 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> is valid even the first time 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> is called after the device is restored.
  </dd> 
 </dl> 
 <p>In your implementation of <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>, you should call <code><a href="../../../reference/android/app/backup/BackupDataInput.html#readNextHeader()">readNextHeader()</a></code> on the <code>data</code> to iterate through all entities in the data set. For each entity found, do the following:</p> 
 <ol> 
  <li>Get the entity key with <code><a href="../../../reference/android/app/backup/BackupDataInput.html#getKey()">getKey()</a></code>.</li> 
  <li>Compare the entity key to a list of known key values that you should have declared as static final strings inside your <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code> class. When the key matches one of your known key strings, enter into a statement to extract the entity data and save it to the device: 
   <ol> 
    <li>Get the entity data size with <code><a href="../../../reference/android/app/backup/BackupDataInput.html#getDataSize()">getDataSize()</a></code> and create a byte array of that size.</li> 
    <li>Call <code><a href="../../../reference/android/app/backup/BackupDataInput.html#readEntityData(byte[], int, int)">readEntityData()</a></code> and pass it the byte array, which is where the data will go, and specify the start offset and the size to read.</li> 
    <li>Your byte array is now full and you can read the data and write it to the device however you like.</li> 
   </ol> </li> 
  <li>After you read and write your data back to the device, write the state of your data to the <code>newState</code> parameter the same as you do during <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code>. </li>
 </ol> 
 <p>For example, here's how you can restore the data backed up by the example in the previous section:</p> 
 <pre>
@Override
public void onRestore(BackupDataInput data, int appVersionCode,
                      ParcelFileDescriptor newState) throws IOException {
    // There should be only one entity, but the safest
    // way to consume it is using a while loop
    while (data.readNextHeader()) {
        String key = data.getKey();
        int dataSize = data.getDataSize();

        // If the key is ours (for saving top score). Note this key was used when
        // we wrote the backup entity header
        if (TOPSCORE_BACKUP_KEY.equals(key)) {
            // Create an input stream for the BackupDataInput
            byte[] dataBuf = new byte[dataSize];
            data.readEntityData(dataBuf, 0, dataSize);
            ByteArrayInputStream baStream = new ByteArrayInputStream(dataBuf);
            DataInputStream in = new DataInputStream(baStream);

            // Read the player name and score from the backup data
            mPlayerName = in.readUTF();
            mPlayerScore = in.readInt();

            // Record the score on the device (to a file or something)
            recordScore(mPlayerName, mPlayerScore);
        } else {
            // We don't know this entity key. Skip it. (Shouldn't happen.)
            data.skipEntityData();
        }
    }

    // Finally, write to the state blob (newState) that describes the restored data
    FileOutputStream outstream = new FileOutputStream(newState.getFileDescriptor());
    DataOutputStream out = new DataOutputStream(outstream);
    out.writeUTF(mPlayerName);
    out.writeInt(mPlayerScore);
}
</pre> 
 <p>In this example, the <code>appVersionCode</code> parameter passed to <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> is not used. However, you might want to use it if you've chosen to perform backup when the user's version of the application has actually moved backward (for example, the user went from version 1.5 of your app to 1.0). For more information, see the section about <a href="#RestoreVersion">Checking the Restore Data Version</a>.</p> 
 <div class="special"> 
  <p>For an example implementation of <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code>, see the <a href="../../../resources/samples/BackupRestore/src/com/example/android/backuprestore/ExampleAgent.html"><code>ExampleAgent</code></a> class in the <a href="../../../resources/samples/BackupRestore/index.html">Backup and Restore</a> sample application.</p> 
 </div> 
 ","BackupAgent","android.app.backup.BackupAgent","class",0
,"Data Backup","Extending BackupAgentHelper","<h2 id="BackupAgentHelper">Extending BackupAgentHelper</h2> 
 <p>You should build your backup agent using <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> if you want to back up complete files (from either <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> or <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>). Building your backup agent with <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> requires far less code than extending <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code>, because you don't have to implement <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>.</p> 
 <p>Your implementation of <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> must use one or more backup helpers. A backup helper is a specialized component that <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> summons to perform backup and restore operations for a particular type of data. The Android framework currently provides two different helpers:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code> to backup <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> files.</li> 
  <li><code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code> to backup files from <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>.</li> 
 </ul> 
 <p>You can include multiple helpers in your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, but only one helper is needed for each data type. That is, if you have multiple <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> files, then you need only one <code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code>.</p> 
 <p>For each helper you want to add to your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, you must do the following during your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onCreate()">onCreate()</a></code> method:</p> 
 <ol> 
  <li>Instantiate in instance of the desired helper class. In the class constructor, you must specify the appropriate file(s) you want to backup.</li> 
  <li>Call <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html#addHelper(java.lang.String, android.app.backup.BackupHelper)">addHelper()</a></code> to add the helper to your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>.</li> 
 </ol> 
 <p>The following sections describe how to create a backup agent using each of the available helpers.</p> 
 ","BackupAgent","android.app.backup.BackupAgent","class",0
,"Extending BackupAgentHelper","Backing up SharedPreferences","<h3 id="SharedPreferences">Backing up SharedPreferences</h3> 
 <p>When you instantiate a <code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code>, you must include the name of one or more <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> files.</p> 
 <p>For example, to back up a <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> file named &quot;user_preferences&quot;, a complete backup agent using <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> looks like this:</p> 
 <pre>
public class MyPrefsBackupAgent extends BackupAgentHelper {
    // The name of the SharedPreferences file
    static final String PREFS = &quot;user_preferences&quot;;

    // A key to uniquely identify the set of backup data
    static final String PREFS_BACKUP_KEY = &quot;prefs&quot;;

    // Allocate a helper and add it to the backup agent
    @Override
    public void onCreate() {
        SharedPreferencesBackupHelper helper = new SharedPreferencesBackupHelper(this, PREFS);
        addHelper(PREFS_BACKUP_KEY, helper);
    }
}
</pre> 
 <p>That's it! That's your entire backup agent. The <code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code> includes all the code needed to backup and restore a <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> file.</p> 
 <p>When the Backup Manager calls <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>, <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> calls your backup helpers to perform backup and restore for your specified files.</p> 
 <p class="note"><strong>Note:</strong> <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> are threadsafe, so you can safely read and write the shared preferences file from your backup agent and other activities.</p> 
 ","BackupAgent","android.app.backup.BackupAgent","class",0
,"Extending BackupAgentHelper","Backing up other files","<h3 id="Files">Backing up other files</h3> 
 <p>When you instantiate a <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code>, you must include the name of one or more files that are saved to your application's <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a> (as specified by <code><a href="../../../reference/android/content/ContextWrapper.html#getFilesDir()">getFilesDir()</a></code>, which is the same location where <code><a href="../../../reference/android/content/Context.html#openFileOutput(java.lang.String, int)">openFileOutput()</a></code> writes files).</p> 
 <p>For example, to backup two files named &quot;scores&quot; and &quot;stats,&quot; a backup agent using <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> looks like this:</p> 
 <pre>
public class MyFileBackupAgent extends BackupAgentHelper {
    // The name of the file
    static final String TOP_SCORES = &quot;scores&quot;;
    static final String PLAYER_STATS = &quot;stats&quot;;

    // A key to uniquely identify the set of backup data
    static final String FILES_BACKUP_KEY = &quot;myfiles&quot;;

    // Allocate a helper and add it to the backup agent
    void onCreate() {
        FileBackupHelper helper = new FileBackupHelper(this, TOP_SCORES, PLAYER_STATS);
        addHelper(FILES_BACKUP_KEY, helper);
    }
}
</pre> 
 <p>The <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code> includes all the code necessary to backup and restore files that are saved to your application's <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>..</p> 
 <p>However, reading and writing to files on internal storage is <strong>not threadsafe</strong>. To ensure that your backup agent does not read or write your files at the same time as your activities, you must use synchronized statements each time you perform a read or write. For example, in any Activity where you read and write the file, you need an object to use as the intrinsic lock for the synchronized statements:</p> 
 <pre>
// Object for intrinsic lock
static final Object sDataLock = new Object();
</pre> 
 <p>Then create a synchronized statement with this lock each time you read or write the files. For example, here's a synchronized statement for writing the latest score in a game to a file:</p> 
 <pre>
try {
    synchronized (MyActivity.sDataLock) {
        File dataFile = new File(<code><a href="../../../reference/android/content/Context.html#getFilesDir()">getFilesDir()</a></code>, TOP_SCORES);
        RandomAccessFile raFile = new RandomAccessFile(dataFile, &quot;rw&quot;);
        raFile.writeInt(score);
    }
} catch (IOException e) {
    Log.e(TAG, &quot;Unable to write to file&quot;);
}
</pre> 
 <p>You should synchronize your read statements with the same lock.</p> 
 <p>Then, in your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, you must override <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> to synchronize the backup and restore operations with the same intrinsic lock. For example, the <code>MyFileBackupAgent</code> example from above needs the following methods:</p> 
 <pre>
@Override
public void onBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
          ParcelFileDescriptor newState) throws IOException {
    // Hold the lock while the FileBackupHelper performs backup
    synchronized (MyActivity.sDataLock) {
        super.onBackup(oldState, data, newState);
    }
}

@Override
public void onRestore(BackupDataInput data, int appVersionCode,
        ParcelFileDescriptor newState) throws IOException {
    // Hold the lock while the FileBackupHelper restores the file
    synchronized (MyActivity.sDataLock) {
        super.onRestore(data, appVersionCode, newState);
    }
}
</pre> 
 <p>That's it. All you need to do is add your <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code> in the <code><a href="../../../reference/android/app/backup/BackupAgent.html#onCreate()">onCreate()</a></code> method and override <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> to synchronize read and write operations.</p> 
 <div class="special"> 
  <p>For an example implementation of <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> with <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code>, see the <code>FileHelperExampleAgent</code> class in the <a href="../../../resources/samples/BackupRestore/index.html">Backup and Restore</a> sample application.</p> 
 </div> 
 ","BackupAgent","android.app.backup.BackupAgent","class",0
,"Data Backup","Checking the Restore Data Version","<h2 id="RestoreVersion">Checking the Restore Data Version</h2> 
 <p>When the Backup Manager saves your data to cloud storage, it automatically includes the version of your application, as defined by your manifest file's <a href="../../../guide/topics/manifest/manifest-element.html#vcode"><code>android:versionCode</code></a> attribute. Before the Backup Manager calls your backup agent to restore your data, it looks at the <a href="../../../guide/topics/manifest/manifest-element.html#vcode"><code>android:versionCode</code></a> of the installed application and compares it to the value recorded in the restore data set. If the version recorded in the restore data set is <em>newer</em> than the application version on the device, then the user has downgraded their application. In this case, the Backup Manager will abort the restore operation for your application and not call your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method, because the restore set is considered meaningless to an older version.</p> 
 <p>You can override this behavior with the <a href="../../../guide/topics/manifest/application-element.html#restoreany"><code>android:restoreAnyVersion</code></a> attribute. This attribute is either &quot;<code>true</code>&quot; or &quot;<code>false</code>&quot; to indicate whether you want to restore the application regardless of the restore set version. The default value is &quot;<code>false</code>&quot;. If you define this to be &quot;<code>true</code>&quot; then the Backup Manager will ignore the <a href="../../../guide/topics/manifest/manifest-element.html#vcode"><code>android:versionCode</code></a> and call your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method in all cases. In doing so, you can manually check for the version difference in your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method and take any steps necessary to make the data compatible if the versions conflict.</p> 
 <p>To help you handle different versions during a restore operation, the <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method passes you the version code included with the restore data set as the <code>appVersionCode</code> parameter. You can then query the current application's version code with the <code><a href="../../../reference/android/content/pm/PackageInfo.html#versionCode">PackageInfo.versionCode</a></code> field. For example:</p> 
 <pre>
PackageInfo info;
try {
    String name = <code><a href="../../../reference/android/content/ContextWrapper.html#getPackageName()">getPackageName</a></code>();
    info = <code><a href="../../../reference/android/content/ContextWrapper.html#getPackageManager()">getPackageManager</a></code>().<code><a href="../../../reference/android/content/pm/PackageManager.html#getPackageInfo(java.lang.String, int)">getPackageInfo</a></code>(name,0);
} catch (NameNotFoundException nnfe) {
    info = null;
}

int version;
if (info != null) {
    version = info.versionCode;
}
</pre> 
 <p>Then simply compare the <code>version</code> acquired from <code><a href="../../../reference/android/content/pm/PackageInfo.html">PackageInfo</a></code> to the <code>appVersionCode</code> passed into <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>. </p> 
 <p class="caution"><strong>Caution:</strong> Be certain you understand the consequences of setting <a href="../../../guide/topics/manifest/application-element.html#restoreany"><code>android:restoreAnyVersion</code></a> to &quot;<code>true</code>&quot; for your application. If each version of your application that supports backup does not properly account for variations in your data format during <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>, then the data on the device could be saved in a format incompatible with the version currently installed on the device.</p> 
 ","BackupAgent","android.app.backup.BackupAgent","class",0
,"Data Backup","Requesting Backup","<h2 id="RequestingBackup">Requesting Backup</h2> 
 <p>You can request a backup operation at any time by calling <code><a href="../../../reference/android/app/backup/BackupManager.html#dataChanged()">dataChanged()</a></code>. This method notifies the Backup Manager that you'd like to backup your data using your backup agent. The Backup Manager then calls your backup agent's <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method at an opportune time in the future. Typically, you should request a backup each time your data changes (such as when the user changes an application preference that you'd like to back up). If you call <code><a href="../../../reference/android/app/backup/BackupManager.html#dataChanged()">dataChanged()</a></code> several times consecutively, before the Backup Manager requests a backup from your agent, your agent still receives just one call to <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code>.</p> 
 <p class="note"><strong>Note:</strong> While developing your application, you can request a backup and initiate an immediate backup operation with the <a href="../../../tools/help/bmgr.html"><code>bmgr</code> tool</a>.</p> 
 ","BackupAgent","android.app.backup.BackupAgent","class",0
,"Data Backup","Requesting Restore","<h2 id="RequestingRestore">Requesting Restore</h2> 
 <p>During the normal life of your application, you shouldn't need to request a restore operation. They system automatically checks for backup data and performs a restore when your application is installed. However, you can manually request a restore operation by calling <code><a href="../../../reference/android/app/backup/BackupManager.html#requestRestore(android.app.backup.RestoreObserver)">requestRestore()</a></code>, if necessary. In which case, the Backup Manager calls your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> implementation, passing the data from the current set of backup data.</p> 
 <p class="note"><strong>Note:</strong> While developing your application, you can request a restore operation with the <a href="../../../tools/help/bmgr.html"><code>bmgr</code> tool</a>.</p> 
 ","BackupAgent","android.app.backup.BackupAgent","class",0
,"Extending BackupAgent","Performing backup","<h3 id="PerformingBackup">Performing backup</h3> 
 <p>When it's time to back up your application data, the Backup Manager calls your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method. This is where you must provide your application data to the Backup Manager so it can be saved to cloud storage.</p> 
 <p>Only the Backup Manager can call your backup agent's <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method. Each time that your application data changes and you want to perform a backup, you must request a backup operation by calling <code><a href="../../../reference/android/app/backup/BackupManager.html#dataChanged()">dataChanged()</a></code> (see <a href="#RequestingBackup">Requesting Backup</a> for more information). A backup request does not result in an immediate call to your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method. Instead, the Backup Manager waits for an appropriate time, then performs backup for all applications that have requested a backup since the last backup was performed.</p> 
 <p class="note"><strong>Tip:</strong> While developing your application, you can initiate an immediate backup operation from the Backup Manager with the <a href="../../../tools/help/bmgr.html"><code>bmgr</code> tool</a>.</p> 
 <p>When the Backup Manager calls your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method, it passes three parameters:</p> 
 <dl> 
  <dt>
   <code>oldState</code>
  </dt> 
  <dd>
   An open, read-only 
   <code><a href="../../../reference/android/os/ParcelFileDescriptor.html">ParcelFileDescriptor</a></code> pointing to the last backup state provided by your application. This is not the backup data from cloud storage, but a local representation of the data that was backed up the last time 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> was called (as defined by 
   <code>newState</code>, below, or from 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>！more about this in the next section). Because 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> does not allow you to read existing backup data in the cloud storage, you can use this local representation to determine whether your data has changed since the last backup.
  </dd> 
  <dt>
   <code>data</code>
  </dt> 
  <dd>
   A 
   <code><a href="../../../reference/android/app/backup/BackupDataOutput.html">BackupDataOutput</a></code> object, which you use to deliver your backup data to the Backup Manager.
  </dd> 
  <dt>
   <code>newState</code>
  </dt> 
  <dd>
   An open, read/write 
   <code><a href="../../../reference/android/os/ParcelFileDescriptor.html">ParcelFileDescriptor</a></code> pointing to a file in which you must write a representation of the data that you delivered to 
   <code>data</code> (a representation can be as simple as the last-modified timestamp for your file). This object is returned as 
   <code>oldState</code> the next time the Backup Manager calls your 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method. If you do not write your backup data to 
   <code>newState</code>, then 
   <code>oldState</code> will point to an empty file next time Backup Manager calls 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code>.
  </dd> 
 </dl> 
 <p>Using these parameters, you should implement your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method to do the following:</p> 
 <ol> 
  <li>Check whether your data has changed since the last backup by comparing <code>oldState</code> to your current data. How you read data in <code>oldState</code> depends on how you originally wrote it to <code>newState</code> (see step 3). The easiest way to record the state of a file is with its last-modified timestamp. For example, here's how you can read and compare a timestamp from <code>oldState</code>: <pre>
// Get the oldState input stream
FileInputStream instream = new FileInputStream(oldState.getFileDescriptor());
DataInputStream in = new DataInputStream(instream);

try {
    // Get the last modified timestamp from the state file and data file
    long stateModified = in.readLong();
    long fileModified = mDataFile.lastModified();

    if (stateModified != fileModified) {
        // The file has been modified, so do a backup
        // Or the time on the device changed, so be safe and do a backup
    } else {
        // Don't back up because the file hasn't changed
        return;
    }
} catch (IOException e) {
    // Unable to read state file... be safe and do a backup
}
</pre> <p>If nothing has changed and you don't need to back up, skip to step 3.</p> </li> 
  <li>If your data has changed, compared to <code>oldState</code>, write the current data to <code>data</code> to back it up to the cloud storage. <p>You must write each chunk of data as an &quot;entity&quot; in the <code><a href="../../../reference/android/app/backup/BackupDataOutput.html">BackupDataOutput</a></code>. An entity is a flattened binary data record that is identified by a unique key string. Thus, the data set that you back up is conceptually a set of key-value pairs.</p> <p>To add an entity to your backup data set, you must:</p> 
   <ol> 
    <li>Call <code><a href="../../../reference/android/app/backup/BackupDataOutput.html#writeEntityHeader(java.lang.String, int)">writeEntityHeader()</a></code>, passing a unique string key for the data you're about to write and the data size.</li> 
    <li>Call <code><a href="../../../reference/android/app/backup/BackupDataOutput.html#writeEntityData(byte[], int)">writeEntityData()</a></code>, passing a byte buffer that contains your data and the number of bytes to write from the buffer (which should match the size passed to <code><a href="../../../reference/android/app/backup/BackupDataOutput.html#writeEntityHeader(java.lang.String, int)">writeEntityHeader()</a></code>).</li> 
   </ol> <p>For example, the following code flattens some data into a byte stream and writes it into a single entity:</p> <pre>
// Create buffer stream and data output stream for our data
ByteArrayOutputStream bufStream = new ByteArrayOutputStream();
DataOutputStream outWriter = new DataOutputStream(bufStream);
// Write structured data
outWriter.writeUTF(mPlayerName);
outWriter.writeInt(mPlayerScore);
// Send the data to the Backup Manager via the BackupDataOutput
byte[] buffer = bufStream.toByteArray();
int len = buffer.length;
data.writeEntityHeader(TOPSCORE_BACKUP_KEY, len);
data.writeEntityData(buffer, len);
</pre> <p>Perform this for each piece of data that you want to back up. How you divide your data into entities is up to you (and you might use just one entity).</p> </li> 
  <li>Whether or not you perform a backup (in step 2), write a representation of the current data to the <code>newState</code> <code><a href="../../../reference/android/os/ParcelFileDescriptor.html">ParcelFileDescriptor</a></code>. The Backup Manager retains this object locally as a representation of the data that is currently backed up. It passes this back to you as <code>oldState</code> the next time it calls <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> so you can determine whether another backup is necessary (as handled in step 1). If you do not write the current data state to this file, then <code>oldState</code> will be empty during the next callback. <p>The following example saves a representation of the current data into <code>newState</code> using the file's last-modified timestamp:</p> <pre>
FileOutputStream outstream = new FileOutputStream(newState.getFileDescriptor());
DataOutputStream out = new DataOutputStream(outstream);

long modified = mDataFile.lastModified();
out.writeLong(modified);
</pre> </li> 
 </ol> 
 <p class="caution"><strong>Caution:</strong> If your application data is saved to a file, make sure that you use synchronized statements while accessing the file so that your backup agent does not read the file while an Activity in your application is also writing the file.</p> 
 ","BackupDataOutput","android.app.backup.BackupDataOutput","class",0
,"Extending BackupAgent","Performing backup","<h3 id="PerformingBackup">Performing backup</h3> 
 <p>When it's time to back up your application data, the Backup Manager calls your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method. This is where you must provide your application data to the Backup Manager so it can be saved to cloud storage.</p> 
 <p>Only the Backup Manager can call your backup agent's <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method. Each time that your application data changes and you want to perform a backup, you must request a backup operation by calling <code><a href="../../../reference/android/app/backup/BackupManager.html#dataChanged()">dataChanged()</a></code> (see <a href="#RequestingBackup">Requesting Backup</a> for more information). A backup request does not result in an immediate call to your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method. Instead, the Backup Manager waits for an appropriate time, then performs backup for all applications that have requested a backup since the last backup was performed.</p> 
 <p class="note"><strong>Tip:</strong> While developing your application, you can initiate an immediate backup operation from the Backup Manager with the <a href="../../../tools/help/bmgr.html"><code>bmgr</code> tool</a>.</p> 
 <p>When the Backup Manager calls your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method, it passes three parameters:</p> 
 <dl> 
  <dt>
   <code>oldState</code>
  </dt> 
  <dd>
   An open, read-only 
   <code><a href="../../../reference/android/os/ParcelFileDescriptor.html">ParcelFileDescriptor</a></code> pointing to the last backup state provided by your application. This is not the backup data from cloud storage, but a local representation of the data that was backed up the last time 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> was called (as defined by 
   <code>newState</code>, below, or from 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>！more about this in the next section). Because 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> does not allow you to read existing backup data in the cloud storage, you can use this local representation to determine whether your data has changed since the last backup.
  </dd> 
  <dt>
   <code>data</code>
  </dt> 
  <dd>
   A 
   <code><a href="../../../reference/android/app/backup/BackupDataOutput.html">BackupDataOutput</a></code> object, which you use to deliver your backup data to the Backup Manager.
  </dd> 
  <dt>
   <code>newState</code>
  </dt> 
  <dd>
   An open, read/write 
   <code><a href="../../../reference/android/os/ParcelFileDescriptor.html">ParcelFileDescriptor</a></code> pointing to a file in which you must write a representation of the data that you delivered to 
   <code>data</code> (a representation can be as simple as the last-modified timestamp for your file). This object is returned as 
   <code>oldState</code> the next time the Backup Manager calls your 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method. If you do not write your backup data to 
   <code>newState</code>, then 
   <code>oldState</code> will point to an empty file next time Backup Manager calls 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code>.
  </dd> 
 </dl> 
 <p>Using these parameters, you should implement your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> method to do the following:</p> 
 <ol> 
  <li>Check whether your data has changed since the last backup by comparing <code>oldState</code> to your current data. How you read data in <code>oldState</code> depends on how you originally wrote it to <code>newState</code> (see step 3). The easiest way to record the state of a file is with its last-modified timestamp. For example, here's how you can read and compare a timestamp from <code>oldState</code>: <pre>
// Get the oldState input stream
FileInputStream instream = new FileInputStream(oldState.getFileDescriptor());
DataInputStream in = new DataInputStream(instream);

try {
    // Get the last modified timestamp from the state file and data file
    long stateModified = in.readLong();
    long fileModified = mDataFile.lastModified();

    if (stateModified != fileModified) {
        // The file has been modified, so do a backup
        // Or the time on the device changed, so be safe and do a backup
    } else {
        // Don't back up because the file hasn't changed
        return;
    }
} catch (IOException e) {
    // Unable to read state file... be safe and do a backup
}
</pre> <p>If nothing has changed and you don't need to back up, skip to step 3.</p> </li> 
  <li>If your data has changed, compared to <code>oldState</code>, write the current data to <code>data</code> to back it up to the cloud storage. <p>You must write each chunk of data as an &quot;entity&quot; in the <code><a href="../../../reference/android/app/backup/BackupDataOutput.html">BackupDataOutput</a></code>. An entity is a flattened binary data record that is identified by a unique key string. Thus, the data set that you back up is conceptually a set of key-value pairs.</p> <p>To add an entity to your backup data set, you must:</p> 
   <ol> 
    <li>Call <code><a href="../../../reference/android/app/backup/BackupDataOutput.html#writeEntityHeader(java.lang.String, int)">writeEntityHeader()</a></code>, passing a unique string key for the data you're about to write and the data size.</li> 
    <li>Call <code><a href="../../../reference/android/app/backup/BackupDataOutput.html#writeEntityData(byte[], int)">writeEntityData()</a></code>, passing a byte buffer that contains your data and the number of bytes to write from the buffer (which should match the size passed to <code><a href="../../../reference/android/app/backup/BackupDataOutput.html#writeEntityHeader(java.lang.String, int)">writeEntityHeader()</a></code>).</li> 
   </ol> <p>For example, the following code flattens some data into a byte stream and writes it into a single entity:</p> <pre>
// Create buffer stream and data output stream for our data
ByteArrayOutputStream bufStream = new ByteArrayOutputStream();
DataOutputStream outWriter = new DataOutputStream(bufStream);
// Write structured data
outWriter.writeUTF(mPlayerName);
outWriter.writeInt(mPlayerScore);
// Send the data to the Backup Manager via the BackupDataOutput
byte[] buffer = bufStream.toByteArray();
int len = buffer.length;
data.writeEntityHeader(TOPSCORE_BACKUP_KEY, len);
data.writeEntityData(buffer, len);
</pre> <p>Perform this for each piece of data that you want to back up. How you divide your data into entities is up to you (and you might use just one entity).</p> </li> 
  <li>Whether or not you perform a backup (in step 2), write a representation of the current data to the <code>newState</code> <code><a href="../../../reference/android/os/ParcelFileDescriptor.html">ParcelFileDescriptor</a></code>. The Backup Manager retains this object locally as a representation of the data that is currently backed up. It passes this back to you as <code>oldState</code> the next time it calls <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> so you can determine whether another backup is necessary (as handled in step 1). If you do not write the current data state to this file, then <code>oldState</code> will be empty during the next callback. <p>The following example saves a representation of the current data into <code>newState</code> using the file's last-modified timestamp:</p> <pre>
FileOutputStream outstream = new FileOutputStream(newState.getFileDescriptor());
DataOutputStream out = new DataOutputStream(outstream);

long modified = mDataFile.lastModified();
out.writeLong(modified);
</pre> </li> 
 </ol> 
 <p class="caution"><strong>Caution:</strong> If your application data is saved to a file, make sure that you use synchronized statements while accessing the file so that your backup agent does not read the file while an Activity in your application is also writing the file.</p> 
 ","ParcelFileDescriptor","android.os.ParcelFileDescriptor","class",0
,"Extending BackupAgent","Performing restore","<h3 id="PerformingRestore">Performing restore</h3> 
 <p>When it's time to restore your application data, the Backup Manager calls your backup agent's <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method. When it calls this method, the Backup Manager delivers your backup data so you can restore it onto the device.</p> 
 <p>Only the Backup Manager can call <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>, which happens automatically when the system installs your application and finds existing backup data. However, you can request a restore operation for your application by calling <code><a href="../../../reference/android/app/backup/BackupManager.html#requestRestore(android.app.backup.RestoreObserver)">requestRestore()</a></code> (see <a href="#RequestingRestore">Requesting restore</a> for more information).</p> 
 <p class="note"><strong>Note:</strong> While developing your application, you can also request a restore operation with the <a href="../../../tools/help/bmgr.html"><code>bmgr</code> tool</a>.</p> 
 <p>When the Backup Manager calls your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method, it passes three parameters:</p> 
 <dl> 
  <dt>
   <code>data</code>
  </dt> 
  <dd>
   A 
   <code><a href="../../../reference/android/app/backup/BackupDataInput.html">BackupDataInput</a></code>, which allows you to read your backup data.
  </dd> 
  <dt>
   <code>appVersionCode</code>
  </dt> 
  <dd>
   An integer representing the value of your application's 
   <a href="../../../guide/topics/manifest/manifest-element.html#vcode"><code>android:versionCode</code></a> manifest attribute, as it was when this data was backed up. You can use this to cross-check the current application version and determine if the data format is compatible. For more information about using this to handle different versions of restore data, see the section below about 
   <a href="#RestoreVersion">Checking the Restore Data Version</a>.
  </dd> 
  <dt>
   <code>newState</code>
  </dt> 
  <dd>
   An open, read/write 
   <code><a href="../../../reference/android/os/ParcelFileDescriptor.html">ParcelFileDescriptor</a></code> pointing to a file in which you must write the final backup state that was provided with 
   <code>data</code>. This object is returned as 
   <code>oldState</code> the next time 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> is called. Recall that you must also write the same 
   <code>newState</code> object in the 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> callback！also doing it here ensures that the 
   <code>oldState</code> object given to 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> is valid even the first time 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> is called after the device is restored.
  </dd> 
 </dl> 
 <p>In your implementation of <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>, you should call <code><a href="../../../reference/android/app/backup/BackupDataInput.html#readNextHeader()">readNextHeader()</a></code> on the <code>data</code> to iterate through all entities in the data set. For each entity found, do the following:</p> 
 <ol> 
  <li>Get the entity key with <code><a href="../../../reference/android/app/backup/BackupDataInput.html#getKey()">getKey()</a></code>.</li> 
  <li>Compare the entity key to a list of known key values that you should have declared as static final strings inside your <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code> class. When the key matches one of your known key strings, enter into a statement to extract the entity data and save it to the device: 
   <ol> 
    <li>Get the entity data size with <code><a href="../../../reference/android/app/backup/BackupDataInput.html#getDataSize()">getDataSize()</a></code> and create a byte array of that size.</li> 
    <li>Call <code><a href="../../../reference/android/app/backup/BackupDataInput.html#readEntityData(byte[], int, int)">readEntityData()</a></code> and pass it the byte array, which is where the data will go, and specify the start offset and the size to read.</li> 
    <li>Your byte array is now full and you can read the data and write it to the device however you like.</li> 
   </ol> </li> 
  <li>After you read and write your data back to the device, write the state of your data to the <code>newState</code> parameter the same as you do during <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code>. </li>
 </ol> 
 <p>For example, here's how you can restore the data backed up by the example in the previous section:</p> 
 <pre>
@Override
public void onRestore(BackupDataInput data, int appVersionCode,
                      ParcelFileDescriptor newState) throws IOException {
    // There should be only one entity, but the safest
    // way to consume it is using a while loop
    while (data.readNextHeader()) {
        String key = data.getKey();
        int dataSize = data.getDataSize();

        // If the key is ours (for saving top score). Note this key was used when
        // we wrote the backup entity header
        if (TOPSCORE_BACKUP_KEY.equals(key)) {
            // Create an input stream for the BackupDataInput
            byte[] dataBuf = new byte[dataSize];
            data.readEntityData(dataBuf, 0, dataSize);
            ByteArrayInputStream baStream = new ByteArrayInputStream(dataBuf);
            DataInputStream in = new DataInputStream(baStream);

            // Read the player name and score from the backup data
            mPlayerName = in.readUTF();
            mPlayerScore = in.readInt();

            // Record the score on the device (to a file or something)
            recordScore(mPlayerName, mPlayerScore);
        } else {
            // We don't know this entity key. Skip it. (Shouldn't happen.)
            data.skipEntityData();
        }
    }

    // Finally, write to the state blob (newState) that describes the restored data
    FileOutputStream outstream = new FileOutputStream(newState.getFileDescriptor());
    DataOutputStream out = new DataOutputStream(outstream);
    out.writeUTF(mPlayerName);
    out.writeInt(mPlayerScore);
}
</pre> 
 <p>In this example, the <code>appVersionCode</code> parameter passed to <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> is not used. However, you might want to use it if you've chosen to perform backup when the user's version of the application has actually moved backward (for example, the user went from version 1.5 of your app to 1.0). For more information, see the section about <a href="#RestoreVersion">Checking the Restore Data Version</a>.</p> 
 <div class="special"> 
  <p>For an example implementation of <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code>, see the <a href="../../../resources/samples/BackupRestore/src/com/example/android/backuprestore/ExampleAgent.html"><code>ExampleAgent</code></a> class in the <a href="../../../resources/samples/BackupRestore/index.html">Backup and Restore</a> sample application.</p> 
 </div> 
 ","ParcelFileDescriptor","android.os.ParcelFileDescriptor","class",0
,"Extending BackupAgent","Performing restore","<h3 id="PerformingRestore">Performing restore</h3> 
 <p>When it's time to restore your application data, the Backup Manager calls your backup agent's <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method. When it calls this method, the Backup Manager delivers your backup data so you can restore it onto the device.</p> 
 <p>Only the Backup Manager can call <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>, which happens automatically when the system installs your application and finds existing backup data. However, you can request a restore operation for your application by calling <code><a href="../../../reference/android/app/backup/BackupManager.html#requestRestore(android.app.backup.RestoreObserver)">requestRestore()</a></code> (see <a href="#RequestingRestore">Requesting restore</a> for more information).</p> 
 <p class="note"><strong>Note:</strong> While developing your application, you can also request a restore operation with the <a href="../../../tools/help/bmgr.html"><code>bmgr</code> tool</a>.</p> 
 <p>When the Backup Manager calls your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method, it passes three parameters:</p> 
 <dl> 
  <dt>
   <code>data</code>
  </dt> 
  <dd>
   A 
   <code><a href="../../../reference/android/app/backup/BackupDataInput.html">BackupDataInput</a></code>, which allows you to read your backup data.
  </dd> 
  <dt>
   <code>appVersionCode</code>
  </dt> 
  <dd>
   An integer representing the value of your application's 
   <a href="../../../guide/topics/manifest/manifest-element.html#vcode"><code>android:versionCode</code></a> manifest attribute, as it was when this data was backed up. You can use this to cross-check the current application version and determine if the data format is compatible. For more information about using this to handle different versions of restore data, see the section below about 
   <a href="#RestoreVersion">Checking the Restore Data Version</a>.
  </dd> 
  <dt>
   <code>newState</code>
  </dt> 
  <dd>
   An open, read/write 
   <code><a href="../../../reference/android/os/ParcelFileDescriptor.html">ParcelFileDescriptor</a></code> pointing to a file in which you must write the final backup state that was provided with 
   <code>data</code>. This object is returned as 
   <code>oldState</code> the next time 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> is called. Recall that you must also write the same 
   <code>newState</code> object in the 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> callback！also doing it here ensures that the 
   <code>oldState</code> object given to 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> is valid even the first time 
   <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> is called after the device is restored.
  </dd> 
 </dl> 
 <p>In your implementation of <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>, you should call <code><a href="../../../reference/android/app/backup/BackupDataInput.html#readNextHeader()">readNextHeader()</a></code> on the <code>data</code> to iterate through all entities in the data set. For each entity found, do the following:</p> 
 <ol> 
  <li>Get the entity key with <code><a href="../../../reference/android/app/backup/BackupDataInput.html#getKey()">getKey()</a></code>.</li> 
  <li>Compare the entity key to a list of known key values that you should have declared as static final strings inside your <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code> class. When the key matches one of your known key strings, enter into a statement to extract the entity data and save it to the device: 
   <ol> 
    <li>Get the entity data size with <code><a href="../../../reference/android/app/backup/BackupDataInput.html#getDataSize()">getDataSize()</a></code> and create a byte array of that size.</li> 
    <li>Call <code><a href="../../../reference/android/app/backup/BackupDataInput.html#readEntityData(byte[], int, int)">readEntityData()</a></code> and pass it the byte array, which is where the data will go, and specify the start offset and the size to read.</li> 
    <li>Your byte array is now full and you can read the data and write it to the device however you like.</li> 
   </ol> </li> 
  <li>After you read and write your data back to the device, write the state of your data to the <code>newState</code> parameter the same as you do during <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code>. </li>
 </ol> 
 <p>For example, here's how you can restore the data backed up by the example in the previous section:</p> 
 <pre>
@Override
public void onRestore(BackupDataInput data, int appVersionCode,
                      ParcelFileDescriptor newState) throws IOException {
    // There should be only one entity, but the safest
    // way to consume it is using a while loop
    while (data.readNextHeader()) {
        String key = data.getKey();
        int dataSize = data.getDataSize();

        // If the key is ours (for saving top score). Note this key was used when
        // we wrote the backup entity header
        if (TOPSCORE_BACKUP_KEY.equals(key)) {
            // Create an input stream for the BackupDataInput
            byte[] dataBuf = new byte[dataSize];
            data.readEntityData(dataBuf, 0, dataSize);
            ByteArrayInputStream baStream = new ByteArrayInputStream(dataBuf);
            DataInputStream in = new DataInputStream(baStream);

            // Read the player name and score from the backup data
            mPlayerName = in.readUTF();
            mPlayerScore = in.readInt();

            // Record the score on the device (to a file or something)
            recordScore(mPlayerName, mPlayerScore);
        } else {
            // We don't know this entity key. Skip it. (Shouldn't happen.)
            data.skipEntityData();
        }
    }

    // Finally, write to the state blob (newState) that describes the restored data
    FileOutputStream outstream = new FileOutputStream(newState.getFileDescriptor());
    DataOutputStream out = new DataOutputStream(outstream);
    out.writeUTF(mPlayerName);
    out.writeInt(mPlayerScore);
}
</pre> 
 <p>In this example, the <code>appVersionCode</code> parameter passed to <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> is not used. However, you might want to use it if you've chosen to perform backup when the user's version of the application has actually moved backward (for example, the user went from version 1.5 of your app to 1.0). For more information, see the section about <a href="#RestoreVersion">Checking the Restore Data Version</a>.</p> 
 <div class="special"> 
  <p>For an example implementation of <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code>, see the <a href="../../../resources/samples/BackupRestore/src/com/example/android/backuprestore/ExampleAgent.html"><code>ExampleAgent</code></a> class in the <a href="../../../resources/samples/BackupRestore/index.html">Backup and Restore</a> sample application.</p> 
 </div> 
 ","BackupDataInput","android.app.backup.BackupDataInput","class",0
,"Data Backup","Extending BackupAgentHelper","<h2 id="BackupAgentHelper">Extending BackupAgentHelper</h2> 
 <p>You should build your backup agent using <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> if you want to back up complete files (from either <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> or <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>). Building your backup agent with <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> requires far less code than extending <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code>, because you don't have to implement <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>.</p> 
 <p>Your implementation of <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> must use one or more backup helpers. A backup helper is a specialized component that <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> summons to perform backup and restore operations for a particular type of data. The Android framework currently provides two different helpers:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code> to backup <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> files.</li> 
  <li><code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code> to backup files from <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>.</li> 
 </ul> 
 <p>You can include multiple helpers in your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, but only one helper is needed for each data type. That is, if you have multiple <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> files, then you need only one <code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code>.</p> 
 <p>For each helper you want to add to your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, you must do the following during your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onCreate()">onCreate()</a></code> method:</p> 
 <ol> 
  <li>Instantiate in instance of the desired helper class. In the class constructor, you must specify the appropriate file(s) you want to backup.</li> 
  <li>Call <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html#addHelper(java.lang.String, android.app.backup.BackupHelper)">addHelper()</a></code> to add the helper to your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>.</li> 
 </ol> 
 <p>The following sections describe how to create a backup agent using each of the available helpers.</p> 
 ","SharedPreferencesBackupHelper","android.app.backup.SharedPreferencesBackupHelper","class",0
,"Extending BackupAgentHelper","Backing up SharedPreferences","<h3 id="SharedPreferences">Backing up SharedPreferences</h3> 
 <p>When you instantiate a <code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code>, you must include the name of one or more <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> files.</p> 
 <p>For example, to back up a <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> file named &quot;user_preferences&quot;, a complete backup agent using <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> looks like this:</p> 
 <pre>
public class MyPrefsBackupAgent extends BackupAgentHelper {
    // The name of the SharedPreferences file
    static final String PREFS = &quot;user_preferences&quot;;

    // A key to uniquely identify the set of backup data
    static final String PREFS_BACKUP_KEY = &quot;prefs&quot;;

    // Allocate a helper and add it to the backup agent
    @Override
    public void onCreate() {
        SharedPreferencesBackupHelper helper = new SharedPreferencesBackupHelper(this, PREFS);
        addHelper(PREFS_BACKUP_KEY, helper);
    }
}
</pre> 
 <p>That's it! That's your entire backup agent. The <code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code> includes all the code needed to backup and restore a <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> file.</p> 
 <p>When the Backup Manager calls <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>, <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> calls your backup helpers to perform backup and restore for your specified files.</p> 
 <p class="note"><strong>Note:</strong> <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> are threadsafe, so you can safely read and write the shared preferences file from your backup agent and other activities.</p> 
 ","SharedPreferencesBackupHelper","android.app.backup.SharedPreferencesBackupHelper","class",1
,"Data Backup","Extending BackupAgentHelper","<h2 id="BackupAgentHelper">Extending BackupAgentHelper</h2> 
 <p>You should build your backup agent using <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> if you want to back up complete files (from either <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> or <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>). Building your backup agent with <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> requires far less code than extending <code><a href="../../../reference/android/app/backup/BackupAgent.html">BackupAgent</a></code>, because you don't have to implement <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>.</p> 
 <p>Your implementation of <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> must use one or more backup helpers. A backup helper is a specialized component that <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> summons to perform backup and restore operations for a particular type of data. The Android framework currently provides two different helpers:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code> to backup <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> files.</li> 
  <li><code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code> to backup files from <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>.</li> 
 </ul> 
 <p>You can include multiple helpers in your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, but only one helper is needed for each data type. That is, if you have multiple <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> files, then you need only one <code><a href="../../../reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a></code>.</p> 
 <p>For each helper you want to add to your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, you must do the following during your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onCreate()">onCreate()</a></code> method:</p> 
 <ol> 
  <li>Instantiate in instance of the desired helper class. In the class constructor, you must specify the appropriate file(s) you want to backup.</li> 
  <li>Call <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html#addHelper(java.lang.String, android.app.backup.BackupHelper)">addHelper()</a></code> to add the helper to your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>.</li> 
 </ol> 
 <p>The following sections describe how to create a backup agent using each of the available helpers.</p> 
 ","FileBackupHelper","android.app.backup.FileBackupHelper","class",0
,"Extending BackupAgentHelper","Backing up other files","<h3 id="Files">Backing up other files</h3> 
 <p>When you instantiate a <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code>, you must include the name of one or more files that are saved to your application's <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a> (as specified by <code><a href="../../../reference/android/content/ContextWrapper.html#getFilesDir()">getFilesDir()</a></code>, which is the same location where <code><a href="../../../reference/android/content/Context.html#openFileOutput(java.lang.String, int)">openFileOutput()</a></code> writes files).</p> 
 <p>For example, to backup two files named &quot;scores&quot; and &quot;stats,&quot; a backup agent using <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> looks like this:</p> 
 <pre>
public class MyFileBackupAgent extends BackupAgentHelper {
    // The name of the file
    static final String TOP_SCORES = &quot;scores&quot;;
    static final String PLAYER_STATS = &quot;stats&quot;;

    // A key to uniquely identify the set of backup data
    static final String FILES_BACKUP_KEY = &quot;myfiles&quot;;

    // Allocate a helper and add it to the backup agent
    void onCreate() {
        FileBackupHelper helper = new FileBackupHelper(this, TOP_SCORES, PLAYER_STATS);
        addHelper(FILES_BACKUP_KEY, helper);
    }
}
</pre> 
 <p>The <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code> includes all the code necessary to backup and restore files that are saved to your application's <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>..</p> 
 <p>However, reading and writing to files on internal storage is <strong>not threadsafe</strong>. To ensure that your backup agent does not read or write your files at the same time as your activities, you must use synchronized statements each time you perform a read or write. For example, in any Activity where you read and write the file, you need an object to use as the intrinsic lock for the synchronized statements:</p> 
 <pre>
// Object for intrinsic lock
static final Object sDataLock = new Object();
</pre> 
 <p>Then create a synchronized statement with this lock each time you read or write the files. For example, here's a synchronized statement for writing the latest score in a game to a file:</p> 
 <pre>
try {
    synchronized (MyActivity.sDataLock) {
        File dataFile = new File(<code><a href="../../../reference/android/content/Context.html#getFilesDir()">getFilesDir()</a></code>, TOP_SCORES);
        RandomAccessFile raFile = new RandomAccessFile(dataFile, &quot;rw&quot;);
        raFile.writeInt(score);
    }
} catch (IOException e) {
    Log.e(TAG, &quot;Unable to write to file&quot;);
}
</pre> 
 <p>You should synchronize your read statements with the same lock.</p> 
 <p>Then, in your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, you must override <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> to synchronize the backup and restore operations with the same intrinsic lock. For example, the <code>MyFileBackupAgent</code> example from above needs the following methods:</p> 
 <pre>
@Override
public void onBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
          ParcelFileDescriptor newState) throws IOException {
    // Hold the lock while the FileBackupHelper performs backup
    synchronized (MyActivity.sDataLock) {
        super.onBackup(oldState, data, newState);
    }
}

@Override
public void onRestore(BackupDataInput data, int appVersionCode,
        ParcelFileDescriptor newState) throws IOException {
    // Hold the lock while the FileBackupHelper restores the file
    synchronized (MyActivity.sDataLock) {
        super.onRestore(data, appVersionCode, newState);
    }
}
</pre> 
 <p>That's it. All you need to do is add your <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code> in the <code><a href="../../../reference/android/app/backup/BackupAgent.html#onCreate()">onCreate()</a></code> method and override <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> to synchronize read and write operations.</p> 
 <div class="special"> 
  <p>For an example implementation of <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> with <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code>, see the <code>FileHelperExampleAgent</code> class in the <a href="../../../resources/samples/BackupRestore/index.html">Backup and Restore</a> sample application.</p> 
 </div> 
 ","FileBackupHelper","android.app.backup.FileBackupHelper","class",1
,"Extending BackupAgentHelper","Backing up other files","<h3 id="Files">Backing up other files</h3> 
 <p>When you instantiate a <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code>, you must include the name of one or more files that are saved to your application's <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a> (as specified by <code><a href="../../../reference/android/content/ContextWrapper.html#getFilesDir()">getFilesDir()</a></code>, which is the same location where <code><a href="../../../reference/android/content/Context.html#openFileOutput(java.lang.String, int)">openFileOutput()</a></code> writes files).</p> 
 <p>For example, to backup two files named &quot;scores&quot; and &quot;stats,&quot; a backup agent using <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> looks like this:</p> 
 <pre>
public class MyFileBackupAgent extends BackupAgentHelper {
    // The name of the file
    static final String TOP_SCORES = &quot;scores&quot;;
    static final String PLAYER_STATS = &quot;stats&quot;;

    // A key to uniquely identify the set of backup data
    static final String FILES_BACKUP_KEY = &quot;myfiles&quot;;

    // Allocate a helper and add it to the backup agent
    void onCreate() {
        FileBackupHelper helper = new FileBackupHelper(this, TOP_SCORES, PLAYER_STATS);
        addHelper(FILES_BACKUP_KEY, helper);
    }
}
</pre> 
 <p>The <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code> includes all the code necessary to backup and restore files that are saved to your application's <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>..</p> 
 <p>However, reading and writing to files on internal storage is <strong>not threadsafe</strong>. To ensure that your backup agent does not read or write your files at the same time as your activities, you must use synchronized statements each time you perform a read or write. For example, in any Activity where you read and write the file, you need an object to use as the intrinsic lock for the synchronized statements:</p> 
 <pre>
// Object for intrinsic lock
static final Object sDataLock = new Object();
</pre> 
 <p>Then create a synchronized statement with this lock each time you read or write the files. For example, here's a synchronized statement for writing the latest score in a game to a file:</p> 
 <pre>
try {
    synchronized (MyActivity.sDataLock) {
        File dataFile = new File(<code><a href="../../../reference/android/content/Context.html#getFilesDir()">getFilesDir()</a></code>, TOP_SCORES);
        RandomAccessFile raFile = new RandomAccessFile(dataFile, &quot;rw&quot;);
        raFile.writeInt(score);
    }
} catch (IOException e) {
    Log.e(TAG, &quot;Unable to write to file&quot;);
}
</pre> 
 <p>You should synchronize your read statements with the same lock.</p> 
 <p>Then, in your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, you must override <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> to synchronize the backup and restore operations with the same intrinsic lock. For example, the <code>MyFileBackupAgent</code> example from above needs the following methods:</p> 
 <pre>
@Override
public void onBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
          ParcelFileDescriptor newState) throws IOException {
    // Hold the lock while the FileBackupHelper performs backup
    synchronized (MyActivity.sDataLock) {
        super.onBackup(oldState, data, newState);
    }
}

@Override
public void onRestore(BackupDataInput data, int appVersionCode,
        ParcelFileDescriptor newState) throws IOException {
    // Hold the lock while the FileBackupHelper restores the file
    synchronized (MyActivity.sDataLock) {
        super.onRestore(data, appVersionCode, newState);
    }
}
</pre> 
 <p>That's it. All you need to do is add your <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code> in the <code><a href="../../../reference/android/app/backup/BackupAgent.html#onCreate()">onCreate()</a></code> method and override <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> to synchronize read and write operations.</p> 
 <div class="special"> 
  <p>For an example implementation of <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> with <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code>, see the <code>FileHelperExampleAgent</code> class in the <a href="../../../resources/samples/BackupRestore/index.html">Backup and Restore</a> sample application.</p> 
 </div> 
 ","Context","android.content.Context","class",0
,"Using Shared Preferences","User Preferences","<h3>User Preferences</h3> 
   <p>Shared preferences are not strictly for saving &quot;user preferences,&quot; such as what ringtone a user has chosen. If you're interested in creating user preferences for your application, see <code><a href="../../../reference/android/preference/PreferenceActivity.html">PreferenceActivity</a></code>, which provides an Activity framework for you to create user preferences, which will be automatically persisted (using shared preferences).</p> 
  </div> 
 </div> 
 <p>To get a <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> object for your application, use one of two methods:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/content/Context.html#getSharedPreferences(java.lang.String, int)">getSharedPreferences()</a></code> - Use this if you need multiple preferences files identified by name, which you specify with the first parameter.</li> 
  <li><code><a href="../../../reference/android/app/Activity.html#getPreferences(int)">getPreferences()</a></code> - Use this if you need only one preferences file for your Activity. Because this will be the only preferences file for your Activity, you don't supply a name.</li> 
 </ul> 
 <p>To write values:</p> 
 <ol> 
  <li>Call <code><a href="../../../reference/android/content/SharedPreferences.html#edit()">edit()</a></code> to get a <code><a href="../../../reference/android/content/SharedPreferences.Editor.html">SharedPreferences.Editor</a></code>.</li> 
  <li>Add values with methods such as <code><a href="../../../reference/android/content/SharedPreferences.Editor.html#putBoolean(java.lang.String, boolean)">putBoolean()</a></code> and <code><a href="../../../reference/android/content/SharedPreferences.Editor.html#putString(java.lang.String, java.lang.String)">putString()</a></code>.</li> 
  <li>Commit the new values with <code><a href="../../../reference/android/content/SharedPreferences.Editor.html#commit()">commit()</a></code></li> 
 </ol> 
 <p>To read values, use <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> methods such as <code><a href="../../../reference/android/content/SharedPreferences.html#getBoolean(java.lang.String, boolean)">getBoolean()</a></code> and <code><a href="../../../reference/android/content/SharedPreferences.html#getString(java.lang.String, java.lang.String)">getString()</a></code>.</p> 
 <p> Here is an example that saves a preference for silent keypress mode in a calculator: </p> 
 <pre>
public class Calc extends Activity {
    public static final String PREFS_NAME = &quot;MyPrefsFile&quot;;

    @Override
    protected void onCreate(Bundle state){
       super.onCreate(state);
       . . .

       // Restore preferences
       SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
       boolean silent = settings.getBoolean(&quot;silentMode&quot;, false);
       setSilent(silent);
    }

    @Override
    protected void onStop(){
       super.onStop();

      // We need an Editor object to make preference changes.
      // All objects are from android.context.Context
      SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
      SharedPreferences.Editor editor = settings.edit();
      editor.putBoolean(&quot;silentMode&quot;, mSilentMode);

      // Commit the edits!
      editor.commit();
    }
}
</pre> 
 <a name="files"></a> 
 ","Context","android.content.Context","class",0
,"Storage Options","Using the Internal Storage","<h2 id="filesInternal">Using the Internal Storage</h2> 
 <p>You can save files directly on the device's internal storage. By default, files saved to the internal storage are private to your application and other applications cannot access them (nor can the user). When the user uninstalls your application, these files are removed.</p> 
 <p>To create and write a private file to the internal storage:</p> 
 <ol> 
  <li>Call <code><a href="../../../reference/android/content/Context.html#openFileOutput(java.lang.String, int)">openFileOutput()</a></code> with the name of the file and the operating mode. This returns a <code><a href="../../../reference/java/io/FileOutputStream.html">FileOutputStream</a></code>.</li> 
  <li>Write to the file with <code><a href="../../../reference/java/io/OutputStream.html#write(byte[])">write()</a></code>.</li> 
  <li>Close the stream with <code><a href="../../../reference/java/io/FileOutputStream.html#close()">close()</a></code>.</li> 
 </ol> 
 <p>For example:</p> 
 <pre>
String FILENAME = &quot;hello_file&quot;;
String string = &quot;hello world!&quot;;

FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);
fos.write(string.getBytes());
fos.close();
</pre> 
 <p><code><a href="../../../reference/android/content/Context.html#MODE_PRIVATE">MODE_PRIVATE</a></code> will create the file (or replace a file of the same name) and make it private to your application. Other modes available are: <code><a href="../../../reference/android/content/Context.html#MODE_APPEND">MODE_APPEND</a></code>, <code><a href="../../../reference/android/content/Context.html#MODE_WORLD_READABLE">MODE_WORLD_READABLE</a></code>, and <code><a href="../../../reference/android/content/Context.html#MODE_WORLD_WRITEABLE">MODE_WORLD_WRITEABLE</a></code>.</p> 
 <p>To read a file from internal storage:</p> 
 <ol> 
  <li>Call <code><a href="../../../reference/android/content/Context.html#openFileInput(java.lang.String)">openFileInput()</a></code> and pass it the name of the file to read. This returns a <code><a href="../../../reference/java/io/FileInputStream.html">FileInputStream</a></code>.</li> 
  <li>Read bytes from the file with <code><a href="../../../reference/java/io/FileInputStream.html#read(byte[], int, int)">read()</a></code>.</li> 
  <li>Then close the stream with <code><a href="../../../reference/java/io/FileInputStream.html#close()">close()</a></code>.</li> 
 </ol> 
 <p class="note"><strong>Tip:</strong> If you want to save a static file in your application at compile time, save the file in your project <code>res/raw/</code> directory. You can open it with <code><a href="../../../reference/android/content/res/Resources.html#openRawResource(int)">openRawResource()</a></code>, passing the <code>R.raw.<em>&lt;filename&gt;</em></code> resource ID. This method returns an <code><a href="../../../reference/java/io/InputStream.html">InputStream</a></code> that you can use to read the file (but you cannot write to the original file). </p> 
 ","Context","android.content.Context","class",0
,"Using the Internal Storage","Saving cache files","<h3 id="InternalCache">Saving cache files</h3> 
 <p>If you'd like to cache some data, rather than store it persistently, you should use <code><a href="../../../reference/android/content/Context.html#getCacheDir()">getCacheDir()</a></code> to open a <code><a href="../../../reference/java/io/File.html">File</a></code> that represents the internal directory where your application should save temporary cache files.</p> 
 <p>When the device is low on internal storage space, Android may delete these cache files to recover space. However, you should not rely on the system to clean up these files for you. You should always maintain the cache files yourself and stay within a reasonable limit of space consumed, such as 1MB. When the user uninstalls your application, these files are removed.</p> 
 ","Context","android.content.Context","class",0
,"Using the Internal Storage","Other useful methods","<h3 id="InternalMethods">Other useful methods</h3> 
 <dl> 
  <dt>
   <code><a href="../../../reference/android/content/Context.html#getFilesDir()">getFilesDir()</a></code>
  </dt> 
  <dd>
   Gets the absolute path to the filesystem directory where your internal files are saved.
  </dd> 
  <dt>
   <code><a href="../../../reference/android/content/Context.html#getDir(java.lang.String, int)">getDir()</a></code>
  </dt> 
  <dd>
   Creates (or opens an existing) directory within your internal storage space.
  </dd> 
  <dt>
   <code><a href="../../../reference/android/content/Context.html#deleteFile(java.lang.String)">deleteFile()</a></code>
  </dt> 
  <dd>
   Deletes a file saved on the internal storage.
  </dd> 
  <dt>
   <code><a href="../../../reference/android/content/Context.html#fileList()">fileList()</a></code>
  </dt> 
  <dd>
   Returns an array of files currently saved by your application.
  </dd> 
 </dl> 
 ","Context","android.content.Context","class",0
,"Using the External Storage","Accessing files on external storage","<h3 id="AccessingExtFiles">Accessing files on external storage</h3> 
 <p>If you're using API Level 8 or greater, use <code><a href="../../../reference/android/content/Context.html#getExternalFilesDir(java.lang.String)">getExternalFilesDir()</a></code> to open a <code><a href="../../../reference/java/io/File.html">File</a></code> that represents the external storage directory where you should save your files. This method takes a <code>type</code> parameter that specifies the type of subdirectory you want, such as <code><a href="../../../reference/android/os/Environment.html#DIRECTORY_MUSIC">DIRECTORY_MUSIC</a></code> and <code><a href="../../../reference/android/os/Environment.html#DIRECTORY_RINGTONES">DIRECTORY_RINGTONES</a></code> (pass <code>null</code> to receive the root of your application's file directory). This method will create the appropriate directory if necessary. By specifying the type of directory, you ensure that the Android's media scanner will properly categorize your files in the system (for example, ringtones are identified as ringtones and not music). If the user uninstalls your application, this directory and all its contents will be deleted.</p> 
 <p>If you're using API Level 7 or lower, use <code><a href="../../../reference/android/os/Environment.html#getExternalStorageDirectory()">getExternalStorageDirectory()</a></code>, to open a <code><a href="../../../reference/java/io/File.html">File</a></code> representing the root of the external storage. You should then write your data in the following directory:</p> 
 <pre class="no-pretty-print classic">
/Android/data/<em>&lt;package_name&gt;</em>/files/
</pre> 
 <p>The <code><em>&lt;package_name&gt;</em></code> is your Java-style package name, such as &quot;<code>com.example.android.app</code>&quot;. If the user's device is running API Level 8 or greater and they uninstall your application, this directory and all its contents will be deleted.</p> 
 <div class="sidebox-wrapper" style="margin-top:3em"> 
  <div class="sidebox"> 
   ","Context","android.content.Context","class",0
,"Using the External Storage","Saving cache files","<h3 id="ExternalCache">Saving cache files</h3> 
 <p>If you're using API Level 8 or greater, use <code><a href="../../../reference/android/content/Context.html#getExternalCacheDir()">getExternalCacheDir()</a></code> to open a <code><a href="../../../reference/java/io/File.html">File</a></code> that represents the external storage directory where you should save cache files. If the user uninstalls your application, these files will be automatically deleted. However, during the life of your application, you should manage these cache files and remove those that aren't needed in order to preserve file space.</p> 
 <p>If you're using API Level 7 or lower, use <code><a href="../../../reference/android/os/Environment.html#getExternalStorageDirectory()">getExternalStorageDirectory()</a></code> to open a <code><a href="../../../reference/java/io/File.html">File</a></code> that represents the root of the external storage, then write your cache data in the following directory:</p> 
 <pre class="no-pretty-print classic">
/Android/data/<em>&lt;package_name&gt;</em>/cache/
</pre> 
 <p>The <code><em>&lt;package_name&gt;</em></code> is your Java-style package name, such as &quot;<code>com.example.android.app</code>&quot;.</p> 
 ","Context","android.content.Context","class",0
,"Extending BackupAgentHelper","Backing up other files","<h3 id="Files">Backing up other files</h3> 
 <p>When you instantiate a <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code>, you must include the name of one or more files that are saved to your application's <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a> (as specified by <code><a href="../../../reference/android/content/ContextWrapper.html#getFilesDir()">getFilesDir()</a></code>, which is the same location where <code><a href="../../../reference/android/content/Context.html#openFileOutput(java.lang.String, int)">openFileOutput()</a></code> writes files).</p> 
 <p>For example, to backup two files named &quot;scores&quot; and &quot;stats,&quot; a backup agent using <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> looks like this:</p> 
 <pre>
public class MyFileBackupAgent extends BackupAgentHelper {
    // The name of the file
    static final String TOP_SCORES = &quot;scores&quot;;
    static final String PLAYER_STATS = &quot;stats&quot;;

    // A key to uniquely identify the set of backup data
    static final String FILES_BACKUP_KEY = &quot;myfiles&quot;;

    // Allocate a helper and add it to the backup agent
    void onCreate() {
        FileBackupHelper helper = new FileBackupHelper(this, TOP_SCORES, PLAYER_STATS);
        addHelper(FILES_BACKUP_KEY, helper);
    }
}
</pre> 
 <p>The <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code> includes all the code necessary to backup and restore files that are saved to your application's <a href="../../../guide/topics/data/data-storage.html#filesInternal">internal storage</a>..</p> 
 <p>However, reading and writing to files on internal storage is <strong>not threadsafe</strong>. To ensure that your backup agent does not read or write your files at the same time as your activities, you must use synchronized statements each time you perform a read or write. For example, in any Activity where you read and write the file, you need an object to use as the intrinsic lock for the synchronized statements:</p> 
 <pre>
// Object for intrinsic lock
static final Object sDataLock = new Object();
</pre> 
 <p>Then create a synchronized statement with this lock each time you read or write the files. For example, here's a synchronized statement for writing the latest score in a game to a file:</p> 
 <pre>
try {
    synchronized (MyActivity.sDataLock) {
        File dataFile = new File(<code><a href="../../../reference/android/content/Context.html#getFilesDir()">getFilesDir()</a></code>, TOP_SCORES);
        RandomAccessFile raFile = new RandomAccessFile(dataFile, &quot;rw&quot;);
        raFile.writeInt(score);
    }
} catch (IOException e) {
    Log.e(TAG, &quot;Unable to write to file&quot;);
}
</pre> 
 <p>You should synchronize your read statements with the same lock.</p> 
 <p>Then, in your <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code>, you must override <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> to synchronize the backup and restore operations with the same intrinsic lock. For example, the <code>MyFileBackupAgent</code> example from above needs the following methods:</p> 
 <pre>
@Override
public void onBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
          ParcelFileDescriptor newState) throws IOException {
    // Hold the lock while the FileBackupHelper performs backup
    synchronized (MyActivity.sDataLock) {
        super.onBackup(oldState, data, newState);
    }
}

@Override
public void onRestore(BackupDataInput data, int appVersionCode,
        ParcelFileDescriptor newState) throws IOException {
    // Hold the lock while the FileBackupHelper restores the file
    synchronized (MyActivity.sDataLock) {
        super.onRestore(data, appVersionCode, newState);
    }
}
</pre> 
 <p>That's it. All you need to do is add your <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code> in the <code><a href="../../../reference/android/app/backup/BackupAgent.html#onCreate()">onCreate()</a></code> method and override <code><a href="../../../reference/android/app/backup/BackupAgent.html#onBackup(android.os.ParcelFileDescriptor, android.app.backup.BackupDataOutput, android.os.ParcelFileDescriptor)">onBackup()</a></code> and <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> to synchronize read and write operations.</p> 
 <div class="special"> 
  <p>For an example implementation of <code><a href="../../../reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a></code> with <code><a href="../../../reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a></code>, see the <code>FileHelperExampleAgent</code> class in the <a href="../../../resources/samples/BackupRestore/index.html">Backup and Restore</a> sample application.</p> 
 </div> 
 ","ContextWrapper","android.content.ContextWrapper","class",0
,"Data Backup","Checking the Restore Data Version","<h2 id="RestoreVersion">Checking the Restore Data Version</h2> 
 <p>When the Backup Manager saves your data to cloud storage, it automatically includes the version of your application, as defined by your manifest file's <a href="../../../guide/topics/manifest/manifest-element.html#vcode"><code>android:versionCode</code></a> attribute. Before the Backup Manager calls your backup agent to restore your data, it looks at the <a href="../../../guide/topics/manifest/manifest-element.html#vcode"><code>android:versionCode</code></a> of the installed application and compares it to the value recorded in the restore data set. If the version recorded in the restore data set is <em>newer</em> than the application version on the device, then the user has downgraded their application. In this case, the Backup Manager will abort the restore operation for your application and not call your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method, because the restore set is considered meaningless to an older version.</p> 
 <p>You can override this behavior with the <a href="../../../guide/topics/manifest/application-element.html#restoreany"><code>android:restoreAnyVersion</code></a> attribute. This attribute is either &quot;<code>true</code>&quot; or &quot;<code>false</code>&quot; to indicate whether you want to restore the application regardless of the restore set version. The default value is &quot;<code>false</code>&quot;. If you define this to be &quot;<code>true</code>&quot; then the Backup Manager will ignore the <a href="../../../guide/topics/manifest/manifest-element.html#vcode"><code>android:versionCode</code></a> and call your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method in all cases. In doing so, you can manually check for the version difference in your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method and take any steps necessary to make the data compatible if the versions conflict.</p> 
 <p>To help you handle different versions during a restore operation, the <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method passes you the version code included with the restore data set as the <code>appVersionCode</code> parameter. You can then query the current application's version code with the <code><a href="../../../reference/android/content/pm/PackageInfo.html#versionCode">PackageInfo.versionCode</a></code> field. For example:</p> 
 <pre>
PackageInfo info;
try {
    String name = <code><a href="../../../reference/android/content/ContextWrapper.html#getPackageName()">getPackageName</a></code>();
    info = <code><a href="../../../reference/android/content/ContextWrapper.html#getPackageManager()">getPackageManager</a></code>().<code><a href="../../../reference/android/content/pm/PackageManager.html#getPackageInfo(java.lang.String, int)">getPackageInfo</a></code>(name,0);
} catch (NameNotFoundException nnfe) {
    info = null;
}

int version;
if (info != null) {
    version = info.versionCode;
}
</pre> 
 <p>Then simply compare the <code>version</code> acquired from <code><a href="../../../reference/android/content/pm/PackageInfo.html">PackageInfo</a></code> to the <code>appVersionCode</code> passed into <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>. </p> 
 <p class="caution"><strong>Caution:</strong> Be certain you understand the consequences of setting <a href="../../../guide/topics/manifest/application-element.html#restoreany"><code>android:restoreAnyVersion</code></a> to &quot;<code>true</code>&quot; for your application. If each version of your application that supports backup does not properly account for variations in your data format during <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>, then the data on the device could be saved in a format incompatible with the version currently installed on the device.</p> 
 ","ContextWrapper","android.content.ContextWrapper","class",0
,"Data Backup","Checking the Restore Data Version","<h2 id="RestoreVersion">Checking the Restore Data Version</h2> 
 <p>When the Backup Manager saves your data to cloud storage, it automatically includes the version of your application, as defined by your manifest file's <a href="../../../guide/topics/manifest/manifest-element.html#vcode"><code>android:versionCode</code></a> attribute. Before the Backup Manager calls your backup agent to restore your data, it looks at the <a href="../../../guide/topics/manifest/manifest-element.html#vcode"><code>android:versionCode</code></a> of the installed application and compares it to the value recorded in the restore data set. If the version recorded in the restore data set is <em>newer</em> than the application version on the device, then the user has downgraded their application. In this case, the Backup Manager will abort the restore operation for your application and not call your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method, because the restore set is considered meaningless to an older version.</p> 
 <p>You can override this behavior with the <a href="../../../guide/topics/manifest/application-element.html#restoreany"><code>android:restoreAnyVersion</code></a> attribute. This attribute is either &quot;<code>true</code>&quot; or &quot;<code>false</code>&quot; to indicate whether you want to restore the application regardless of the restore set version. The default value is &quot;<code>false</code>&quot;. If you define this to be &quot;<code>true</code>&quot; then the Backup Manager will ignore the <a href="../../../guide/topics/manifest/manifest-element.html#vcode"><code>android:versionCode</code></a> and call your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method in all cases. In doing so, you can manually check for the version difference in your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method and take any steps necessary to make the data compatible if the versions conflict.</p> 
 <p>To help you handle different versions during a restore operation, the <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method passes you the version code included with the restore data set as the <code>appVersionCode</code> parameter. You can then query the current application's version code with the <code><a href="../../../reference/android/content/pm/PackageInfo.html#versionCode">PackageInfo.versionCode</a></code> field. For example:</p> 
 <pre>
PackageInfo info;
try {
    String name = <code><a href="../../../reference/android/content/ContextWrapper.html#getPackageName()">getPackageName</a></code>();
    info = <code><a href="../../../reference/android/content/ContextWrapper.html#getPackageManager()">getPackageManager</a></code>().<code><a href="../../../reference/android/content/pm/PackageManager.html#getPackageInfo(java.lang.String, int)">getPackageInfo</a></code>(name,0);
} catch (NameNotFoundException nnfe) {
    info = null;
}

int version;
if (info != null) {
    version = info.versionCode;
}
</pre> 
 <p>Then simply compare the <code>version</code> acquired from <code><a href="../../../reference/android/content/pm/PackageInfo.html">PackageInfo</a></code> to the <code>appVersionCode</code> passed into <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>. </p> 
 <p class="caution"><strong>Caution:</strong> Be certain you understand the consequences of setting <a href="../../../guide/topics/manifest/application-element.html#restoreany"><code>android:restoreAnyVersion</code></a> to &quot;<code>true</code>&quot; for your application. If each version of your application that supports backup does not properly account for variations in your data format during <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>, then the data on the device could be saved in a format incompatible with the version currently installed on the device.</p> 
 ","PackageManager","android.content.pm.PackageManager","class",0
,"Data Backup","Checking the Restore Data Version","<h2 id="RestoreVersion">Checking the Restore Data Version</h2> 
 <p>When the Backup Manager saves your data to cloud storage, it automatically includes the version of your application, as defined by your manifest file's <a href="../../../guide/topics/manifest/manifest-element.html#vcode"><code>android:versionCode</code></a> attribute. Before the Backup Manager calls your backup agent to restore your data, it looks at the <a href="../../../guide/topics/manifest/manifest-element.html#vcode"><code>android:versionCode</code></a> of the installed application and compares it to the value recorded in the restore data set. If the version recorded in the restore data set is <em>newer</em> than the application version on the device, then the user has downgraded their application. In this case, the Backup Manager will abort the restore operation for your application and not call your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method, because the restore set is considered meaningless to an older version.</p> 
 <p>You can override this behavior with the <a href="../../../guide/topics/manifest/application-element.html#restoreany"><code>android:restoreAnyVersion</code></a> attribute. This attribute is either &quot;<code>true</code>&quot; or &quot;<code>false</code>&quot; to indicate whether you want to restore the application regardless of the restore set version. The default value is &quot;<code>false</code>&quot;. If you define this to be &quot;<code>true</code>&quot; then the Backup Manager will ignore the <a href="../../../guide/topics/manifest/manifest-element.html#vcode"><code>android:versionCode</code></a> and call your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method in all cases. In doing so, you can manually check for the version difference in your <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method and take any steps necessary to make the data compatible if the versions conflict.</p> 
 <p>To help you handle different versions during a restore operation, the <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code> method passes you the version code included with the restore data set as the <code>appVersionCode</code> parameter. You can then query the current application's version code with the <code><a href="../../../reference/android/content/pm/PackageInfo.html#versionCode">PackageInfo.versionCode</a></code> field. For example:</p> 
 <pre>
PackageInfo info;
try {
    String name = <code><a href="../../../reference/android/content/ContextWrapper.html#getPackageName()">getPackageName</a></code>();
    info = <code><a href="../../../reference/android/content/ContextWrapper.html#getPackageManager()">getPackageManager</a></code>().<code><a href="../../../reference/android/content/pm/PackageManager.html#getPackageInfo(java.lang.String, int)">getPackageInfo</a></code>(name,0);
} catch (NameNotFoundException nnfe) {
    info = null;
}

int version;
if (info != null) {
    version = info.versionCode;
}
</pre> 
 <p>Then simply compare the <code>version</code> acquired from <code><a href="../../../reference/android/content/pm/PackageInfo.html">PackageInfo</a></code> to the <code>appVersionCode</code> passed into <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>. </p> 
 <p class="caution"><strong>Caution:</strong> Be certain you understand the consequences of setting <a href="../../../guide/topics/manifest/application-element.html#restoreany"><code>android:restoreAnyVersion</code></a> to &quot;<code>true</code>&quot; for your application. If each version of your application that supports backup does not properly account for variations in your data format during <code><a href="../../../reference/android/app/backup/BackupAgent.html#onRestore(android.app.backup.BackupDataInput, int, android.os.ParcelFileDescriptor)">onRestore()</a></code>, then the data on the device could be saved in a format incompatible with the version currently installed on the device.</p> 
 ","PackageInfo","android.content.pm.PackageInfo","class",1
,"Using Shared Preferences","User Preferences","<h3>User Preferences</h3> 
   <p>Shared preferences are not strictly for saving &quot;user preferences,&quot; such as what ringtone a user has chosen. If you're interested in creating user preferences for your application, see <code><a href="../../../reference/android/preference/PreferenceActivity.html">PreferenceActivity</a></code>, which provides an Activity framework for you to create user preferences, which will be automatically persisted (using shared preferences).</p> 
  </div> 
 </div> 
 <p>To get a <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> object for your application, use one of two methods:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/content/Context.html#getSharedPreferences(java.lang.String, int)">getSharedPreferences()</a></code> - Use this if you need multiple preferences files identified by name, which you specify with the first parameter.</li> 
  <li><code><a href="../../../reference/android/app/Activity.html#getPreferences(int)">getPreferences()</a></code> - Use this if you need only one preferences file for your Activity. Because this will be the only preferences file for your Activity, you don't supply a name.</li> 
 </ul> 
 <p>To write values:</p> 
 <ol> 
  <li>Call <code><a href="../../../reference/android/content/SharedPreferences.html#edit()">edit()</a></code> to get a <code><a href="../../../reference/android/content/SharedPreferences.Editor.html">SharedPreferences.Editor</a></code>.</li> 
  <li>Add values with methods such as <code><a href="../../../reference/android/content/SharedPreferences.Editor.html#putBoolean(java.lang.String, boolean)">putBoolean()</a></code> and <code><a href="../../../reference/android/content/SharedPreferences.Editor.html#putString(java.lang.String, java.lang.String)">putString()</a></code>.</li> 
  <li>Commit the new values with <code><a href="../../../reference/android/content/SharedPreferences.Editor.html#commit()">commit()</a></code></li> 
 </ol> 
 <p>To read values, use <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> methods such as <code><a href="../../../reference/android/content/SharedPreferences.html#getBoolean(java.lang.String, boolean)">getBoolean()</a></code> and <code><a href="../../../reference/android/content/SharedPreferences.html#getString(java.lang.String, java.lang.String)">getString()</a></code>.</p> 
 <p> Here is an example that saves a preference for silent keypress mode in a calculator: </p> 
 <pre>
public class Calc extends Activity {
    public static final String PREFS_NAME = &quot;MyPrefsFile&quot;;

    @Override
    protected void onCreate(Bundle state){
       super.onCreate(state);
       . . .

       // Restore preferences
       SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
       boolean silent = settings.getBoolean(&quot;silentMode&quot;, false);
       setSilent(silent);
    }

    @Override
    protected void onStop(){
       super.onStop();

      // We need an Editor object to make preference changes.
      // All objects are from android.context.Context
      SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
      SharedPreferences.Editor editor = settings.edit();
      editor.putBoolean(&quot;silentMode&quot;, mSilentMode);

      // Commit the edits!
      editor.commit();
    }
}
</pre> 
 <a name="files"></a> 
 ","Editor","android.content.SharedPreferences.Editor","class",0
,"Using Shared Preferences","User Preferences","<h3>User Preferences</h3> 
   <p>Shared preferences are not strictly for saving &quot;user preferences,&quot; such as what ringtone a user has chosen. If you're interested in creating user preferences for your application, see <code><a href="../../../reference/android/preference/PreferenceActivity.html">PreferenceActivity</a></code>, which provides an Activity framework for you to create user preferences, which will be automatically persisted (using shared preferences).</p> 
  </div> 
 </div> 
 <p>To get a <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> object for your application, use one of two methods:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/content/Context.html#getSharedPreferences(java.lang.String, int)">getSharedPreferences()</a></code> - Use this if you need multiple preferences files identified by name, which you specify with the first parameter.</li> 
  <li><code><a href="../../../reference/android/app/Activity.html#getPreferences(int)">getPreferences()</a></code> - Use this if you need only one preferences file for your Activity. Because this will be the only preferences file for your Activity, you don't supply a name.</li> 
 </ul> 
 <p>To write values:</p> 
 <ol> 
  <li>Call <code><a href="../../../reference/android/content/SharedPreferences.html#edit()">edit()</a></code> to get a <code><a href="../../../reference/android/content/SharedPreferences.Editor.html">SharedPreferences.Editor</a></code>.</li> 
  <li>Add values with methods such as <code><a href="../../../reference/android/content/SharedPreferences.Editor.html#putBoolean(java.lang.String, boolean)">putBoolean()</a></code> and <code><a href="../../../reference/android/content/SharedPreferences.Editor.html#putString(java.lang.String, java.lang.String)">putString()</a></code>.</li> 
  <li>Commit the new values with <code><a href="../../../reference/android/content/SharedPreferences.Editor.html#commit()">commit()</a></code></li> 
 </ol> 
 <p>To read values, use <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> methods such as <code><a href="../../../reference/android/content/SharedPreferences.html#getBoolean(java.lang.String, boolean)">getBoolean()</a></code> and <code><a href="../../../reference/android/content/SharedPreferences.html#getString(java.lang.String, java.lang.String)">getString()</a></code>.</p> 
 <p> Here is an example that saves a preference for silent keypress mode in a calculator: </p> 
 <pre>
public class Calc extends Activity {
    public static final String PREFS_NAME = &quot;MyPrefsFile&quot;;

    @Override
    protected void onCreate(Bundle state){
       super.onCreate(state);
       . . .

       // Restore preferences
       SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
       boolean silent = settings.getBoolean(&quot;silentMode&quot;, false);
       setSilent(silent);
    }

    @Override
    protected void onStop(){
       super.onStop();

      // We need an Editor object to make preference changes.
      // All objects are from android.context.Context
      SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
      SharedPreferences.Editor editor = settings.edit();
      editor.putBoolean(&quot;silentMode&quot;, mSilentMode);

      // Commit the edits!
      editor.commit();
    }
}
</pre> 
 <a name="files"></a> 
 ","PreferenceActivity","android.preference.PreferenceActivity","class",0
,"Using Shared Preferences","User Preferences","<h3>User Preferences</h3> 
   <p>Shared preferences are not strictly for saving &quot;user preferences,&quot; such as what ringtone a user has chosen. If you're interested in creating user preferences for your application, see <code><a href="../../../reference/android/preference/PreferenceActivity.html">PreferenceActivity</a></code>, which provides an Activity framework for you to create user preferences, which will be automatically persisted (using shared preferences).</p> 
  </div> 
 </div> 
 <p>To get a <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> object for your application, use one of two methods:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/content/Context.html#getSharedPreferences(java.lang.String, int)">getSharedPreferences()</a></code> - Use this if you need multiple preferences files identified by name, which you specify with the first parameter.</li> 
  <li><code><a href="../../../reference/android/app/Activity.html#getPreferences(int)">getPreferences()</a></code> - Use this if you need only one preferences file for your Activity. Because this will be the only preferences file for your Activity, you don't supply a name.</li> 
 </ul> 
 <p>To write values:</p> 
 <ol> 
  <li>Call <code><a href="../../../reference/android/content/SharedPreferences.html#edit()">edit()</a></code> to get a <code><a href="../../../reference/android/content/SharedPreferences.Editor.html">SharedPreferences.Editor</a></code>.</li> 
  <li>Add values with methods such as <code><a href="../../../reference/android/content/SharedPreferences.Editor.html#putBoolean(java.lang.String, boolean)">putBoolean()</a></code> and <code><a href="../../../reference/android/content/SharedPreferences.Editor.html#putString(java.lang.String, java.lang.String)">putString()</a></code>.</li> 
  <li>Commit the new values with <code><a href="../../../reference/android/content/SharedPreferences.Editor.html#commit()">commit()</a></code></li> 
 </ol> 
 <p>To read values, use <code><a href="../../../reference/android/content/SharedPreferences.html">SharedPreferences</a></code> methods such as <code><a href="../../../reference/android/content/SharedPreferences.html#getBoolean(java.lang.String, boolean)">getBoolean()</a></code> and <code><a href="../../../reference/android/content/SharedPreferences.html#getString(java.lang.String, java.lang.String)">getString()</a></code>.</p> 
 <p> Here is an example that saves a preference for silent keypress mode in a calculator: </p> 
 <pre>
public class Calc extends Activity {
    public static final String PREFS_NAME = &quot;MyPrefsFile&quot;;

    @Override
    protected void onCreate(Bundle state){
       super.onCreate(state);
       . . .

       // Restore preferences
       SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
       boolean silent = settings.getBoolean(&quot;silentMode&quot;, false);
       setSilent(silent);
    }

    @Override
    protected void onStop(){
       super.onStop();

      // We need an Editor object to make preference changes.
      // All objects are from android.context.Context
      SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
      SharedPreferences.Editor editor = settings.edit();
      editor.putBoolean(&quot;silentMode&quot;, mSilentMode);

      // Commit the edits!
      editor.commit();
    }
}
</pre> 
 <a name="files"></a> 
 ","Activity","android.app.Activity","class",0
,"Storage Options","Using the Internal Storage","<h2 id="filesInternal">Using the Internal Storage</h2> 
 <p>You can save files directly on the device's internal storage. By default, files saved to the internal storage are private to your application and other applications cannot access them (nor can the user). When the user uninstalls your application, these files are removed.</p> 
 <p>To create and write a private file to the internal storage:</p> 
 <ol> 
  <li>Call <code><a href="../../../reference/android/content/Context.html#openFileOutput(java.lang.String, int)">openFileOutput()</a></code> with the name of the file and the operating mode. This returns a <code><a href="../../../reference/java/io/FileOutputStream.html">FileOutputStream</a></code>.</li> 
  <li>Write to the file with <code><a href="../../../reference/java/io/OutputStream.html#write(byte[])">write()</a></code>.</li> 
  <li>Close the stream with <code><a href="../../../reference/java/io/FileOutputStream.html#close()">close()</a></code>.</li> 
 </ol> 
 <p>For example:</p> 
 <pre>
String FILENAME = &quot;hello_file&quot;;
String string = &quot;hello world!&quot;;

FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);
fos.write(string.getBytes());
fos.close();
</pre> 
 <p><code><a href="../../../reference/android/content/Context.html#MODE_PRIVATE">MODE_PRIVATE</a></code> will create the file (or replace a file of the same name) and make it private to your application. Other modes available are: <code><a href="../../../reference/android/content/Context.html#MODE_APPEND">MODE_APPEND</a></code>, <code><a href="../../../reference/android/content/Context.html#MODE_WORLD_READABLE">MODE_WORLD_READABLE</a></code>, and <code><a href="../../../reference/android/content/Context.html#MODE_WORLD_WRITEABLE">MODE_WORLD_WRITEABLE</a></code>.</p> 
 <p>To read a file from internal storage:</p> 
 <ol> 
  <li>Call <code><a href="../../../reference/android/content/Context.html#openFileInput(java.lang.String)">openFileInput()</a></code> and pass it the name of the file to read. This returns a <code><a href="../../../reference/java/io/FileInputStream.html">FileInputStream</a></code>.</li> 
  <li>Read bytes from the file with <code><a href="../../../reference/java/io/FileInputStream.html#read(byte[], int, int)">read()</a></code>.</li> 
  <li>Then close the stream with <code><a href="../../../reference/java/io/FileInputStream.html#close()">close()</a></code>.</li> 
 </ol> 
 <p class="note"><strong>Tip:</strong> If you want to save a static file in your application at compile time, save the file in your project <code>res/raw/</code> directory. You can open it with <code><a href="../../../reference/android/content/res/Resources.html#openRawResource(int)">openRawResource()</a></code>, passing the <code>R.raw.<em>&lt;filename&gt;</em></code> resource ID. This method returns an <code><a href="../../../reference/java/io/InputStream.html">InputStream</a></code> that you can use to read the file (but you cannot write to the original file). </p> 
 ","OutputStream","java.io.OutputStream","class",1
,"Storage Options","Using the Internal Storage","<h2 id="filesInternal">Using the Internal Storage</h2> 
 <p>You can save files directly on the device's internal storage. By default, files saved to the internal storage are private to your application and other applications cannot access them (nor can the user). When the user uninstalls your application, these files are removed.</p> 
 <p>To create and write a private file to the internal storage:</p> 
 <ol> 
  <li>Call <code><a href="../../../reference/android/content/Context.html#openFileOutput(java.lang.String, int)">openFileOutput()</a></code> with the name of the file and the operating mode. This returns a <code><a href="../../../reference/java/io/FileOutputStream.html">FileOutputStream</a></code>.</li> 
  <li>Write to the file with <code><a href="../../../reference/java/io/OutputStream.html#write(byte[])">write()</a></code>.</li> 
  <li>Close the stream with <code><a href="../../../reference/java/io/FileOutputStream.html#close()">close()</a></code>.</li> 
 </ol> 
 <p>For example:</p> 
 <pre>
String FILENAME = &quot;hello_file&quot;;
String string = &quot;hello world!&quot;;

FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);
fos.write(string.getBytes());
fos.close();
</pre> 
 <p><code><a href="../../../reference/android/content/Context.html#MODE_PRIVATE">MODE_PRIVATE</a></code> will create the file (or replace a file of the same name) and make it private to your application. Other modes available are: <code><a href="../../../reference/android/content/Context.html#MODE_APPEND">MODE_APPEND</a></code>, <code><a href="../../../reference/android/content/Context.html#MODE_WORLD_READABLE">MODE_WORLD_READABLE</a></code>, and <code><a href="../../../reference/android/content/Context.html#MODE_WORLD_WRITEABLE">MODE_WORLD_WRITEABLE</a></code>.</p> 
 <p>To read a file from internal storage:</p> 
 <ol> 
  <li>Call <code><a href="../../../reference/android/content/Context.html#openFileInput(java.lang.String)">openFileInput()</a></code> and pass it the name of the file to read. This returns a <code><a href="../../../reference/java/io/FileInputStream.html">FileInputStream</a></code>.</li> 
  <li>Read bytes from the file with <code><a href="../../../reference/java/io/FileInputStream.html#read(byte[], int, int)">read()</a></code>.</li> 
  <li>Then close the stream with <code><a href="../../../reference/java/io/FileInputStream.html#close()">close()</a></code>.</li> 
 </ol> 
 <p class="note"><strong>Tip:</strong> If you want to save a static file in your application at compile time, save the file in your project <code>res/raw/</code> directory. You can open it with <code><a href="../../../reference/android/content/res/Resources.html#openRawResource(int)">openRawResource()</a></code>, passing the <code>R.raw.<em>&lt;filename&gt;</em></code> resource ID. This method returns an <code><a href="../../../reference/java/io/InputStream.html">InputStream</a></code> that you can use to read the file (but you cannot write to the original file). </p> 
 ","FileOutputStream","java.io.FileOutputStream","class",0
,"Storage Options","Using the Internal Storage","<h2 id="filesInternal">Using the Internal Storage</h2> 
 <p>You can save files directly on the device's internal storage. By default, files saved to the internal storage are private to your application and other applications cannot access them (nor can the user). When the user uninstalls your application, these files are removed.</p> 
 <p>To create and write a private file to the internal storage:</p> 
 <ol> 
  <li>Call <code><a href="../../../reference/android/content/Context.html#openFileOutput(java.lang.String, int)">openFileOutput()</a></code> with the name of the file and the operating mode. This returns a <code><a href="../../../reference/java/io/FileOutputStream.html">FileOutputStream</a></code>.</li> 
  <li>Write to the file with <code><a href="../../../reference/java/io/OutputStream.html#write(byte[])">write()</a></code>.</li> 
  <li>Close the stream with <code><a href="../../../reference/java/io/FileOutputStream.html#close()">close()</a></code>.</li> 
 </ol> 
 <p>For example:</p> 
 <pre>
String FILENAME = &quot;hello_file&quot;;
String string = &quot;hello world!&quot;;

FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);
fos.write(string.getBytes());
fos.close();
</pre> 
 <p><code><a href="../../../reference/android/content/Context.html#MODE_PRIVATE">MODE_PRIVATE</a></code> will create the file (or replace a file of the same name) and make it private to your application. Other modes available are: <code><a href="../../../reference/android/content/Context.html#MODE_APPEND">MODE_APPEND</a></code>, <code><a href="../../../reference/android/content/Context.html#MODE_WORLD_READABLE">MODE_WORLD_READABLE</a></code>, and <code><a href="../../../reference/android/content/Context.html#MODE_WORLD_WRITEABLE">MODE_WORLD_WRITEABLE</a></code>.</p> 
 <p>To read a file from internal storage:</p> 
 <ol> 
  <li>Call <code><a href="../../../reference/android/content/Context.html#openFileInput(java.lang.String)">openFileInput()</a></code> and pass it the name of the file to read. This returns a <code><a href="../../../reference/java/io/FileInputStream.html">FileInputStream</a></code>.</li> 
  <li>Read bytes from the file with <code><a href="../../../reference/java/io/FileInputStream.html#read(byte[], int, int)">read()</a></code>.</li> 
  <li>Then close the stream with <code><a href="../../../reference/java/io/FileInputStream.html#close()">close()</a></code>.</li> 
 </ol> 
 <p class="note"><strong>Tip:</strong> If you want to save a static file in your application at compile time, save the file in your project <code>res/raw/</code> directory. You can open it with <code><a href="../../../reference/android/content/res/Resources.html#openRawResource(int)">openRawResource()</a></code>, passing the <code>R.raw.<em>&lt;filename&gt;</em></code> resource ID. This method returns an <code><a href="../../../reference/java/io/InputStream.html">InputStream</a></code> that you can use to read the file (but you cannot write to the original file). </p> 
 ","FileInputStream","java.io.FileInputStream","class",0
,"Storage Options","Using the Internal Storage","<h2 id="filesInternal">Using the Internal Storage</h2> 
 <p>You can save files directly on the device's internal storage. By default, files saved to the internal storage are private to your application and other applications cannot access them (nor can the user). When the user uninstalls your application, these files are removed.</p> 
 <p>To create and write a private file to the internal storage:</p> 
 <ol> 
  <li>Call <code><a href="../../../reference/android/content/Context.html#openFileOutput(java.lang.String, int)">openFileOutput()</a></code> with the name of the file and the operating mode. This returns a <code><a href="../../../reference/java/io/FileOutputStream.html">FileOutputStream</a></code>.</li> 
  <li>Write to the file with <code><a href="../../../reference/java/io/OutputStream.html#write(byte[])">write()</a></code>.</li> 
  <li>Close the stream with <code><a href="../../../reference/java/io/FileOutputStream.html#close()">close()</a></code>.</li> 
 </ol> 
 <p>For example:</p> 
 <pre>
String FILENAME = &quot;hello_file&quot;;
String string = &quot;hello world!&quot;;

FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);
fos.write(string.getBytes());
fos.close();
</pre> 
 <p><code><a href="../../../reference/android/content/Context.html#MODE_PRIVATE">MODE_PRIVATE</a></code> will create the file (or replace a file of the same name) and make it private to your application. Other modes available are: <code><a href="../../../reference/android/content/Context.html#MODE_APPEND">MODE_APPEND</a></code>, <code><a href="../../../reference/android/content/Context.html#MODE_WORLD_READABLE">MODE_WORLD_READABLE</a></code>, and <code><a href="../../../reference/android/content/Context.html#MODE_WORLD_WRITEABLE">MODE_WORLD_WRITEABLE</a></code>.</p> 
 <p>To read a file from internal storage:</p> 
 <ol> 
  <li>Call <code><a href="../../../reference/android/content/Context.html#openFileInput(java.lang.String)">openFileInput()</a></code> and pass it the name of the file to read. This returns a <code><a href="../../../reference/java/io/FileInputStream.html">FileInputStream</a></code>.</li> 
  <li>Read bytes from the file with <code><a href="../../../reference/java/io/FileInputStream.html#read(byte[], int, int)">read()</a></code>.</li> 
  <li>Then close the stream with <code><a href="../../../reference/java/io/FileInputStream.html#close()">close()</a></code>.</li> 
 </ol> 
 <p class="note"><strong>Tip:</strong> If you want to save a static file in your application at compile time, save the file in your project <code>res/raw/</code> directory. You can open it with <code><a href="../../../reference/android/content/res/Resources.html#openRawResource(int)">openRawResource()</a></code>, passing the <code>R.raw.<em>&lt;filename&gt;</em></code> resource ID. This method returns an <code><a href="../../../reference/java/io/InputStream.html">InputStream</a></code> that you can use to read the file (but you cannot write to the original file). </p> 
 ","InputStream","java.io.InputStream","class",0
,"Storage Options","Using the Internal Storage","<h2 id="filesInternal">Using the Internal Storage</h2> 
 <p>You can save files directly on the device's internal storage. By default, files saved to the internal storage are private to your application and other applications cannot access them (nor can the user). When the user uninstalls your application, these files are removed.</p> 
 <p>To create and write a private file to the internal storage:</p> 
 <ol> 
  <li>Call <code><a href="../../../reference/android/content/Context.html#openFileOutput(java.lang.String, int)">openFileOutput()</a></code> with the name of the file and the operating mode. This returns a <code><a href="../../../reference/java/io/FileOutputStream.html">FileOutputStream</a></code>.</li> 
  <li>Write to the file with <code><a href="../../../reference/java/io/OutputStream.html#write(byte[])">write()</a></code>.</li> 
  <li>Close the stream with <code><a href="../../../reference/java/io/FileOutputStream.html#close()">close()</a></code>.</li> 
 </ol> 
 <p>For example:</p> 
 <pre>
String FILENAME = &quot;hello_file&quot;;
String string = &quot;hello world!&quot;;

FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);
fos.write(string.getBytes());
fos.close();
</pre> 
 <p><code><a href="../../../reference/android/content/Context.html#MODE_PRIVATE">MODE_PRIVATE</a></code> will create the file (or replace a file of the same name) and make it private to your application. Other modes available are: <code><a href="../../../reference/android/content/Context.html#MODE_APPEND">MODE_APPEND</a></code>, <code><a href="../../../reference/android/content/Context.html#MODE_WORLD_READABLE">MODE_WORLD_READABLE</a></code>, and <code><a href="../../../reference/android/content/Context.html#MODE_WORLD_WRITEABLE">MODE_WORLD_WRITEABLE</a></code>.</p> 
 <p>To read a file from internal storage:</p> 
 <ol> 
  <li>Call <code><a href="../../../reference/android/content/Context.html#openFileInput(java.lang.String)">openFileInput()</a></code> and pass it the name of the file to read. This returns a <code><a href="../../../reference/java/io/FileInputStream.html">FileInputStream</a></code>.</li> 
  <li>Read bytes from the file with <code><a href="../../../reference/java/io/FileInputStream.html#read(byte[], int, int)">read()</a></code>.</li> 
  <li>Then close the stream with <code><a href="../../../reference/java/io/FileInputStream.html#close()">close()</a></code>.</li> 
 </ol> 
 <p class="note"><strong>Tip:</strong> If you want to save a static file in your application at compile time, save the file in your project <code>res/raw/</code> directory. You can open it with <code><a href="../../../reference/android/content/res/Resources.html#openRawResource(int)">openRawResource()</a></code>, passing the <code>R.raw.<em>&lt;filename&gt;</em></code> resource ID. This method returns an <code><a href="../../../reference/java/io/InputStream.html">InputStream</a></code> that you can use to read the file (but you cannot write to the original file). </p> 
 ","Resources","android.content.res.Resources","class",0
,"Using the Internal Storage","Saving cache files","<h3 id="InternalCache">Saving cache files</h3> 
 <p>If you'd like to cache some data, rather than store it persistently, you should use <code><a href="../../../reference/android/content/Context.html#getCacheDir()">getCacheDir()</a></code> to open a <code><a href="../../../reference/java/io/File.html">File</a></code> that represents the internal directory where your application should save temporary cache files.</p> 
 <p>When the device is low on internal storage space, Android may delete these cache files to recover space. However, you should not rely on the system to clean up these files for you. You should always maintain the cache files yourself and stay within a reasonable limit of space consumed, such as 1MB. When the user uninstalls your application, these files are removed.</p> 
 ","File","java.io.File","class",1
,"Using the External Storage","Accessing files on external storage","<h3 id="AccessingExtFiles">Accessing files on external storage</h3> 
 <p>If you're using API Level 8 or greater, use <code><a href="../../../reference/android/content/Context.html#getExternalFilesDir(java.lang.String)">getExternalFilesDir()</a></code> to open a <code><a href="../../../reference/java/io/File.html">File</a></code> that represents the external storage directory where you should save your files. This method takes a <code>type</code> parameter that specifies the type of subdirectory you want, such as <code><a href="../../../reference/android/os/Environment.html#DIRECTORY_MUSIC">DIRECTORY_MUSIC</a></code> and <code><a href="../../../reference/android/os/Environment.html#DIRECTORY_RINGTONES">DIRECTORY_RINGTONES</a></code> (pass <code>null</code> to receive the root of your application's file directory). This method will create the appropriate directory if necessary. By specifying the type of directory, you ensure that the Android's media scanner will properly categorize your files in the system (for example, ringtones are identified as ringtones and not music). If the user uninstalls your application, this directory and all its contents will be deleted.</p> 
 <p>If you're using API Level 7 or lower, use <code><a href="../../../reference/android/os/Environment.html#getExternalStorageDirectory()">getExternalStorageDirectory()</a></code>, to open a <code><a href="../../../reference/java/io/File.html">File</a></code> representing the root of the external storage. You should then write your data in the following directory:</p> 
 <pre class="no-pretty-print classic">
/Android/data/<em>&lt;package_name&gt;</em>/files/
</pre> 
 <p>The <code><em>&lt;package_name&gt;</em></code> is your Java-style package name, such as &quot;<code>com.example.android.app</code>&quot;. If the user's device is running API Level 8 or greater and they uninstall your application, this directory and all its contents will be deleted.</p> 
 <div class="sidebox-wrapper" style="margin-top:3em"> 
  <div class="sidebox"> 
   ","File","java.io.File","class",1
,"Using the External Storage","Saving files that should be shared","<h3 id="SavingSharedFiles">Saving files that should be shared</h3> 
 <p>If you want to save files that are not specific to your application and that should <em>not</em> be deleted when your application is uninstalled, save them to one of the public directories on the external storage. These directories lay at the root of the external storage, such as <code>Music/</code>, <code>Pictures/</code>, <code>Ringtones/</code>, and others.</p> 
 <p>In API Level 8 or greater, use <code><a href="../../../reference/android/os/Environment.html#getExternalStoragePublicDirectory(java.lang.String)">getExternalStoragePublicDirectory()</a></code>, passing it the type of public directory you want, such as <code><a href="../../../reference/android/os/Environment.html#DIRECTORY_MUSIC">DIRECTORY_MUSIC</a></code>, <code><a href="../../../reference/android/os/Environment.html#DIRECTORY_PICTURES">DIRECTORY_PICTURES</a></code>, <code><a href="../../../reference/android/os/Environment.html#DIRECTORY_RINGTONES">DIRECTORY_RINGTONES</a></code>, or others. This method will create the appropriate directory if necessary.</p> 
 <p>If you're using API Level 7 or lower, use <code><a href="../../../reference/android/os/Environment.html#getExternalStorageDirectory()">getExternalStorageDirectory()</a></code> to open a <code><a href="../../../reference/java/io/File.html">File</a></code> that represents the root of the external storage, then save your shared files in one of the following directories:</p> 
 <ul class="nolist"> 
  <li><code>Music/</code> - Media scanner classifies all media found here as user music.</li> 
  <li><code>Podcasts/</code> - Media scanner classifies all media found here as a podcast.</li> 
  <li><code>Ringtones/ </code> - Media scanner classifies all media found here as a ringtone.</li> 
  <li><code>Alarms/</code> - Media scanner classifies all media found here as an alarm sound.</li> 
  <li><code>Notifications/</code> - Media scanner classifies all media found here as a notification sound.</li> 
  <li><code>Pictures/</code> - All photos (excluding those taken with the camera).</li> 
  <li><code>Movies/</code> - All movies (excluding those taken with the camcorder).</li> 
  <li><code>Download/</code> - Miscellaneous downloads.</li> 
 </ul> 
 ","File","java.io.File","class",1
,"Using the External Storage","Saving cache files","<h3 id="ExternalCache">Saving cache files</h3> 
 <p>If you're using API Level 8 or greater, use <code><a href="../../../reference/android/content/Context.html#getExternalCacheDir()">getExternalCacheDir()</a></code> to open a <code><a href="../../../reference/java/io/File.html">File</a></code> that represents the external storage directory where you should save cache files. If the user uninstalls your application, these files will be automatically deleted. However, during the life of your application, you should manage these cache files and remove those that aren't needed in order to preserve file space.</p> 
 <p>If you're using API Level 7 or lower, use <code><a href="../../../reference/android/os/Environment.html#getExternalStorageDirectory()">getExternalStorageDirectory()</a></code> to open a <code><a href="../../../reference/java/io/File.html">File</a></code> that represents the root of the external storage, then write your cache data in the following directory:</p> 
 <pre class="no-pretty-print classic">
/Android/data/<em>&lt;package_name&gt;</em>/cache/
</pre> 
 <p>The <code><em>&lt;package_name&gt;</em></code> is your Java-style package name, such as &quot;<code>com.example.android.app</code>&quot;.</p> 
 ","File","java.io.File","class",1
,"Using the External Storage","Checking media availability","<h3 id="MediaAvail">Checking media availability</h3> 
 <p>Before you do any work with the external storage, you should always call <code><a href="../../../reference/android/os/Environment.html#getExternalStorageState()">getExternalStorageState()</a></code> to check whether the media is available. The media might be mounted to a computer, missing, read-only, or in some other state. For example, here's how you can check the availability:</p> 
 <pre>
boolean mExternalStorageAvailable = false;
boolean mExternalStorageWriteable = false;
String state = Environment.getExternalStorageState();

if (Environment.MEDIA_MOUNTED.equals(state)) {
    // We can read and write the media
    mExternalStorageAvailable = mExternalStorageWriteable = true;
} else if (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {
    // We can only read the media
    mExternalStorageAvailable = true;
    mExternalStorageWriteable = false;
} else {
    // Something else is wrong. It may be one of many other states, but all we need
    //  to know is we can neither read nor write
    mExternalStorageAvailable = mExternalStorageWriteable = false;
}
</pre> 
 <p>This example checks whether the external storage is available to read and write. The <code><a href="../../../reference/android/os/Environment.html#getExternalStorageState()">getExternalStorageState()</a></code> method returns other states that you might want to check, such as whether the media is being shared (connected to a computer), is missing entirely, has been removed badly, etc. You can use these to notify the user with more information when your application needs to access the media.</p> 
 ","Environment","android.os.Environment","class",0
,"Using the External Storage","Accessing files on external storage","<h3 id="AccessingExtFiles">Accessing files on external storage</h3> 
 <p>If you're using API Level 8 or greater, use <code><a href="../../../reference/android/content/Context.html#getExternalFilesDir(java.lang.String)">getExternalFilesDir()</a></code> to open a <code><a href="../../../reference/java/io/File.html">File</a></code> that represents the external storage directory where you should save your files. This method takes a <code>type</code> parameter that specifies the type of subdirectory you want, such as <code><a href="../../../reference/android/os/Environment.html#DIRECTORY_MUSIC">DIRECTORY_MUSIC</a></code> and <code><a href="../../../reference/android/os/Environment.html#DIRECTORY_RINGTONES">DIRECTORY_RINGTONES</a></code> (pass <code>null</code> to receive the root of your application's file directory). This method will create the appropriate directory if necessary. By specifying the type of directory, you ensure that the Android's media scanner will properly categorize your files in the system (for example, ringtones are identified as ringtones and not music). If the user uninstalls your application, this directory and all its contents will be deleted.</p> 
 <p>If you're using API Level 7 or lower, use <code><a href="../../../reference/android/os/Environment.html#getExternalStorageDirectory()">getExternalStorageDirectory()</a></code>, to open a <code><a href="../../../reference/java/io/File.html">File</a></code> representing the root of the external storage. You should then write your data in the following directory:</p> 
 <pre class="no-pretty-print classic">
/Android/data/<em>&lt;package_name&gt;</em>/files/
</pre> 
 <p>The <code><em>&lt;package_name&gt;</em></code> is your Java-style package name, such as &quot;<code>com.example.android.app</code>&quot;. If the user's device is running API Level 8 or greater and they uninstall your application, this directory and all its contents will be deleted.</p> 
 <div class="sidebox-wrapper" style="margin-top:3em"> 
  <div class="sidebox"> 
   ","Environment","android.os.Environment","class",0
,"Using the External Storage","Saving files that should be shared","<h3 id="SavingSharedFiles">Saving files that should be shared</h3> 
 <p>If you want to save files that are not specific to your application and that should <em>not</em> be deleted when your application is uninstalled, save them to one of the public directories on the external storage. These directories lay at the root of the external storage, such as <code>Music/</code>, <code>Pictures/</code>, <code>Ringtones/</code>, and others.</p> 
 <p>In API Level 8 or greater, use <code><a href="../../../reference/android/os/Environment.html#getExternalStoragePublicDirectory(java.lang.String)">getExternalStoragePublicDirectory()</a></code>, passing it the type of public directory you want, such as <code><a href="../../../reference/android/os/Environment.html#DIRECTORY_MUSIC">DIRECTORY_MUSIC</a></code>, <code><a href="../../../reference/android/os/Environment.html#DIRECTORY_PICTURES">DIRECTORY_PICTURES</a></code>, <code><a href="../../../reference/android/os/Environment.html#DIRECTORY_RINGTONES">DIRECTORY_RINGTONES</a></code>, or others. This method will create the appropriate directory if necessary.</p> 
 <p>If you're using API Level 7 or lower, use <code><a href="../../../reference/android/os/Environment.html#getExternalStorageDirectory()">getExternalStorageDirectory()</a></code> to open a <code><a href="../../../reference/java/io/File.html">File</a></code> that represents the root of the external storage, then save your shared files in one of the following directories:</p> 
 <ul class="nolist"> 
  <li><code>Music/</code> - Media scanner classifies all media found here as user music.</li> 
  <li><code>Podcasts/</code> - Media scanner classifies all media found here as a podcast.</li> 
  <li><code>Ringtones/ </code> - Media scanner classifies all media found here as a ringtone.</li> 
  <li><code>Alarms/</code> - Media scanner classifies all media found here as an alarm sound.</li> 
  <li><code>Notifications/</code> - Media scanner classifies all media found here as a notification sound.</li> 
  <li><code>Pictures/</code> - All photos (excluding those taken with the camera).</li> 
  <li><code>Movies/</code> - All movies (excluding those taken with the camcorder).</li> 
  <li><code>Download/</code> - Miscellaneous downloads.</li> 
 </ul> 
 ","Environment","android.os.Environment","class",0
,"Using the External Storage","Saving cache files","<h3 id="ExternalCache">Saving cache files</h3> 
 <p>If you're using API Level 8 or greater, use <code><a href="../../../reference/android/content/Context.html#getExternalCacheDir()">getExternalCacheDir()</a></code> to open a <code><a href="../../../reference/java/io/File.html">File</a></code> that represents the external storage directory where you should save cache files. If the user uninstalls your application, these files will be automatically deleted. However, during the life of your application, you should manage these cache files and remove those that aren't needed in order to preserve file space.</p> 
 <p>If you're using API Level 7 or lower, use <code><a href="../../../reference/android/os/Environment.html#getExternalStorageDirectory()">getExternalStorageDirectory()</a></code> to open a <code><a href="../../../reference/java/io/File.html">File</a></code> that represents the root of the external storage, then write your cache data in the following directory:</p> 
 <pre class="no-pretty-print classic">
/Android/data/<em>&lt;package_name&gt;</em>/cache/
</pre> 
 <p>The <code><em>&lt;package_name&gt;</em></code> is your Java-style package name, such as &quot;<code>com.example.android.app</code>&quot;.</p> 
 ","Environment","android.os.Environment","class",0
,"Storage Options","Using Databases","<h2 id="db">Using Databases</h2> 
 <p>Android provides full support for <a href="http://www.sqlite.org/">SQLite</a> databases. Any databases you create will be accessible by name to any class in the application, but not outside the application.</p> 
 <p>The recommended method to create a new SQLite database is to create a subclass of <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html">SQLiteOpenHelper</a></code> and override the <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html#onCreate(android.database.sqlite.SQLiteDatabase)">onCreate()</a></code> method, in which you can execute a SQLite command to create tables in the database. For example:</p> 
 <pre>
public class DictionaryOpenHelper extends SQLiteOpenHelper {

    private static final int DATABASE_VERSION = 2;
    private static final String DICTIONARY_TABLE_NAME = &quot;dictionary&quot;;
    private static final String DICTIONARY_TABLE_CREATE =
                &quot;CREATE TABLE &quot; + DICTIONARY_TABLE_NAME + &quot; (&quot; +
                KEY_WORD + &quot; TEXT, &quot; +
                KEY_DEFINITION + &quot; TEXT);&quot;;

    DictionaryOpenHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(DICTIONARY_TABLE_CREATE);
    }
}
</pre> 
 <p>You can then get an instance of your <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html">SQLiteOpenHelper</a></code> implementation using the constructor you've defined. To write to and read from the database, call <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html#getWritableDatabase()">getWritableDatabase()</a></code> and <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html#getReadableDatabase()">getReadableDatabase()</a></code>, respectively. These both return a <code><a href="../../../reference/android/database/sqlite/SQLiteDatabase.html">SQLiteDatabase</a></code> object that represents the database and provides methods for SQLite operations.</p> 
 <div class="sidebox-wrapper"> 
  <div class="sidebox"> 
   <p>Android does not impose any limitations beyond the standard SQLite concepts. We do recommend including an autoincrement value key field that can be used as a unique ID to quickly find a record. This is not required for private data, but if you implement a <a href="../../../guide/topics/providers/content-providers.html">content provider</a>, you must include a unique ID using the <code><a href="../../../reference/android/provider/BaseColumns.html#_ID">BaseColumns._ID</a></code> constant. </p> 
  </div> 
 </div> 
 <p>You can execute SQLite queries using the <code><a href="../../../reference/android/database/sqlite/SQLiteDatabase.html">SQLiteDatabase</a></code> <code><a href="../../../reference/android/database/sqlite/SQLiteDatabase.html#query(boolean, java.lang.String, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String, java.lang.String, java.lang.String, java.lang.String)">query()</a></code> methods, which accept various query parameters, such as the table to query, the projection, selection, columns, grouping, and others. For complex queries, such as those that require column aliases, you should use <code><a href="../../../reference/android/database/sqlite/SQLiteQueryBuilder.html">SQLiteQueryBuilder</a></code>, which provides several convienent methods for building queries.</p> 
 <p>Every SQLite query will return a <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code> that points to all the rows found by the query. The <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code> is always the mechanism with which you can navigate results from a database query and read rows and columns.</p> 
 <p>For sample apps that demonstrate how to use SQLite databases in Android, see the <a href="../../../resources/samples/NotePad/index.html">Note Pad</a> and <a href="../../../resources/samples/SearchableDictionary/index.html">Searchable Dictionary</a> applications.</p> 
 ","SQLiteDatabase","android.database.sqlite.SQLiteDatabase","class",1
,"Storage Options","Using Databases","<h2 id="db">Using Databases</h2> 
 <p>Android provides full support for <a href="http://www.sqlite.org/">SQLite</a> databases. Any databases you create will be accessible by name to any class in the application, but not outside the application.</p> 
 <p>The recommended method to create a new SQLite database is to create a subclass of <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html">SQLiteOpenHelper</a></code> and override the <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html#onCreate(android.database.sqlite.SQLiteDatabase)">onCreate()</a></code> method, in which you can execute a SQLite command to create tables in the database. For example:</p> 
 <pre>
public class DictionaryOpenHelper extends SQLiteOpenHelper {

    private static final int DATABASE_VERSION = 2;
    private static final String DICTIONARY_TABLE_NAME = &quot;dictionary&quot;;
    private static final String DICTIONARY_TABLE_CREATE =
                &quot;CREATE TABLE &quot; + DICTIONARY_TABLE_NAME + &quot; (&quot; +
                KEY_WORD + &quot; TEXT, &quot; +
                KEY_DEFINITION + &quot; TEXT);&quot;;

    DictionaryOpenHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(DICTIONARY_TABLE_CREATE);
    }
}
</pre> 
 <p>You can then get an instance of your <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html">SQLiteOpenHelper</a></code> implementation using the constructor you've defined. To write to and read from the database, call <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html#getWritableDatabase()">getWritableDatabase()</a></code> and <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html#getReadableDatabase()">getReadableDatabase()</a></code>, respectively. These both return a <code><a href="../../../reference/android/database/sqlite/SQLiteDatabase.html">SQLiteDatabase</a></code> object that represents the database and provides methods for SQLite operations.</p> 
 <div class="sidebox-wrapper"> 
  <div class="sidebox"> 
   <p>Android does not impose any limitations beyond the standard SQLite concepts. We do recommend including an autoincrement value key field that can be used as a unique ID to quickly find a record. This is not required for private data, but if you implement a <a href="../../../guide/topics/providers/content-providers.html">content provider</a>, you must include a unique ID using the <code><a href="../../../reference/android/provider/BaseColumns.html#_ID">BaseColumns._ID</a></code> constant. </p> 
  </div> 
 </div> 
 <p>You can execute SQLite queries using the <code><a href="../../../reference/android/database/sqlite/SQLiteDatabase.html">SQLiteDatabase</a></code> <code><a href="../../../reference/android/database/sqlite/SQLiteDatabase.html#query(boolean, java.lang.String, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String, java.lang.String, java.lang.String, java.lang.String)">query()</a></code> methods, which accept various query parameters, such as the table to query, the projection, selection, columns, grouping, and others. For complex queries, such as those that require column aliases, you should use <code><a href="../../../reference/android/database/sqlite/SQLiteQueryBuilder.html">SQLiteQueryBuilder</a></code>, which provides several convienent methods for building queries.</p> 
 <p>Every SQLite query will return a <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code> that points to all the rows found by the query. The <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code> is always the mechanism with which you can navigate results from a database query and read rows and columns.</p> 
 <p>For sample apps that demonstrate how to use SQLite databases in Android, see the <a href="../../../resources/samples/NotePad/index.html">Note Pad</a> and <a href="../../../resources/samples/SearchableDictionary/index.html">Searchable Dictionary</a> applications.</p> 
 ","SQLiteQueryBuilder","android.database.sqlite.SQLiteQueryBuilder","class",0
,"Storage Options","Using Databases","<h2 id="db">Using Databases</h2> 
 <p>Android provides full support for <a href="http://www.sqlite.org/">SQLite</a> databases. Any databases you create will be accessible by name to any class in the application, but not outside the application.</p> 
 <p>The recommended method to create a new SQLite database is to create a subclass of <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html">SQLiteOpenHelper</a></code> and override the <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html#onCreate(android.database.sqlite.SQLiteDatabase)">onCreate()</a></code> method, in which you can execute a SQLite command to create tables in the database. For example:</p> 
 <pre>
public class DictionaryOpenHelper extends SQLiteOpenHelper {

    private static final int DATABASE_VERSION = 2;
    private static final String DICTIONARY_TABLE_NAME = &quot;dictionary&quot;;
    private static final String DICTIONARY_TABLE_CREATE =
                &quot;CREATE TABLE &quot; + DICTIONARY_TABLE_NAME + &quot; (&quot; +
                KEY_WORD + &quot; TEXT, &quot; +
                KEY_DEFINITION + &quot; TEXT);&quot;;

    DictionaryOpenHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(DICTIONARY_TABLE_CREATE);
    }
}
</pre> 
 <p>You can then get an instance of your <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html">SQLiteOpenHelper</a></code> implementation using the constructor you've defined. To write to and read from the database, call <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html#getWritableDatabase()">getWritableDatabase()</a></code> and <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html#getReadableDatabase()">getReadableDatabase()</a></code>, respectively. These both return a <code><a href="../../../reference/android/database/sqlite/SQLiteDatabase.html">SQLiteDatabase</a></code> object that represents the database and provides methods for SQLite operations.</p> 
 <div class="sidebox-wrapper"> 
  <div class="sidebox"> 
   <p>Android does not impose any limitations beyond the standard SQLite concepts. We do recommend including an autoincrement value key field that can be used as a unique ID to quickly find a record. This is not required for private data, but if you implement a <a href="../../../guide/topics/providers/content-providers.html">content provider</a>, you must include a unique ID using the <code><a href="../../../reference/android/provider/BaseColumns.html#_ID">BaseColumns._ID</a></code> constant. </p> 
  </div> 
 </div> 
 <p>You can execute SQLite queries using the <code><a href="../../../reference/android/database/sqlite/SQLiteDatabase.html">SQLiteDatabase</a></code> <code><a href="../../../reference/android/database/sqlite/SQLiteDatabase.html#query(boolean, java.lang.String, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String, java.lang.String, java.lang.String, java.lang.String)">query()</a></code> methods, which accept various query parameters, such as the table to query, the projection, selection, columns, grouping, and others. For complex queries, such as those that require column aliases, you should use <code><a href="../../../reference/android/database/sqlite/SQLiteQueryBuilder.html">SQLiteQueryBuilder</a></code>, which provides several convienent methods for building queries.</p> 
 <p>Every SQLite query will return a <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code> that points to all the rows found by the query. The <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code> is always the mechanism with which you can navigate results from a database query and read rows and columns.</p> 
 <p>For sample apps that demonstrate how to use SQLite databases in Android, see the <a href="../../../resources/samples/NotePad/index.html">Note Pad</a> and <a href="../../../resources/samples/SearchableDictionary/index.html">Searchable Dictionary</a> applications.</p> 
 ","SQLiteOpenHelper","android.database.sqlite.SQLiteOpenHelper","class",0
,"Storage Options","Using Databases","<h2 id="db">Using Databases</h2> 
 <p>Android provides full support for <a href="http://www.sqlite.org/">SQLite</a> databases. Any databases you create will be accessible by name to any class in the application, but not outside the application.</p> 
 <p>The recommended method to create a new SQLite database is to create a subclass of <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html">SQLiteOpenHelper</a></code> and override the <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html#onCreate(android.database.sqlite.SQLiteDatabase)">onCreate()</a></code> method, in which you can execute a SQLite command to create tables in the database. For example:</p> 
 <pre>
public class DictionaryOpenHelper extends SQLiteOpenHelper {

    private static final int DATABASE_VERSION = 2;
    private static final String DICTIONARY_TABLE_NAME = &quot;dictionary&quot;;
    private static final String DICTIONARY_TABLE_CREATE =
                &quot;CREATE TABLE &quot; + DICTIONARY_TABLE_NAME + &quot; (&quot; +
                KEY_WORD + &quot; TEXT, &quot; +
                KEY_DEFINITION + &quot; TEXT);&quot;;

    DictionaryOpenHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(DICTIONARY_TABLE_CREATE);
    }
}
</pre> 
 <p>You can then get an instance of your <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html">SQLiteOpenHelper</a></code> implementation using the constructor you've defined. To write to and read from the database, call <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html#getWritableDatabase()">getWritableDatabase()</a></code> and <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html#getReadableDatabase()">getReadableDatabase()</a></code>, respectively. These both return a <code><a href="../../../reference/android/database/sqlite/SQLiteDatabase.html">SQLiteDatabase</a></code> object that represents the database and provides methods for SQLite operations.</p> 
 <div class="sidebox-wrapper"> 
  <div class="sidebox"> 
   <p>Android does not impose any limitations beyond the standard SQLite concepts. We do recommend including an autoincrement value key field that can be used as a unique ID to quickly find a record. This is not required for private data, but if you implement a <a href="../../../guide/topics/providers/content-providers.html">content provider</a>, you must include a unique ID using the <code><a href="../../../reference/android/provider/BaseColumns.html#_ID">BaseColumns._ID</a></code> constant. </p> 
  </div> 
 </div> 
 <p>You can execute SQLite queries using the <code><a href="../../../reference/android/database/sqlite/SQLiteDatabase.html">SQLiteDatabase</a></code> <code><a href="../../../reference/android/database/sqlite/SQLiteDatabase.html#query(boolean, java.lang.String, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String, java.lang.String, java.lang.String, java.lang.String)">query()</a></code> methods, which accept various query parameters, such as the table to query, the projection, selection, columns, grouping, and others. For complex queries, such as those that require column aliases, you should use <code><a href="../../../reference/android/database/sqlite/SQLiteQueryBuilder.html">SQLiteQueryBuilder</a></code>, which provides several convienent methods for building queries.</p> 
 <p>Every SQLite query will return a <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code> that points to all the rows found by the query. The <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code> is always the mechanism with which you can navigate results from a database query and read rows and columns.</p> 
 <p>For sample apps that demonstrate how to use SQLite databases in Android, see the <a href="../../../resources/samples/NotePad/index.html">Note Pad</a> and <a href="../../../resources/samples/SearchableDictionary/index.html">Searchable Dictionary</a> applications.</p> 
 ","BaseColumns","android.provider.BaseColumns","class",1
,"Storage Options","Using Databases","<h2 id="db">Using Databases</h2> 
 <p>Android provides full support for <a href="http://www.sqlite.org/">SQLite</a> databases. Any databases you create will be accessible by name to any class in the application, but not outside the application.</p> 
 <p>The recommended method to create a new SQLite database is to create a subclass of <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html">SQLiteOpenHelper</a></code> and override the <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html#onCreate(android.database.sqlite.SQLiteDatabase)">onCreate()</a></code> method, in which you can execute a SQLite command to create tables in the database. For example:</p> 
 <pre>
public class DictionaryOpenHelper extends SQLiteOpenHelper {

    private static final int DATABASE_VERSION = 2;
    private static final String DICTIONARY_TABLE_NAME = &quot;dictionary&quot;;
    private static final String DICTIONARY_TABLE_CREATE =
                &quot;CREATE TABLE &quot; + DICTIONARY_TABLE_NAME + &quot; (&quot; +
                KEY_WORD + &quot; TEXT, &quot; +
                KEY_DEFINITION + &quot; TEXT);&quot;;

    DictionaryOpenHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(DICTIONARY_TABLE_CREATE);
    }
}
</pre> 
 <p>You can then get an instance of your <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html">SQLiteOpenHelper</a></code> implementation using the constructor you've defined. To write to and read from the database, call <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html#getWritableDatabase()">getWritableDatabase()</a></code> and <code><a href="../../../reference/android/database/sqlite/SQLiteOpenHelper.html#getReadableDatabase()">getReadableDatabase()</a></code>, respectively. These both return a <code><a href="../../../reference/android/database/sqlite/SQLiteDatabase.html">SQLiteDatabase</a></code> object that represents the database and provides methods for SQLite operations.</p> 
 <div class="sidebox-wrapper"> 
  <div class="sidebox"> 
   <p>Android does not impose any limitations beyond the standard SQLite concepts. We do recommend including an autoincrement value key field that can be used as a unique ID to quickly find a record. This is not required for private data, but if you implement a <a href="../../../guide/topics/providers/content-providers.html">content provider</a>, you must include a unique ID using the <code><a href="../../../reference/android/provider/BaseColumns.html#_ID">BaseColumns._ID</a></code> constant. </p> 
  </div> 
 </div> 
 <p>You can execute SQLite queries using the <code><a href="../../../reference/android/database/sqlite/SQLiteDatabase.html">SQLiteDatabase</a></code> <code><a href="../../../reference/android/database/sqlite/SQLiteDatabase.html#query(boolean, java.lang.String, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String, java.lang.String, java.lang.String, java.lang.String)">query()</a></code> methods, which accept various query parameters, such as the table to query, the projection, selection, columns, grouping, and others. For complex queries, such as those that require column aliases, you should use <code><a href="../../../reference/android/database/sqlite/SQLiteQueryBuilder.html">SQLiteQueryBuilder</a></code>, which provides several convienent methods for building queries.</p> 
 <p>Every SQLite query will return a <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code> that points to all the rows found by the query. The <code><a href="../../../reference/android/database/Cursor.html">Cursor</a></code> is always the mechanism with which you can navigate results from a database query and read rows and columns.</p> 
 <p>For sample apps that demonstrate how to use SQLite databases in Android, see the <a href="../../../resources/samples/NotePad/index.html">Note Pad</a> and <a href="../../../resources/samples/SearchableDictionary/index.html">Searchable Dictionary</a> applications.</p> 
 ","Cursor","android.database.Cursor","class",0
,"Storage Options","Using a Network Connection","<h2 id="netw">Using a Network Connection</h2> 
 <!-- TODO MAKE THIS USEFUL!! --> 
 <p>You can use the network (when it's available) to store and retrieve data on your own web-based services. To do network operations, use classes in the following packages:</p> 
 <ul class="no-style"> 
  <li><code><code><a href="../../../reference/java/net/package-summary.html">java.net.*</a></code></code></li> 
  <li><code><code><a href="../../../reference/android/net/package-summary.html">android.net.*</a></code></code></li> 
 </ul> 
</div> 
","package-summary","java.net.package-summary","class",1
,"Storage Options","Using a Network Connection","<h2 id="netw">Using a Network Connection</h2> 
 <!-- TODO MAKE THIS USEFUL!! --> 
 <p>You can use the network (when it's available) to store and retrieve data on your own web-based services. To do network operations, use classes in the following packages:</p> 
 <ul class="no-style"> 
  <li><code><code><a href="../../../reference/java/net/package-summary.html">java.net.*</a></code></code></li> 
  <li><code><code><a href="../../../reference/android/net/package-summary.html">android.net.*</a></code></code></li> 
 </ul> 
</div> 
","package-summary","android.net.package-summary","class",1
,"App Install Location","Applications That Should NOT Install on External Storage","<h2 id="ShouldNot">Applications That Should NOT Install on External Storage</h2> 
 <p>When the user enables USB mass storage to share files with their computer (or otherwise unmounts or removes the external storage), any application installed on the external storage and currently running is killed. The system effectively becomes unaware of the application until mass storage is disabled and the external storage is remounted on the device. Besides killing the application and making it unavailable to the user, this can break some types of applications in a more serious way. In order for your application to consistently behave as expected, you <strong>should not</strong> allow your application to be installed on the external storage if it uses any of the following features, due to the cited consequences when the external storage is unmounted:</p> 
 <dl> 
  <dt>
   Services
  </dt> 
  <dd>
   Your running 
   <code><a href="../../../reference/android/app/Service.html">Service</a></code> will be killed and will not be restarted when external storage is remounted. You can, however, register for the 
   <code><a href="../../../reference/android/content/Intent.html#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE">ACTION_EXTERNAL_APPLICATIONS_AVAILABLE</a></code> broadcast Intent, which will notify your application when applications installed on external storage have become available to the system again. At which time, you can restart your Service.
  </dd> 
  <dt>
   Alarm Services
  </dt> 
  <dd>
   Your alarms registered with 
   <code><a href="../../../reference/android/app/AlarmManager.html">AlarmManager</a></code> will be cancelled. You must manually re-register any alarms when external storage is remounted.
  </dd> 
  <dt>
   Input Method Engines
  </dt> 
  <dd>
   Your 
   <a href="../../../guide/topics/text/creating-input-method.html">IME</a> will be replaced by the default IME. When external storage is remounted, the user can open system settings to enable your IME again.
  </dd> 
  <dt>
   Live Wallpapers
  </dt> 
  <dd>
   Your running 
   <a href="http://android-developers.blogspot.com/2010/02/live-wallpapers.html">Live Wallpaper</a> will be replaced by the default Live Wallpaper. When external storage is remounted, the user can select your Live Wallpaper again.
  </dd> 
  <dt>
   App Widgets
  </dt> 
  <dd>
   Your 
   <a href="../../../guide/topics/appwidgets/index.html">App Widget</a> will be removed from the home screen. When external storage is remounted, your App Widget will 
   <em>not</em> be available for the user to select until the system resets the home application (usually not until a system reboot).
  </dd> 
  <dt>
   Account Managers
  </dt> 
  <dd>
   Your accounts created with 
   <code><a href="../../../reference/android/accounts/AccountManager.html">AccountManager</a></code> will disappear until external storage is remounted.
  </dd> 
  <dt>
   Sync Adapters
  </dt> 
  <dd>
   Your 
   <code><a href="../../../reference/android/content/AbstractThreadedSyncAdapter.html">AbstractThreadedSyncAdapter</a></code> and all its sync functionality will not work until external storage is remounted.
  </dd> 
  <dt>
   Device Administrators
  </dt> 
  <dd>
   Your 
   <code><a href="../../../reference/android/app/admin/DeviceAdminReceiver.html">DeviceAdminReceiver</a></code> and all its admin capabilities will be disabled, which can have unforeseeable consequences for the device functionality, which may persist after external storage is remounted.
  </dd> 
  <dt>
   Broadcast Receivers listening for &quot;boot completed&quot;
  </dt> 
  <dd>
   The system delivers the 
   <code><a href="../../../reference/android/content/Intent.html#ACTION_BOOT_COMPLETED">ACTION_BOOT_COMPLETED</a></code> broadcast before the external storage is mounted to the device. If your application is installed on the external storage, it can never receive this broadcast.
  </dd> 
 </dl> 
 <p>If your application uses any of the features listed above, you <strong>should not</strong> allow your application to install on external storage. By default, the system <em>will not</em> allow your application to install on the external storage, so you don't need to worry about your existing applications. However, if you're certain that your application should never be installed on the external storage, then you should make this clear by declaring <a href="../../../guide/topics/manifest/manifest-element.html#install"><code>android:installLocation</code></a> with a value of &quot;<code>internalOnly</code>&quot;. Though this does not change the default behavior, it explicitly states that your application should only be installed on the internal storage and serves as a reminder to you and other developers that this decision has been made.</p> 
 ","AccountManager","android.accounts.AccountManager","class",1
,"App Install Location","Applications That Should NOT Install on External Storage","<h2 id="ShouldNot">Applications That Should NOT Install on External Storage</h2> 
 <p>When the user enables USB mass storage to share files with their computer (or otherwise unmounts or removes the external storage), any application installed on the external storage and currently running is killed. The system effectively becomes unaware of the application until mass storage is disabled and the external storage is remounted on the device. Besides killing the application and making it unavailable to the user, this can break some types of applications in a more serious way. In order for your application to consistently behave as expected, you <strong>should not</strong> allow your application to be installed on the external storage if it uses any of the following features, due to the cited consequences when the external storage is unmounted:</p> 
 <dl> 
  <dt>
   Services
  </dt> 
  <dd>
   Your running 
   <code><a href="../../../reference/android/app/Service.html">Service</a></code> will be killed and will not be restarted when external storage is remounted. You can, however, register for the 
   <code><a href="../../../reference/android/content/Intent.html#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE">ACTION_EXTERNAL_APPLICATIONS_AVAILABLE</a></code> broadcast Intent, which will notify your application when applications installed on external storage have become available to the system again. At which time, you can restart your Service.
  </dd> 
  <dt>
   Alarm Services
  </dt> 
  <dd>
   Your alarms registered with 
   <code><a href="../../../reference/android/app/AlarmManager.html">AlarmManager</a></code> will be cancelled. You must manually re-register any alarms when external storage is remounted.
  </dd> 
  <dt>
   Input Method Engines
  </dt> 
  <dd>
   Your 
   <a href="../../../guide/topics/text/creating-input-method.html">IME</a> will be replaced by the default IME. When external storage is remounted, the user can open system settings to enable your IME again.
  </dd> 
  <dt>
   Live Wallpapers
  </dt> 
  <dd>
   Your running 
   <a href="http://android-developers.blogspot.com/2010/02/live-wallpapers.html">Live Wallpaper</a> will be replaced by the default Live Wallpaper. When external storage is remounted, the user can select your Live Wallpaper again.
  </dd> 
  <dt>
   App Widgets
  </dt> 
  <dd>
   Your 
   <a href="../../../guide/topics/appwidgets/index.html">App Widget</a> will be removed from the home screen. When external storage is remounted, your App Widget will 
   <em>not</em> be available for the user to select until the system resets the home application (usually not until a system reboot).
  </dd> 
  <dt>
   Account Managers
  </dt> 
  <dd>
   Your accounts created with 
   <code><a href="../../../reference/android/accounts/AccountManager.html">AccountManager</a></code> will disappear until external storage is remounted.
  </dd> 
  <dt>
   Sync Adapters
  </dt> 
  <dd>
   Your 
   <code><a href="../../../reference/android/content/AbstractThreadedSyncAdapter.html">AbstractThreadedSyncAdapter</a></code> and all its sync functionality will not work until external storage is remounted.
  </dd> 
  <dt>
   Device Administrators
  </dt> 
  <dd>
   Your 
   <code><a href="../../../reference/android/app/admin/DeviceAdminReceiver.html">DeviceAdminReceiver</a></code> and all its admin capabilities will be disabled, which can have unforeseeable consequences for the device functionality, which may persist after external storage is remounted.
  </dd> 
  <dt>
   Broadcast Receivers listening for &quot;boot completed&quot;
  </dt> 
  <dd>
   The system delivers the 
   <code><a href="../../../reference/android/content/Intent.html#ACTION_BOOT_COMPLETED">ACTION_BOOT_COMPLETED</a></code> broadcast before the external storage is mounted to the device. If your application is installed on the external storage, it can never receive this broadcast.
  </dd> 
 </dl> 
 <p>If your application uses any of the features listed above, you <strong>should not</strong> allow your application to install on external storage. By default, the system <em>will not</em> allow your application to install on the external storage, so you don't need to worry about your existing applications. However, if you're certain that your application should never be installed on the external storage, then you should make this clear by declaring <a href="../../../guide/topics/manifest/manifest-element.html#install"><code>android:installLocation</code></a> with a value of &quot;<code>internalOnly</code>&quot;. Though this does not change the default behavior, it explicitly states that your application should only be installed on the internal storage and serves as a reminder to you and other developers that this decision has been made.</p> 
 ","DeviceAdminReceiver","android.app.admin.DeviceAdminReceiver","class",1
,"App Install Location","Applications That Should NOT Install on External Storage","<h2 id="ShouldNot">Applications That Should NOT Install on External Storage</h2> 
 <p>When the user enables USB mass storage to share files with their computer (or otherwise unmounts or removes the external storage), any application installed on the external storage and currently running is killed. The system effectively becomes unaware of the application until mass storage is disabled and the external storage is remounted on the device. Besides killing the application and making it unavailable to the user, this can break some types of applications in a more serious way. In order for your application to consistently behave as expected, you <strong>should not</strong> allow your application to be installed on the external storage if it uses any of the following features, due to the cited consequences when the external storage is unmounted:</p> 
 <dl> 
  <dt>
   Services
  </dt> 
  <dd>
   Your running 
   <code><a href="../../../reference/android/app/Service.html">Service</a></code> will be killed and will not be restarted when external storage is remounted. You can, however, register for the 
   <code><a href="../../../reference/android/content/Intent.html#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE">ACTION_EXTERNAL_APPLICATIONS_AVAILABLE</a></code> broadcast Intent, which will notify your application when applications installed on external storage have become available to the system again. At which time, you can restart your Service.
  </dd> 
  <dt>
   Alarm Services
  </dt> 
  <dd>
   Your alarms registered with 
   <code><a href="../../../reference/android/app/AlarmManager.html">AlarmManager</a></code> will be cancelled. You must manually re-register any alarms when external storage is remounted.
  </dd> 
  <dt>
   Input Method Engines
  </dt> 
  <dd>
   Your 
   <a href="../../../guide/topics/text/creating-input-method.html">IME</a> will be replaced by the default IME. When external storage is remounted, the user can open system settings to enable your IME again.
  </dd> 
  <dt>
   Live Wallpapers
  </dt> 
  <dd>
   Your running 
   <a href="http://android-developers.blogspot.com/2010/02/live-wallpapers.html">Live Wallpaper</a> will be replaced by the default Live Wallpaper. When external storage is remounted, the user can select your Live Wallpaper again.
  </dd> 
  <dt>
   App Widgets
  </dt> 
  <dd>
   Your 
   <a href="../../../guide/topics/appwidgets/index.html">App Widget</a> will be removed from the home screen. When external storage is remounted, your App Widget will 
   <em>not</em> be available for the user to select until the system resets the home application (usually not until a system reboot).
  </dd> 
  <dt>
   Account Managers
  </dt> 
  <dd>
   Your accounts created with 
   <code><a href="../../../reference/android/accounts/AccountManager.html">AccountManager</a></code> will disappear until external storage is remounted.
  </dd> 
  <dt>
   Sync Adapters
  </dt> 
  <dd>
   Your 
   <code><a href="../../../reference/android/content/AbstractThreadedSyncAdapter.html">AbstractThreadedSyncAdapter</a></code> and all its sync functionality will not work until external storage is remounted.
  </dd> 
  <dt>
   Device Administrators
  </dt> 
  <dd>
   Your 
   <code><a href="../../../reference/android/app/admin/DeviceAdminReceiver.html">DeviceAdminReceiver</a></code> and all its admin capabilities will be disabled, which can have unforeseeable consequences for the device functionality, which may persist after external storage is remounted.
  </dd> 
  <dt>
   Broadcast Receivers listening for &quot;boot completed&quot;
  </dt> 
  <dd>
   The system delivers the 
   <code><a href="../../../reference/android/content/Intent.html#ACTION_BOOT_COMPLETED">ACTION_BOOT_COMPLETED</a></code> broadcast before the external storage is mounted to the device. If your application is installed on the external storage, it can never receive this broadcast.
  </dd> 
 </dl> 
 <p>If your application uses any of the features listed above, you <strong>should not</strong> allow your application to install on external storage. By default, the system <em>will not</em> allow your application to install on the external storage, so you don't need to worry about your existing applications. However, if you're certain that your application should never be installed on the external storage, then you should make this clear by declaring <a href="../../../guide/topics/manifest/manifest-element.html#install"><code>android:installLocation</code></a> with a value of &quot;<code>internalOnly</code>&quot;. Though this does not change the default behavior, it explicitly states that your application should only be installed on the internal storage and serves as a reminder to you and other developers that this decision has been made.</p> 
 ","AlarmManager","android.app.AlarmManager","class",1
,"App Install Location","Applications That Should NOT Install on External Storage","<h2 id="ShouldNot">Applications That Should NOT Install on External Storage</h2> 
 <p>When the user enables USB mass storage to share files with their computer (or otherwise unmounts or removes the external storage), any application installed on the external storage and currently running is killed. The system effectively becomes unaware of the application until mass storage is disabled and the external storage is remounted on the device. Besides killing the application and making it unavailable to the user, this can break some types of applications in a more serious way. In order for your application to consistently behave as expected, you <strong>should not</strong> allow your application to be installed on the external storage if it uses any of the following features, due to the cited consequences when the external storage is unmounted:</p> 
 <dl> 
  <dt>
   Services
  </dt> 
  <dd>
   Your running 
   <code><a href="../../../reference/android/app/Service.html">Service</a></code> will be killed and will not be restarted when external storage is remounted. You can, however, register for the 
   <code><a href="../../../reference/android/content/Intent.html#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE">ACTION_EXTERNAL_APPLICATIONS_AVAILABLE</a></code> broadcast Intent, which will notify your application when applications installed on external storage have become available to the system again. At which time, you can restart your Service.
  </dd> 
  <dt>
   Alarm Services
  </dt> 
  <dd>
   Your alarms registered with 
   <code><a href="../../../reference/android/app/AlarmManager.html">AlarmManager</a></code> will be cancelled. You must manually re-register any alarms when external storage is remounted.
  </dd> 
  <dt>
   Input Method Engines
  </dt> 
  <dd>
   Your 
   <a href="../../../guide/topics/text/creating-input-method.html">IME</a> will be replaced by the default IME. When external storage is remounted, the user can open system settings to enable your IME again.
  </dd> 
  <dt>
   Live Wallpapers
  </dt> 
  <dd>
   Your running 
   <a href="http://android-developers.blogspot.com/2010/02/live-wallpapers.html">Live Wallpaper</a> will be replaced by the default Live Wallpaper. When external storage is remounted, the user can select your Live Wallpaper again.
  </dd> 
  <dt>
   App Widgets
  </dt> 
  <dd>
   Your 
   <a href="../../../guide/topics/appwidgets/index.html">App Widget</a> will be removed from the home screen. When external storage is remounted, your App Widget will 
   <em>not</em> be available for the user to select until the system resets the home application (usually not until a system reboot).
  </dd> 
  <dt>
   Account Managers
  </dt> 
  <dd>
   Your accounts created with 
   <code><a href="../../../reference/android/accounts/AccountManager.html">AccountManager</a></code> will disappear until external storage is remounted.
  </dd> 
  <dt>
   Sync Adapters
  </dt> 
  <dd>
   Your 
   <code><a href="../../../reference/android/content/AbstractThreadedSyncAdapter.html">AbstractThreadedSyncAdapter</a></code> and all its sync functionality will not work until external storage is remounted.
  </dd> 
  <dt>
   Device Administrators
  </dt> 
  <dd>
   Your 
   <code><a href="../../../reference/android/app/admin/DeviceAdminReceiver.html">DeviceAdminReceiver</a></code> and all its admin capabilities will be disabled, which can have unforeseeable consequences for the device functionality, which may persist after external storage is remounted.
  </dd> 
  <dt>
   Broadcast Receivers listening for &quot;boot completed&quot;
  </dt> 
  <dd>
   The system delivers the 
   <code><a href="../../../reference/android/content/Intent.html#ACTION_BOOT_COMPLETED">ACTION_BOOT_COMPLETED</a></code> broadcast before the external storage is mounted to the device. If your application is installed on the external storage, it can never receive this broadcast.
  </dd> 
 </dl> 
 <p>If your application uses any of the features listed above, you <strong>should not</strong> allow your application to install on external storage. By default, the system <em>will not</em> allow your application to install on the external storage, so you don't need to worry about your existing applications. However, if you're certain that your application should never be installed on the external storage, then you should make this clear by declaring <a href="../../../guide/topics/manifest/manifest-element.html#install"><code>android:installLocation</code></a> with a value of &quot;<code>internalOnly</code>&quot;. Though this does not change the default behavior, it explicitly states that your application should only be installed on the internal storage and serves as a reminder to you and other developers that this decision has been made.</p> 
 ","Service","android.app.Service","class",0
,"App Install Location","Applications That Should NOT Install on External Storage","<h2 id="ShouldNot">Applications That Should NOT Install on External Storage</h2> 
 <p>When the user enables USB mass storage to share files with their computer (or otherwise unmounts or removes the external storage), any application installed on the external storage and currently running is killed. The system effectively becomes unaware of the application until mass storage is disabled and the external storage is remounted on the device. Besides killing the application and making it unavailable to the user, this can break some types of applications in a more serious way. In order for your application to consistently behave as expected, you <strong>should not</strong> allow your application to be installed on the external storage if it uses any of the following features, due to the cited consequences when the external storage is unmounted:</p> 
 <dl> 
  <dt>
   Services
  </dt> 
  <dd>
   Your running 
   <code><a href="../../../reference/android/app/Service.html">Service</a></code> will be killed and will not be restarted when external storage is remounted. You can, however, register for the 
   <code><a href="../../../reference/android/content/Intent.html#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE">ACTION_EXTERNAL_APPLICATIONS_AVAILABLE</a></code> broadcast Intent, which will notify your application when applications installed on external storage have become available to the system again. At which time, you can restart your Service.
  </dd> 
  <dt>
   Alarm Services
  </dt> 
  <dd>
   Your alarms registered with 
   <code><a href="../../../reference/android/app/AlarmManager.html">AlarmManager</a></code> will be cancelled. You must manually re-register any alarms when external storage is remounted.
  </dd> 
  <dt>
   Input Method Engines
  </dt> 
  <dd>
   Your 
   <a href="../../../guide/topics/text/creating-input-method.html">IME</a> will be replaced by the default IME. When external storage is remounted, the user can open system settings to enable your IME again.
  </dd> 
  <dt>
   Live Wallpapers
  </dt> 
  <dd>
   Your running 
   <a href="http://android-developers.blogspot.com/2010/02/live-wallpapers.html">Live Wallpaper</a> will be replaced by the default Live Wallpaper. When external storage is remounted, the user can select your Live Wallpaper again.
  </dd> 
  <dt>
   App Widgets
  </dt> 
  <dd>
   Your 
   <a href="../../../guide/topics/appwidgets/index.html">App Widget</a> will be removed from the home screen. When external storage is remounted, your App Widget will 
   <em>not</em> be available for the user to select until the system resets the home application (usually not until a system reboot).
  </dd> 
  <dt>
   Account Managers
  </dt> 
  <dd>
   Your accounts created with 
   <code><a href="../../../reference/android/accounts/AccountManager.html">AccountManager</a></code> will disappear until external storage is remounted.
  </dd> 
  <dt>
   Sync Adapters
  </dt> 
  <dd>
   Your 
   <code><a href="../../../reference/android/content/AbstractThreadedSyncAdapter.html">AbstractThreadedSyncAdapter</a></code> and all its sync functionality will not work until external storage is remounted.
  </dd> 
  <dt>
   Device Administrators
  </dt> 
  <dd>
   Your 
   <code><a href="../../../reference/android/app/admin/DeviceAdminReceiver.html">DeviceAdminReceiver</a></code> and all its admin capabilities will be disabled, which can have unforeseeable consequences for the device functionality, which may persist after external storage is remounted.
  </dd> 
  <dt>
   Broadcast Receivers listening for &quot;boot completed&quot;
  </dt> 
  <dd>
   The system delivers the 
   <code><a href="../../../reference/android/content/Intent.html#ACTION_BOOT_COMPLETED">ACTION_BOOT_COMPLETED</a></code> broadcast before the external storage is mounted to the device. If your application is installed on the external storage, it can never receive this broadcast.
  </dd> 
 </dl> 
 <p>If your application uses any of the features listed above, you <strong>should not</strong> allow your application to install on external storage. By default, the system <em>will not</em> allow your application to install on the external storage, so you don't need to worry about your existing applications. However, if you're certain that your application should never be installed on the external storage, then you should make this clear by declaring <a href="../../../guide/topics/manifest/manifest-element.html#install"><code>android:installLocation</code></a> with a value of &quot;<code>internalOnly</code>&quot;. Though this does not change the default behavior, it explicitly states that your application should only be installed on the internal storage and serves as a reminder to you and other developers that this decision has been made.</p> 
 ","AbstractThreadedSyncAdapter","android.content.AbstractThreadedSyncAdapter","class",1
,"App Install Location","Applications That Should NOT Install on External Storage","<h2 id="ShouldNot">Applications That Should NOT Install on External Storage</h2> 
 <p>When the user enables USB mass storage to share files with their computer (or otherwise unmounts or removes the external storage), any application installed on the external storage and currently running is killed. The system effectively becomes unaware of the application until mass storage is disabled and the external storage is remounted on the device. Besides killing the application and making it unavailable to the user, this can break some types of applications in a more serious way. In order for your application to consistently behave as expected, you <strong>should not</strong> allow your application to be installed on the external storage if it uses any of the following features, due to the cited consequences when the external storage is unmounted:</p> 
 <dl> 
  <dt>
   Services
  </dt> 
  <dd>
   Your running 
   <code><a href="../../../reference/android/app/Service.html">Service</a></code> will be killed and will not be restarted when external storage is remounted. You can, however, register for the 
   <code><a href="../../../reference/android/content/Intent.html#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE">ACTION_EXTERNAL_APPLICATIONS_AVAILABLE</a></code> broadcast Intent, which will notify your application when applications installed on external storage have become available to the system again. At which time, you can restart your Service.
  </dd> 
  <dt>
   Alarm Services
  </dt> 
  <dd>
   Your alarms registered with 
   <code><a href="../../../reference/android/app/AlarmManager.html">AlarmManager</a></code> will be cancelled. You must manually re-register any alarms when external storage is remounted.
  </dd> 
  <dt>
   Input Method Engines
  </dt> 
  <dd>
   Your 
   <a href="../../../guide/topics/text/creating-input-method.html">IME</a> will be replaced by the default IME. When external storage is remounted, the user can open system settings to enable your IME again.
  </dd> 
  <dt>
   Live Wallpapers
  </dt> 
  <dd>
   Your running 
   <a href="http://android-developers.blogspot.com/2010/02/live-wallpapers.html">Live Wallpaper</a> will be replaced by the default Live Wallpaper. When external storage is remounted, the user can select your Live Wallpaper again.
  </dd> 
  <dt>
   App Widgets
  </dt> 
  <dd>
   Your 
   <a href="../../../guide/topics/appwidgets/index.html">App Widget</a> will be removed from the home screen. When external storage is remounted, your App Widget will 
   <em>not</em> be available for the user to select until the system resets the home application (usually not until a system reboot).
  </dd> 
  <dt>
   Account Managers
  </dt> 
  <dd>
   Your accounts created with 
   <code><a href="../../../reference/android/accounts/AccountManager.html">AccountManager</a></code> will disappear until external storage is remounted.
  </dd> 
  <dt>
   Sync Adapters
  </dt> 
  <dd>
   Your 
   <code><a href="../../../reference/android/content/AbstractThreadedSyncAdapter.html">AbstractThreadedSyncAdapter</a></code> and all its sync functionality will not work until external storage is remounted.
  </dd> 
  <dt>
   Device Administrators
  </dt> 
  <dd>
   Your 
   <code><a href="../../../reference/android/app/admin/DeviceAdminReceiver.html">DeviceAdminReceiver</a></code> and all its admin capabilities will be disabled, which can have unforeseeable consequences for the device functionality, which may persist after external storage is remounted.
  </dd> 
  <dt>
   Broadcast Receivers listening for &quot;boot completed&quot;
  </dt> 
  <dd>
   The system delivers the 
   <code><a href="../../../reference/android/content/Intent.html#ACTION_BOOT_COMPLETED">ACTION_BOOT_COMPLETED</a></code> broadcast before the external storage is mounted to the device. If your application is installed on the external storage, it can never receive this broadcast.
  </dd> 
 </dl> 
 <p>If your application uses any of the features listed above, you <strong>should not</strong> allow your application to install on external storage. By default, the system <em>will not</em> allow your application to install on the external storage, so you don't need to worry about your existing applications. However, if you're certain that your application should never be installed on the external storage, then you should make this clear by declaring <a href="../../../guide/topics/manifest/manifest-element.html#install"><code>android:installLocation</code></a> with a value of &quot;<code>internalOnly</code>&quot;. Though this does not change the default behavior, it explicitly states that your application should only be installed on the internal storage and serves as a reminder to you and other developers that this decision has been made.</p> 
 ","Intent","android.content.Intent","class",1
